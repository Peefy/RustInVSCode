
# Rustç¬”è®°

## Rustå®‰è£…

å¯¹äºLinuxæˆ–è€…macOSï¼Œä½¿ç”¨ç»ˆç«¯å¹¶è¿è¡Œå¦‚ä¸‹å‘½ä»¤ï¼š

```
$ curl https://sh.rustup.rs -sSf | sh
```

å¯¹äºWindowsï¼Œ[å®‰è£…é“¾æ¥](https://www.rust-lang.org/tools/install)ï¼Œä»¥åŠVS2013æˆ–æ›´é«˜ç‰ˆæœ¬çš„C++ç”Ÿæˆå·¥å…·ï¼Œæˆ–è€…ä½¿ç”¨VS2019ç›´æ¥å®‰è£…ã€‚

## ç¬¬ä¸€ä¸ªRustç¨‹åº

```rust
fn main() {
    println!("Hello, world!");
}
```

æ³¨æ„ï¼Œ`println!`è°ƒç”¨Rustå®ã€‚å¦‚æœæ”¹ä¸ºè°ƒç”¨å‡½æ•°ï¼Œåˆ™å°†å…¶è¾“å…¥ä¸º`printlnï¼ˆä¸å¸¦!ï¼‰`

## RuståŒ…ç®¡ç†å™¨Cargo

Cargoæ˜¯Rustçš„æ„å»ºç³»ç»Ÿå’ŒåŒ…ç®¡ç†å™¨ã€‚å¤§å¤šæ•°Rustaceansä½¿ç”¨æ­¤å·¥å…·æ¥ç®¡ç†ä»–ä»¬çš„Rusté¡¹ç›®ï¼Œå› ä¸ºCargoä¼šä¸ºå¤„ç†å¾ˆå¤šä»»åŠ¡ï¼Œä¾‹å¦‚æ„å»ºä»£ç ï¼Œä¸‹è½½ä»£ç æ‰€ä¾èµ–çš„åº“ä»¥åŠæ„å»ºè¿™äº›åº“ã€‚

Cargo.toml

```
[package]
name = "hello_cargo"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]
edition = "2018"

[dependencies]
```

ç¬¬ä¸€è¡Œ`[package]`æ˜¯èŠ‚æ ‡é¢˜ï¼ŒæŒ‡ç¤ºä»¥ä¸‹è¯­å¥æ­£åœ¨é…ç½®ç¨‹åºåŒ…ã€‚å½“å‘è¯¥æ–‡ä»¶æ·»åŠ æ›´å¤šä¿¡æ¯æ—¶ï¼Œå°†æ·»åŠ å…¶ä»–éƒ¨åˆ†ã€‚

æ¥ä¸‹æ¥çš„å››è¡Œè®¾ç½®äº†Cargoç¼–è¯‘ç¨‹åºæ‰€éœ€çš„é…ç½®ä¿¡æ¯ï¼šåç§°ï¼Œç‰ˆæœ¬ï¼Œç¼–å†™è€…ä»¥åŠè¦ä½¿ç”¨çš„Rustç‰ˆæœ¬ã€‚Cargoä»çš„ç¯å¢ƒä¸­è·å–çš„å§“åå’Œç”µå­é‚®ä»¶ä¿¡æ¯ï¼Œå› æ­¤ï¼Œå¦‚æœè¯¥ä¿¡æ¯ä¸æ­£ç¡®ï¼Œè¯·ç«‹å³ä¿®å¤æ­¤ä¿¡æ¯ï¼Œç„¶åä¿å­˜æ–‡ä»¶ã€‚å°†editionåœ¨é™„å½•Eä¸­è®¨è®ºå¯†é’¥ã€‚

æœ€åä¸€è¡Œ`[dependencies]`æ˜¯è¯¥éƒ¨åˆ†çš„å¼€å¤´ï¼Œå¯ä»¥åˆ—å‡ºé¡¹ç›®çš„ä»»ä½•ä¾èµ–é¡¹ã€‚

## Rustç¨‹åºè¿›é˜¶

```rust
use std::io; // æ ‡å‡†åº“

/* ä¸»å‡½æ•°å£°æ˜ */
fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    /* å¯å˜å˜é‡ */
    let mut guess = String::new();

    /* ä¼ å˜é‡çš„å¼•ç”¨ */
    io::stdin().read_line(&mut guess)
        .expect("Failed to read line");  /* std::result::Result */

    /* ä½¿ç”¨println!å ä½ç¬¦æ‰“å°å€¼ */
    println!("You guessed: {}", guess);

    /* å®šä¹‰ä¸å¯å˜å˜é‡ */
    let x = 5;
    let y = 10;

    println!("x = {} and y = {}", x, y);

}
```

æœ€åä½¿ç”¨`cargo run`æŒ‡ä»¤è¿è¡Œç¨‹åºï¼Œä½¿ç”¨`cargo build`æ„å»ºé¡¹ç›®ï¼Œ

**ä½¿ç”¨Cargo.lockæ–‡ä»¶ç¡®ä¿å¯å¤åˆ¶çš„å†…éƒ¨ç‰ˆæœ¬**

Cargoå…·æœ‰ä¸€ç§æœºåˆ¶ï¼Œå¯ç¡®ä¿æˆ–å…¶ä»–ä»»ä½•äººæ¯æ¬¡æ„å»ºä»£ç æ—¶éƒ½å¯ä»¥é‡å»ºç›¸åŒçš„å·¥ä»¶ï¼šCargoå°†ä»…ä½¿ç”¨æŒ‡å®šçš„ä¾èµ–é¡¹ç‰ˆæœ¬ï¼Œé™¤éå¦æœ‰è¯´æ˜ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä¸‹å‘¨å‘å¸ƒçš„ç‰ˆæœ¬ä¸º0.5.6çš„randåŒ…

**äº§ç”Ÿä¸€ä¸ªéšæœºæ•°**

```rust
use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
```

**æ¯”è¾ƒçŒœæµ‹äºç§˜å¯†å·ç **

```rust
use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin().read_line(&mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}

```

## RuståŸºæœ¬æ¦‚å¿µ

### Rustå˜é‡å’Œå¯å˜æ€§

é»˜è®¤æƒ…å†µä¸‹å˜é‡æ˜¯ä¸å¯å˜çš„ã€‚è¿™æ˜¯Rustæ¨åŠ¨ç¼–å†™ä»£ç çš„ä¸€ç§æ–¹å¼ï¼Œå®ƒå¯ä»¥åˆ©ç”¨Rustæä¾›çš„å®‰å…¨æ€§å’Œæ˜“å¹¶å‘æ€§ã€‚ä½†æ˜¯ï¼Œä»ç„¶å¯ä»¥é€‰æ‹©ä½¿å˜é‡å¯å˜ã€‚è®©æ¢è®¨ä¸€ä¸‹Rustå¦‚ä½•ä»¥åŠä¸ºä»€ä¹ˆé¼“åŠ±æ”¯æŒä¸å˜æ€§ï¼Œä»¥åŠä¸ºä»€ä¹ˆæœ‰æ—¶å¯èƒ½æƒ³è¦é€€å‡ºã€‚

å½“å˜é‡æ˜¯ä¸å¯å˜çš„æ—¶ï¼Œå°†å€¼ç»‘å®šåˆ°åç§°åï¼Œå°±æ— æ³•æ›´æ”¹è¯¥å€¼ã€‚ä¸ºäº†è¯´æ˜è¿™ä¸€ç‚¹ï¼Œä½¿ç”¨æ¥ åœ¨é¡¹ç›®ç›®å½•ä¸­ç”Ÿæˆä¸€ä¸ªåä¸ºå˜é‡çš„æ–°é¡¹ç›®ã€‚

```rust
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    // x = 6;   //error!
    println!("The value of x is: {}", x);
}
```

#### å˜é‡å’Œå¸¸é‡ä¹‹é—´çš„å·®å¼‚

æ— æ³•æ›´æ”¹å˜é‡çš„å€¼å¯èƒ½ä½¿æƒ³èµ·äº†å¤§å¤šæ•°å…¶ä»–è¯­è¨€éƒ½å…·æœ‰çš„å¦ä¸€ä¸ªç¼–ç¨‹æ¦‚å¿µï¼šå¸¸é‡ã€‚åƒä¸å¯å˜å˜é‡ä¸€æ ·ï¼Œå¸¸é‡æ˜¯ç»‘å®šåˆ°åç§°ä¸”ä¸å…è®¸æ›´æ”¹çš„å€¼ï¼Œä½†æ˜¯å¸¸é‡å’Œå˜é‡ä¹‹é—´å­˜åœ¨ä¸€äº›å·®å¼‚ã€‚

é¦–å…ˆï¼Œä¸å…è®¸ä½¿ç”¨`mut`å¸¸é‡ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå¸¸é‡ä¸ä»…æ˜¯ä¸å¯å˜çš„ï¼Œå®ƒä»¬å§‹ç»ˆæ˜¯ä¸å¯å˜çš„ã€‚

å¯ä»¥ä½¿ç”¨`const`å…³é”®å­—è€Œä¸æ˜¯å…³é”®å­—å£°æ˜å¸¸é‡letï¼Œå¹¶ä¸”å€¼çš„ç±»å‹å¿…é¡»å¸¦æœ‰æ³¨é‡Šã€‚

å¯ä»¥åœ¨ä»»ä½•èŒƒå›´ï¼ˆåŒ…æ‹¬å…¨å±€èŒƒå›´ï¼‰ä¸­å£°æ˜å¸¸é‡ï¼Œè¿™ä½¿å®ƒä»¬å¯¹äºè®¸å¤šä»£ç éƒ¨åˆ†éœ€è¦äº†è§£çš„å€¼å¾ˆæœ‰ç”¨ã€‚

æœ€åä¸€ä¸ªåŒºåˆ«æ˜¯ï¼Œåªèƒ½å°†å¸¸é‡è®¾ç½®ä¸ºå¸¸é‡è¡¨è¾¾å¼ï¼Œè€Œä¸æ˜¯å‡½æ•°è°ƒç”¨çš„ç»“æœæˆ–åªèƒ½åœ¨è¿è¡Œæ—¶è®¡ç®—çš„ä»»ä½•å…¶ä»–å€¼ã€‚

è¿™æ˜¯ä¸€ä¸ªå¸¸é‡å£°æ˜çš„ç¤ºä¾‹ï¼Œå…¶ä¸­å¸¸é‡çš„åç§°ä¸º `MAX_POINTS`ï¼Œå…¶å€¼è®¾ç½®ä¸º100,000ã€‚ï¼ˆRustå¸¸é‡çš„å‘½åçº¦å®šæ˜¯ä½¿ç”¨æ‰€æœ‰å¤§å†™å­—æ¯åœ¨å•è¯ä¹‹é—´ä½¿ç”¨ä¸‹åˆ’çº¿ï¼Œå¹¶ä¸”å¯ä»¥åœ¨æ•°å­—æ–‡å­—ä¸­æ’å…¥ä¸‹åˆ’çº¿ä»¥æé«˜å¯è¯»æ€§ï¼‰

```rust
fn main() {
const MAX_POINTS: u32 = 100_000;
}
```

### Rustæ•°æ®ç±»å‹

Rustä¸­çš„æ¯ä¸ªå€¼éƒ½å…·æœ‰ç‰¹å®šçš„æ•°æ®ç±»å‹ï¼Œå®ƒå‘Šè¯‰RustæŒ‡å®šäº†å“ªç§æ•°æ®ï¼Œå› æ­¤çŸ¥é“å¦‚ä½•ä½¿ç”¨è¯¥æ•°æ®ã€‚å°†ç ”ç©¶ä¸¤ä¸ªæ•°æ®ç±»å‹å­é›†ï¼šæ ‡é‡å’Œå¤åˆã€‚

è¯·è®°ä½ï¼ŒRustæ˜¯ä¸€ç§é™æ€ç±»å‹çš„è¯­è¨€ï¼Œè¿™æ„å‘³ç€å®ƒå¿…é¡»åœ¨ç¼–è¯‘æ—¶çŸ¥é“æ‰€æœ‰å˜é‡çš„ç±»å‹ã€‚ç¼–è¯‘å™¨é€šå¸¸å¯ä»¥æ ¹æ®å€¼ä»¥åŠå¦‚ä½•ä½¿ç”¨å®ƒæ¥æ¨æ–­è¦ä½¿ç”¨çš„ç±»å‹ã€‚åœ¨å½“è®¸å¤šç±»å‹æ˜¯å¯èƒ½çš„ï¼Œ

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

#### æ ‡é‡ç±»å‹

æ ‡é‡ç±»å‹è¡¨ç¤ºä¸€ä¸ªå•ä¸€çš„å€¼ã€‚Rustå…·æœ‰å››ç§ä¸»è¦çš„æ ‡é‡ç±»å‹ï¼šæ•´æ•°ï¼Œæµ®ç‚¹æ•°ï¼Œå¸ƒå°”å€¼å’Œå­—ç¬¦ã€‚å¯èƒ½ä¼šä»å…¶ä»–ç¼–ç¨‹è¯­è¨€ä¸­è¯†åˆ«è¿™äº›ã€‚è®©è·³åˆ°ä»–ä»¬åœ¨Rustä¸­çš„å·¥ä½œæ–¹å¼ã€‚

##### æ•´æ•°ç±»å‹

ä¸€ä¸ªæ•´æ•°æ˜¯æ²¡æœ‰å°æ•°éƒ¨åˆ†çš„æ•°ã€‚åœ¨ç¬¬2ç« ä¸­ï¼Œä½¿ç”¨äº†ä¸€ç§æ•´æ•°`u32`ç±»å‹ã€‚æ­¤ç±»å‹å£°æ˜è¡¨ç¤ºä¸ä¹‹å…³è”çš„å€¼åº”ä¸ºå ç”¨32ä½ç©ºé—´çš„æ— ç¬¦å·æ•´æ•°ï¼ˆæœ‰ç¬¦å·æ•´æ•°ç±»å‹ä»¥å¼€å¤´`i`ï¼Œè€Œä¸æ˜¯`u`ï¼‰ã€‚è¡¨3-1æ˜¾ç¤ºäº†Rustä¸­çš„å†…ç½®æ•´æ•°ç±»å‹ã€‚`Signed`å’Œ`Unsigned`åˆ—ä¸­çš„æ¯ä¸ªå˜ä½“ï¼ˆä¾‹å¦‚`i16`ï¼‰éƒ½å¯ä»¥ç”¨æ¥å£°æ˜æ•´æ•°å€¼çš„ç±»å‹ã€‚

é•¿åº¦|	ç¬¦å·|	æ— ç¬¦å·
-|-|-
8ä½|	i8|	u8
16ä½|	i16|	u16
32ä½|	i32|	u32
64ä½|	i64|	u64
128ä½|	i128|	u128

æ¯ä¸ªå˜ä½“å¯ä»¥æ˜¯æœ‰ç¬¦å·çš„ä¹Ÿå¯ä»¥æ˜¯æ— ç¬¦å·çš„ï¼Œå¹¶ä¸”å…·æœ‰æ˜ç¡®çš„å¤§å°ã€‚ å¸¦ç¬¦å·å’Œæ— ç¬¦å·è¡¨ç¤ºæ•°å­—æ˜¯è´Ÿæ•°è¿˜æ˜¯æ­£æ•°ï¼Œæ¢å¥è¯è¯´ï¼Œæ•°å­—æ˜¯å¦éœ€è¦å¸¦æœ‰æ­£è´Ÿå·ï¼ˆå¸¦æ­£è´Ÿå·ï¼‰ï¼Œæˆ–è€…æ•°å­—å°†æ°¸è¿œæ˜¯æ­£æ•°ï¼Œå› æ­¤å¯ä»¥ä¸å¸¦æ­£è´Ÿå·è¡¨ç¤ºï¼ˆæœªç­¾åï¼‰ã€‚è¿™å°±åƒåœ¨çº¸ä¸Šå†™æ•°å­—ä¸€æ ·ï¼šå½“ç¬¦å·å¾ˆé‡è¦æ—¶ï¼Œæ•°å­—ä¸Šä¼šæ˜¾ç¤ºåŠ å·æˆ–å‡å·ã€‚ä½†æ˜¯ï¼Œå¯ä»¥æ”¾å¿ƒåœ°å‡è®¾æ•°å­—ä¸ºæ­£æ•°æ—¶ï¼Œå®ƒä¸ä¼šæ˜¾ç¤ºä»»ä½•ç¬¦å·ã€‚å¸¦ç¬¦å·çš„æ•°å­—ä½¿ç”¨äºŒè¿›åˆ¶è¡¥ç è¡¨ç¤ºå­˜å‚¨ã€‚

æ¯ä¸ªå¸¦ç¬¦å·çš„å˜é‡å¯ä»¥å­˜å‚¨\[-2^{n - 1}\]åˆ°\[ 2^{n-1}-1 \]ä¹‹é—´çš„æ•°å­—ï¼Œå…¶ä¸­næ˜¯å˜é‡ä½¿ç”¨çš„ä½æ•°ã€‚å› æ­¤ï¼Œä¸€ä¸ª `i8`å¯ä»å­˜å‚¨-128è‡³127ï¼Œå…¶ç­‰äº-128åˆ°127æ— ç¬¦å·çš„å˜ä½“å¯ä»¥å­˜å‚¨ä»0ç¼–å·.

æ­¤å¤–ï¼Œ`isize`å’Œ`usize`ç±»å‹å–å†³äºçš„ç¨‹åºæ‰€è¿è¡Œçš„è®¡ç®—æœºç±»å‹ï¼šå¦‚æœä½¿ç”¨çš„æ˜¯64ä½ä½“ç³»ç»“æ„ï¼Œåˆ™ä¸º64ä½ï¼›å¦‚æœä½¿ç”¨çš„æ˜¯32ä½ä½“ç³»ç»“æ„ï¼Œåˆ™ä¸º32ä½ã€‚

æ•°å­—æ–‡å­—|	ä¾‹
-|-
å°æ•°|	`98_222`
åå…­è¿›åˆ¶|	`0xff`
å…«è¿›åˆ¶|	`0o77`
äºŒå…ƒ|	`0b1111_0000`
å­—èŠ‚ï¼ˆ`u8`ï¼‰|	`b'A'`

##### æµ®ç‚¹ç±»å‹

Rustå¯¹äºæµ®ç‚¹æ•°ä¹Ÿæœ‰ä¸¤ç§åŸå§‹ç±»å‹ï¼Œå³å¸¦å°æ•°ç‚¹çš„æ•°å­—ã€‚Rustçš„æµ®ç‚¹ç±»å‹ä¸ºf32å’Œf64ï¼Œå¤§å°åˆ†åˆ«ä¸º32ä½å’Œ64ä½ã€‚é»˜è®¤ç±»å‹æ˜¯f64 å› ä¸ºåœ¨ç°ä»£CPUä¸Šï¼Œå®ƒçš„é€Ÿåº¦ä¸ä¹‹å¤§è‡´ç›¸åŒï¼Œf32ä½†ç²¾åº¦æ›´é«˜ã€‚

##### æ•°å€¼è¿ç®—

Rustæ”¯æŒæœŸæœ›æ‰€æœ‰æ•°å­—ç±»å‹çš„åŸºæœ¬æ•°å­¦è¿ç®—ï¼šåŠ ï¼Œå‡ï¼Œä¹˜ï¼Œé™¤å’Œä½™æ•°ã€‚ä»¥ä¸‹ä»£ç æ˜¾ç¤ºäº†å¦‚ä½•åœ¨letè¯­å¥ä¸­ä½¿ç”¨æ¯ä¸ªä»£ç 

```rust
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;

    // remainder
    let remainder = 43 % 5;
}
```

##### å¸ƒå°”ç±»å‹

ä¸å¤§å¤šæ•°å…¶ä»–ç¼–ç¨‹è¯­è¨€ä¸€æ ·ï¼ŒRustä¸­çš„å¸ƒå°”ç±»å‹å…·æœ‰ä¸¤ä¸ªå¯èƒ½çš„å€¼ï¼štrueå’Œfalseã€‚å¸ƒå°”å€¼çš„å¤§å°ä¸º1ä¸ªå­—èŠ‚ã€‚Rustä¸­çš„å¸ƒå°”ç±»å‹ä½¿ç”¨æŒ‡å®šboolã€‚ä¾‹å¦‚ï¼š

```rust
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
```

##### å­—ç¬¦ç±»å‹

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œä»…å¤„ç†æ•°å­—ï¼Œä½†æ˜¯Rustä¹Ÿæ”¯æŒå­—æ¯ã€‚Rustçš„ charç±»å‹æ˜¯è¯¥è¯­è¨€æœ€åŸå§‹çš„å­—æ¯ç±»å‹ï¼Œä¸‹é¢çš„ä»£ç æ˜¾ç¤ºäº†ä¸€ç§ä½¿ç”¨å®ƒçš„æ–¹å¼ã€‚ï¼ˆè¯·æ³¨æ„ï¼Œcharæ–‡å­—æ˜¯ç”¨å•å¼•å·æŒ‡å®šçš„ï¼Œè€Œå­—ç¬¦ä¸²æ–‡å­—æ˜¯ä½¿ç”¨åŒå¼•å·çš„ã€‚ï¼‰

```rust
fn main() {
    let c = 'z';
    let z = 'â„¤';
    let heart_eyed_cat = 'ğŸ˜»';
}
```

Rustçš„`char`ç±»å‹ä¸º4ä¸ªå­—èŠ‚ï¼Œä»£è¡¨Unicodeæ ‡é‡å€¼ï¼Œè¿™æ„å‘³ç€å®ƒå¯ä»¥ä»£è¡¨çš„ä¸ä»…ä»…æ˜¯ASCIIã€‚é‡éŸ³å­—æ¯ï¼›ä¸­æ–‡ï¼Œæ—¥æ–‡å’ŒéŸ©æ–‡å­—ç¬¦ï¼›è¡¨æƒ…ç¬¦å· å’Œé›¶å®½åº¦ç©ºæ ¼charåœ¨Rust ä¸­éƒ½æ˜¯æœ‰æ•ˆå€¼ã€‚Unicodeæ ‡å€¼çš„èŒƒå›´ä»`U+0000`åˆ° `U+D7FF`å’Œ`U+E000`åˆ°`U+10FFFF`åŒ…å®¹æ€§ã€‚ä½†æ˜¯ï¼Œâ€œå­—ç¬¦â€åœ¨Unicodeä¸­å¹¶ä¸æ˜¯çœŸæ­£çš„æ¦‚å¿µï¼Œå› æ­¤å¯¹â€œå­—ç¬¦â€æ˜¯ä»€ä¹ˆçš„ç›´è§‰å¯èƒ½ä¸`char`Rustä¸­çš„a ä¸ä¸€è‡´ã€‚

##### å¤åˆç±»å‹

å¤åˆç±»å‹å¯ä»¥å°†å¤šä¸ªå€¼ç»„åˆä¸ºä¸€ç§ç±»å‹ã€‚Rustæœ‰ä¸¤ç§åŸå§‹çš„å¤åˆç±»å‹ï¼šå…ƒç»„å’Œæ•°ç»„ã€‚

###### å…ƒç»„ç±»å‹

å…ƒç»„æ˜¯ä¸€ç§å°†å¤šç§ç±»å‹çš„å€¼ç»„åˆä¸ºä¸€ä¸ªå¤åˆç±»å‹çš„ä¸€èˆ¬æ–¹æ³•ã€‚å…ƒç»„çš„é•¿åº¦æ˜¯å›ºå®šçš„ï¼šå£°æ˜åï¼Œå®ƒä»¬çš„å¤§å°å°±æ— æ³•å¢é•¿æˆ–ç¼©å°ã€‚

é€šè¿‡åœ¨æ‹¬å·å†…ç¼–å†™é€—å·åˆ†éš”çš„å€¼åˆ—è¡¨æ¥åˆ›å»ºå…ƒç»„ã€‚å…ƒç»„ä¸­çš„æ¯ä¸ªä½ç½®éƒ½æœ‰ä¸€ä¸ªç±»å‹ï¼Œå¹¶ä¸”å…ƒç»„ä¸­ä¸åŒå€¼çš„ç±»å‹ä¸å¿…ç›¸åŒã€‚åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œæ·»åŠ äº†å¯é€‰çš„ç±»å‹æ³¨é‡Šï¼š

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
    let (x, y, z) = tup;
    println!("The value of y is: {}", y);
}
```

ç¨‹åºé¦–å…ˆåˆ›å»ºä¸€ä¸ªå…ƒç»„å¹¶å°†å…¶ç»‘å®šåˆ°å˜é‡`tup`ã€‚ç„¶åï¼Œå®ƒä½¿ç”¨å¸¦æœ‰`let`é‡‡å–`tup`å¹¶æŠŠå®ƒå˜æˆä¸‰ä¸ªç‹¬ç«‹çš„å˜é‡`x`ï¼Œ`y`å’Œ`z`ã€‚è¿™ç§°ä¸ºè§£æ„ï¼Œå› ä¸ºå®ƒå°†å•ä¸ªå…ƒç»„åˆ†ä¸ºä¸‰éƒ¨åˆ†ã€‚æœ€åï¼Œç¨‹åºå°†è¾“å‡ºçš„å€¼ `y`ï¼Œå³`6.4`ã€‚

é™¤äº†é€šè¿‡æ¨¡å¼åŒ¹é…è¿›è¡Œç»“æ„åˆ†è§£ä¹‹å¤–ï¼Œè¿˜å¯ä»¥é€šè¿‡ä½¿ç”¨å¥ç‚¹ï¼ˆ.ï¼‰å’Œè¦è®¿é—®çš„å€¼çš„ç´¢å¼•ç›´æ¥è®¿é—®å…ƒç»„å…ƒç´ ã€‚ä¾‹å¦‚ï¼š

```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```

###### æ•°ç»„ç±»å‹

æ”¶é›†å¤šä¸ªå€¼çš„å¦ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨æ•°ç»„ã€‚ä¸å…ƒç»„ä¸åŒï¼Œæ•°ç»„çš„æ¯ä¸ªå…ƒç´ éƒ½å¿…é¡»å…·æœ‰ç›¸åŒçš„ç±»å‹ã€‚Rustä¸­çš„æ•°ç»„ä¸æŸäº›å…¶ä»–è¯­è¨€ä¸­çš„æ•°ç»„ä¸åŒï¼Œå› ä¸ºRustä¸­çš„æ•°ç»„å…·æœ‰å›ºå®šé•¿åº¦ï¼Œä¾‹å¦‚å…ƒç»„ã€‚

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

å½“å¸Œæœ›å°†æ•°æ®åˆ†é…åœ¨å †æ ˆè€Œä¸æ˜¯å †ä¸Šæ—¶ï¼ˆå½“åœ¨ç¬¬4ç« ä¸­è®¨è®ºå †æ ˆå’Œå †æ—¶ï¼‰ï¼Œæˆ–è€…è¦ç¡®ä¿å§‹ç»ˆæ‹¥æœ‰å›ºå®šæ•°é‡çš„å…ƒç´ æ—¶ï¼Œæ•°ç»„å¾ˆæœ‰ç”¨ã€‚ä½†æ˜¯ï¼Œæ•°ç»„ä¸åƒçŸ¢é‡ç±»å‹é‚£æ ·çµæ´»ã€‚è½½ä½“æ˜¯ç”±æ ‡å‡†åº“æä¾›ä¸€ä¸ªç±»ä¼¼é›†åˆç±»å‹æ˜¯å…è®¸ç”Ÿé•¿æˆ–å°ºå¯¸çš„ç¼©å°ã€‚å¦‚æœä¸ç¡®å®šä½¿ç”¨æ•°ç»„è¿˜æ˜¯å®¹å™¨ï¼Œåˆ™å¯èƒ½åº”è¯¥ä½¿ç”¨å®¹å™¨ã€‚

ä¸€ä¸ªç¨‹åºå¯èƒ½éœ€è¦ä½¿ç”¨æ•°ç»„è€Œä¸æ˜¯å®¹å™¨ï¼Œä¾‹å¦‚ï¼Œè¯¥ç¨‹åºéœ€è¦çŸ¥é“ä¸€å¹´ä¸­å„ä¸ªæœˆä»½çš„åç§°ã€‚è¿™æ ·çš„ç¨‹åºä¸å¤ªå¯èƒ½éœ€è¦æ·»åŠ æˆ–åˆ é™¤æœˆä»½ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨æ•°ç»„ï¼Œå› ä¸ºçŸ¥é“å®ƒå°†å§‹ç»ˆåŒ…å«12ä¸ªå…ƒç´ ï¼š

```rust

#![allow(unused_variables)]
fn main() {
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
}
```

å°†ä½¿ç”¨æ–¹æ‹¬å·ç¼–å†™æ•°ç»„çš„ç±»å‹ï¼Œå¹¶ä¸”åœ¨æ–¹æ‹¬å·å†…åŒ…æ‹¬æ¯ä¸ªå…ƒç´ çš„ç±»å‹ï¼Œåˆ†å·ï¼Œç„¶åæ˜¯æ•°ç»„ä¸­å…ƒç´ çš„æ•°é‡ï¼Œå¦‚ä¸‹æ‰€ç¤º

```rust

#![allow(unused_variables)]
fn main() {
let a: [i32; 5] = [1, 2, 3, 4, 5];
}
```

åœ¨è¿™é‡Œï¼Œ`i32`æ˜¯æ¯ä¸ªå…ƒç´ çš„ç±»å‹ã€‚åˆ†å·åçš„æ•°å­—`5` è¡¨ç¤ºæ•°ç»„åŒ…å«äº”ä¸ªå…ƒç´ ã€‚

ä»¥è¿™ç§æ–¹å¼ç¼–å†™æ•°ç»„çš„ç±»å‹çœ‹èµ·æ¥ç±»ä¼¼äºåˆå§‹åŒ–æ•°ç»„çš„å¦ä¸€ç§è¯­æ³•ï¼šå¦‚æœè¦åˆ›å»ºä¸€ä¸ªæ•°ç»„ï¼Œè¯¥æ•°ç»„çš„æ¯ä¸ªå…ƒç´ éƒ½åŒ…å«ç›¸åŒçš„å€¼ï¼Œåˆ™å¯ä»¥æŒ‡å®šåˆå§‹å€¼ï¼Œåè·Ÿä¸€ä¸ªåˆ†å·ï¼Œç„¶åæŒ‡å®šé•¿åº¦æ•°ç»„æ”¾åœ¨æ–¹æ‹¬å·ä¸­ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```rust

#![allow(unused_variables)]
fn main() {
let a = [3; 5];
}
```

åä¸ºçš„æ•°ç»„`a`å°†åŒ…å«`5`å°†å…¨éƒ¨è®¾ç½®ä¸º`3`åˆå§‹å€¼çš„å…ƒç´  ã€‚è¿™ä¸å†™ä½œç›¸åŒï¼Œ`let a = [3, 3, 3, 3, 3]`;ä½†æ›´ä¸ºç®€æ´ã€‚

###### è®¿é—®æ•°ç»„å…ƒç´ 

æ•°ç»„æ˜¯åœ¨å †æ ˆä¸Šåˆ†é…çš„å•ä¸ªå†…å­˜å—ã€‚å¯ä»¥ä½¿ç”¨ç´¢å¼•è®¿é—®æ•°ç»„çš„å…ƒç´ ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}

```

åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œåä¸ºçš„å˜é‡`first`å°†è·å¾—å€¼`1`ï¼Œå› ä¸ºè¿™æ˜¯`[0]`æ•°ç»„ä¸­indexå¤„çš„å€¼ã€‚åä¸ºçš„å˜é‡`second`å°†ä»æ•°ç»„ä¸­çš„`2`ç´¢å¼•è·å–å€¼`[1]`ã€‚

### Rustå‡½æ•°

Rustä»£ç ä¸­æ™®éå­˜åœ¨å‡½æ•°ã€‚å·²ç»çœ‹åˆ°äº†è¯¥è¯­è¨€ä¸­æœ€é‡è¦çš„åŠŸèƒ½ä¹‹ä¸€ï¼šmainå‡½æ•°ï¼Œå®ƒæ˜¯è®¸å¤šç¨‹åºçš„å…¥å£ç‚¹ã€‚è¿˜çœ‹åˆ°äº†fnå…³é”®å­—ï¼Œè¯¥å…³é”®å­—ä½¿å¯ä»¥å£°æ˜æ–°åŠŸèƒ½ã€‚

Rustä»£ç ä½¿ç”¨è›‡å½¢å¤§å°å†™ä½œä¸ºå‡½æ•°å’Œå˜é‡åçš„å¸¸è§„æ ·å¼ã€‚åœ¨è›‡å½¢çš„æƒ…å†µä¸‹ï¼Œæ‰€æœ‰å­—æ¯å‡ä¸ºå°å†™ï¼Œå¹¶åœ¨ä¸‹åˆ’çº¿åˆ†å¼€å•è¯ã€‚è¿™æ˜¯ä¸€ä¸ªåŒ…å«ç¤ºä¾‹å‡½æ•°å®šä¹‰çš„ç¨‹åºï¼š

```rust
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}

```

Rustä¸­çš„å‡½æ•°å®šä¹‰ä»¥`fn`å‡½æ•°åç§°å¼€å¤´ï¼Œå¹¶åœ¨å‡½æ•°åç§°åå¸¦æœ‰ä¸€ç»„æ‹¬å·ã€‚å¤§æ‹¬å·å‘Šè¯‰ç¼–è¯‘å™¨å‡½æ•°ä½“çš„å¼€å§‹å’Œç»“æŸä½ç½®ã€‚

å¯ä»¥è°ƒç”¨å®šä¹‰çš„ä»»ä½•å‡½æ•°ï¼Œæ–¹æ³•æ˜¯è¾“å…¥å…¶åç§°ï¼Œç„¶åè¾“å…¥ä¸€ç»„æ‹¬å·ã€‚å› ä¸º`another_function`æ˜¯åœ¨ç¨‹åºä¸­å®šä¹‰çš„ï¼Œæ‰€ä»¥å¯ä»¥ä»`main`å‡½æ•°å†…éƒ¨è°ƒç”¨å®ƒã€‚æ³¨æ„ï¼Œåœ¨æºä»£ç ä¸­çš„å‡½æ•°`another_function` ä¹‹åå®šä¹‰`main`ï¼›æœ¬æ¥ä¹Ÿå¯ä»¥å®šä¹‰å®ƒã€‚Rustä¸åœ¨ä¹åœ¨ä½•å¤„å®šä¹‰å‡½æ•°ï¼Œåªéœ€åœ¨æŸä¸ªåœ°æ–¹å®šä¹‰å®ƒä»¬å³å¯ã€‚

è®©å¼€å§‹ä¸€ä¸ªæ–°çš„åä¸ºå‡½æ•°çš„äºŒè¿›åˆ¶é¡¹ç›®ï¼Œä»¥è¿›ä¸€æ­¥æ¢ç´¢å‡½æ•°ã€‚å°†another_functionç¤ºä¾‹æ”¾åœ¨src / main.rsä¸­å¹¶è¿è¡Œå®ƒã€‚åº”è¯¥çœ‹åˆ°ä»¥ä¸‹è¾“å‡ºï¼š

#### å‡½æ•°å‚æ•°

ä¹Ÿå¯ä»¥å°†å‡½æ•°å®šä¹‰ä¸ºå…·æœ‰parametersï¼Œparametersæ˜¯ä½œä¸ºå‡½æ•°ç­¾åä¸€éƒ¨åˆ†çš„ç‰¹æ®Šå˜é‡ã€‚å½“å‡½æ•°å…·æœ‰å‚æ•°æ—¶ï¼Œå¯ä»¥ä¸ºå…¶æä¾›è¿™äº›å‚æ•°çš„å…·ä½“å€¼ã€‚ä»æŠ€æœ¯ä¸Šè®²ï¼Œå…·ä½“å€¼ç§°ä¸ºè‡ªå˜é‡ï¼Œä½†æ˜¯åœ¨éšæ„çš„äº¤è°ˆä¸­ï¼Œäººä»¬å€¾å‘äºå°†å‚æ•°å’Œè‡ªå˜é‡ä¸€è¯äº¤æ›¿ç”¨äºå‡½æ•°å®šä¹‰ä¸­çš„å˜é‡æˆ–è°ƒç”¨å‡½æ•°æ—¶ä¼ é€’çš„å…·ä½“å€¼ã€‚

ä»¥ä¸‹é‡å†™çš„ç‰ˆæœ¬`another_function`æ˜¾ç¤ºäº†Rustä¸­çš„å‚æ•°ï¼š

```rust
fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("The value of x is: {}", x);
}

```

å½“å¸Œæœ›ä¸€ä¸ªå‡½æ•°å…·æœ‰å¤šä¸ªå‚æ•°æ—¶ï¼Œè¯·ç”¨é€—å·åˆ†éš”å‚æ•°å£°æ˜ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```rust
fn main() {
    another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
    println!("The value of x is: {}", x);
    println!("The value of y is: {}", y);
}
```

#### å‡½æ•°å®ä½“åŒ…å«è¯­å¥å’Œè¡¨è¾¾å¼

å‡½æ•°ä½“ç”±ä¸€ç³»åˆ—å¯é€‰åœ°ä»¥è¡¨è¾¾å¼ç»“å°¾çš„è¯­å¥ç»„æˆã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼Œä»…ä»‹ç»äº†æ²¡æœ‰ç»“å°¾è¡¨è¾¾å¼çš„å‡½æ•°ï¼Œä½†æ˜¯å·²ç»å°†è¡¨è¾¾å¼è§†ä¸ºè¯­å¥çš„ä¸€éƒ¨åˆ†ã€‚ç”±äºRustæ˜¯ä¸€ç§åŸºäºè¡¨è¾¾å¼çš„è¯­è¨€ï¼Œå› æ­¤è¿™æ˜¯éœ€è¦ç†è§£çš„é‡è¦åŒºåˆ«ã€‚å…¶ä»–è¯­è¨€æ²¡æœ‰ç›¸åŒçš„åŒºåˆ«ï¼Œå› æ­¤è®©çœ‹çœ‹ä»€ä¹ˆæ˜¯è¯­å¥å’Œè¡¨è¾¾å¼ä»¥åŠå®ƒä»¬çš„å·®å¼‚å¦‚ä½•å½±å“å‡½æ•°ä½“ã€‚

å®é™…ä¸Šå·²ç»ä½¿ç”¨è¿‡è¯­å¥å’Œè¡¨è¾¾å¼ã€‚è¯­å¥æ˜¯æ‰§è¡ŒæŸäº›æ“ä½œä¸”ä¸è¿”å›å€¼çš„æŒ‡ä»¤ã€‚è¡¨è¾¾å¼çš„ è®¡ç®—ç»“æœä¸ºç»“æœå€¼ã€‚è®©çœ‹ä¸€äº›ä¾‹å­ã€‚

åˆ›å»ºå˜é‡å¹¶ä½¿ç”¨`let`å…³é”®å­—ä¸ºå…¶åˆ†é…å€¼æ˜¯ä¸€æ¡è¯­å¥ã€‚

```rust
fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
```

æ˜¯åœ¨è¿™ç§æƒ…å†µä¸‹æ±‚å€¼ä¸ºçš„å—`4`ã€‚è¯¥å€¼ç»‘å®š`y` ä¸º`let`è¯­å¥çš„ä¸€éƒ¨åˆ†ã€‚è¯·æ³¨æ„ï¼Œè¯¥`x + 1`è¡Œçš„æœ«å°¾æ²¡æœ‰åˆ†å·ï¼Œè¿™ä¸åˆ°ç›®å‰ä¸ºæ­¢æ‰€çœ‹åˆ°çš„å¤§å¤šæ•°è¡Œä¸åŒã€‚è¡¨è¾¾å¼ä¸åŒ…æ‹¬ç»“å°¾åˆ†å·ã€‚å¦‚æœåœ¨è¡¨è¾¾å¼çš„æœ«å°¾æ·»åŠ åˆ†å·ï¼Œåˆ™å°†å…¶å˜æˆä¸€æ¡è¯­å¥ï¼Œç„¶åè¯¥è¯­å¥å°†ä¸è¿”å›å€¼ã€‚åœ¨æ¥ä¸‹æ¥æ¢ç´¢å‡½æ•°è¿”å›å€¼å’Œè¡¨è¾¾å¼æ—¶ï¼Œè¯·è®°ä½è¿™ä¸€ç‚¹ã€‚

#### å…·æœ‰è¿”å›å€¼çš„å‡½æ•°

å‡½æ•°å¯ä»¥å°†å€¼è¿”å›åˆ°è°ƒç”¨å®ƒä»¬çš„ä»£ç ä¸­ã€‚æ²¡æœ‰å‘½åè¿”å›å€¼ï¼Œä½†ç¡®å®åœ¨ç®­å¤´ï¼ˆ`->`ï¼‰åå£°æ˜äº†å®ƒä»¬çš„ç±»å‹ã€‚åœ¨Rustä¸­ï¼Œå‡½æ•°çš„è¿”å›å€¼ä¸å‡½æ•°ä¸»ä½“å—ä¸­æœ€ç»ˆè¡¨è¾¾å¼çš„å€¼åŒä¹‰ã€‚å¯ä»¥é€šè¿‡ä½¿ç”¨`return`å…³é”®å­—å¹¶æŒ‡å®šå€¼ä»å‡½æ•°ä¸­æå‰è¿”å›ï¼Œä½†æ˜¯å¤§å¤šæ•°å‡½æ•°éƒ½éšå¼è¿”å›æœ€åä¸€ä¸ªè¡¨è¾¾å¼ã€‚è¿™æ˜¯ä¸€ä¸ªè¿”å›å€¼çš„å‡½æ•°çš„ç¤ºä¾‹ï¼š

```rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}

```

å‡½æ•°ä¸­æ²¡æœ‰å‡½æ•°è°ƒç”¨ï¼Œå®ç”šè‡³`let`è¯­å¥ï¼Œ`five` ä»…æ˜¯æ•°å­—`5`æœ¬èº«ã€‚åœ¨Rustä¸­ï¼Œè¿™æ˜¯ä¸€ä¸ªéå¸¸æœ‰æ•ˆçš„å‡½æ•°ã€‚è¯·æ³¨æ„ï¼Œå‡½æ•°çš„è¿”å›ç±»å‹ä¹ŸæŒ‡å®šä¸º`-> i32`.

### Rustæ³¨é‡Š

æ‰€æœ‰ç¨‹åºå‘˜éƒ½åŠªåŠ›ä½¿ä»–ä»¬çš„ä»£ç æ˜“äºç†è§£ï¼Œä½†æ˜¯æœ‰æ—¶éœ€è¦é¢å¤–çš„è¯´æ˜ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç¨‹åºå‘˜åœ¨å…¶æºä»£ç ä¸­ç•™ä¸‹æ³¨é‡Šæˆ– æ³¨é‡Šï¼Œç¼–è¯‘å™¨å°†å¿½ç•¥å®ƒä»¬ï¼Œä½†é˜…è¯»æºä»£ç çš„äººå¯èƒ½ä¼šå‘ç°æœ‰ç”¨ã€‚

è¿™æ˜¯ä¸€ä¸ªç®€å•çš„æ³¨é‡Šï¼š

```rust

#![allow(unused_variables)]
fn main() {
// hello, world
}
```

### Rustæ§åˆ¶æµ

ä¸€ç§`if`è¡¨è¾¾å¼å…è®¸åˆ†æ”¯æ ¹æ®æ¡ä»¶çš„ä»£ç ã€‚æä¾›ä¸€ä¸ªæ¡ä»¶ï¼Œç„¶åè¯´ï¼šâ€œå¦‚æœæ»¡è¶³æ­¤æ¡ä»¶ï¼Œè¯·è¿è¡Œæ­¤ä»£ç å—ã€‚å¦‚æœä¸æ»¡è¶³æ¡ä»¶ï¼Œè¯·ä¸è¦è¿è¡Œæ­¤ä»£ç å—ã€‚â€

```rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
```

å¯é€‰åœ°ï¼Œè¿˜å¯ä»¥åŒ…æ‹¬ä¸€ä¸ª`else`è¡¨è¾¾å¼ï¼Œåœ¨æ­¤å¤„é€‰æ‹©äº†è¯¥è¡¨è¾¾å¼ï¼Œä»¥åœ¨æ¡ä»¶è¯„ä¼°ä¸ºfalseæ—¶ä¸ºç¨‹åºæä¾›æ›¿ä»£çš„ä»£ç å—æ¥æ‰§è¡Œã€‚å¦‚æœä¸æä¾›`else`è¡¨è¾¾å¼ä¸”æ¡ä»¶ä¸ºå‡ï¼Œåˆ™ç¨‹åºå°†è·³è¿‡è¯¥ifå—å¹¶ç»§ç»­æ‰§è¡Œä¸‹ä¸€éƒ¨åˆ†ä»£ç ã€‚

```rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```

#### ä½¿ç”¨ifçš„letè¯­å¥

å› ä¸ºifæ˜¯è¡¨è¾¾å¼ï¼Œæ‰€ä»¥å¯ä»¥åœ¨let è¯­å¥çš„å³ä¾§ä½¿ç”¨å®ƒï¼Œ

```rust
fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    println!("The value of number is: {}", number);
}
```

#### å¾ªç¯é‡å¤

`loop`,`while`,`for`

```rust
fn main() {
    loop {
        println!("again!");
    }
}
```

##### ä»å¾ªç¯è¿”å›å€¼

açš„ç”¨é€”ä¹‹ä¸€loopæ˜¯é‡è¯•çŸ¥é“å¯èƒ½ä¼šå¤±è´¥çš„æ“ä½œï¼Œä¾‹å¦‚æ£€æŸ¥çº¿ç¨‹æ˜¯å¦å·²å®Œæˆå…¶å·¥ä½œã€‚ä½†æ˜¯ï¼Œå¯èƒ½éœ€è¦å°†è¯¥æ“ä½œçš„ç»“æœä¼ é€’ç»™å…¶ä½™ä»£ç ã€‚ä¸ºæ­¤ï¼Œå¯ä»¥åœ¨breakåœæ­¢å¾ªç¯çš„è¡¨è¾¾å¼åæ·»åŠ è¦è¿”å›çš„å€¼ã€‚è¯¥å€¼å°†ä»å¾ªç¯ä¸­è¿”å›ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨å®ƒï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}
```

##### æœ‰æ¡ä»¶å¾ªç¯ while

å¯¹äºç¨‹åºè€Œè¨€ï¼Œåœ¨å¾ªç¯ä¸­è¯„ä¼°æ¡ä»¶é€šå¸¸å¾ˆæœ‰ç”¨ã€‚å½“æ¡ä»¶ä¸ºçœŸæ—¶ï¼Œå¾ªç¯è¿è¡Œã€‚å½“æ¡ä»¶ä¸å†ä¸ºçœŸæ—¶ï¼Œç¨‹åºå°†è°ƒç”¨breakï¼Œä»è€Œåœæ­¢å¾ªç¯ã€‚è¿™ä¸ªç¯å‹å¯ä½¿ç”¨çš„ç»„åˆæ¥å®ç°loopï¼Œifï¼Œelseï¼Œå’Œbreak; å¯ä»¥æ ¹æ®éœ€è¦åœ¨ç¨‹åºä¸­ç«‹å³å°è¯•ã€‚

```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
```

##### éå†ä¸€ä¸ªé›†åˆ for

å¯ä»¥ä½¿ç”¨è¯¥whileæ„é€ éå†é›†åˆçš„å…ƒç´ ï¼Œä¾‹å¦‚æ•°ç»„ã€‚

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
```

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!("the value is: {}", element);
    }
}
```

forå¾ªç¯çš„å®‰å…¨æ€§å’Œç®€æ´æ€§ä½¿å…¶æˆä¸ºRustä¸­æœ€å¸¸ç”¨çš„å¾ªç¯æ„é€ ã€‚å³ä½¿åœ¨æƒ³è¦å¤šæ¬¡è¿è¡ŒæŸäº›ä»£ç çš„æƒ…å†µä¸‹ï¼ˆä¾‹å¦‚whileæ¸…å•3-3 ä¸­ä½¿ç”¨å¾ªç¯çš„å€’è®¡æ—¶ç¤ºä¾‹ï¼‰ï¼Œå¤§å¤šæ•°Rustaceansä¹Ÿä¼šä½¿ç”¨forå¾ªç¯ã€‚è¿™æ ·åšçš„æ–¹æ³•æ˜¯ä½¿ç”¨Rangeï¼Œè¿™æ˜¯æ ‡å‡†åº“æä¾›çš„ä¸€ç§ç±»å‹ï¼Œå®ƒæŒ‰é¡ºåºç”Ÿæˆæ‰€æœ‰æ•°å­—ï¼Œä»ä¸€ä¸ªæ•°å­—å¼€å§‹åˆ°å¦ä¸€ä¸ªæ•°å­—ä¹‹å‰ç»“æŸã€‚

```rust
fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}
```

### Rustæ‰€æœ‰æƒ

Rustçš„ä¸»è¦ç‰¹å¾æ˜¯æ‰€æœ‰æƒã€‚å°½ç®¡è¯¥åŠŸèƒ½æ˜“äºè§£é‡Šï¼Œä½†å¯¹å…¶ä½™è¯­è¨€æœ‰æ·±è¿œçš„å½±å“ã€‚

æ‰€æœ‰ç¨‹åºå¿…é¡»åœ¨è¿è¡Œæ—¶ç®¡ç†å®ƒä»¬ä½¿ç”¨è®¡ç®—æœºå†…å­˜çš„æ–¹å¼ã€‚æŸäº›è¯­è¨€å…·æœ‰åƒåœ¾å›æ”¶åŠŸèƒ½ï¼Œè¯¥åƒåœ¾å›æ”¶åŠŸèƒ½ä¼šåœ¨ç¨‹åºè¿è¡Œæ—¶ä¸æ–­å¯»æ‰¾ä¸å†ä½¿ç”¨çš„å†…å­˜ã€‚åœ¨å…¶ä»–è¯­è¨€ä¸­ï¼Œç¨‹åºå‘˜å¿…é¡»æ˜¾å¼åˆ†é…å’Œé‡Šæ”¾å†…å­˜ã€‚Rustä½¿ç”¨ç¬¬ä¸‰ç§æ–¹æ³•ï¼šé€šè¿‡æ‰€æœ‰æƒç³»ç»Ÿç®¡ç†å†…å­˜ï¼Œè¯¥ç³»ç»Ÿå…·æœ‰ä¸€ç»„åœ¨ç¼–è¯‘æ—¶æ£€æŸ¥çš„è§„åˆ™ã€‚ç¨‹åºè¿è¡Œæ—¶ï¼Œæ‰€æœ‰æ‰€æœ‰æƒåŠŸèƒ½éƒ½ä¸ä¼šå‡æ…¢å…¶è¿è¡Œé€Ÿåº¦ã€‚

å› ä¸ºæ‰€æœ‰æƒæ˜¯è®¸å¤šç¨‹åºå‘˜çš„æ–°æ¦‚å¿µï¼Œæ‰€ä»¥å®ƒç¡®å®éœ€è¦ä¸€äº›æ—¶é—´æ¥ä¹ æƒ¯ã€‚å¥½æ¶ˆæ¯æ˜¯ï¼Œå¯¹Rustå’Œæ‰€æœ‰æƒç³»ç»Ÿçš„è§„åˆ™è¶Šæœ‰ç»éªŒï¼Œå°±è¶Šèƒ½è‡ªç„¶å¼€å‘å®‰å…¨æœ‰æ•ˆçš„ä»£ç ã€‚ç»§ç»­å§ï¼

äº†è§£æ‰€æœ‰æƒåï¼Œå°†æ‹¥æœ‰åšå®çš„åŸºç¡€ï¼Œå¯ä»¥ç†è§£ä½¿Rustç‹¬æ ‘ä¸€å¸œçš„åŠŸèƒ½ã€‚åœ¨æœ¬ç« ä¸­ï¼Œå°†é€šè¿‡ä¸€äº›é’ˆå¯¹éå¸¸å¸¸è§çš„æ•°æ®ç»“æ„çš„ç¤ºä¾‹æ¥å­¦ä¹ æ‰€æœ‰æƒï¼šå­—ç¬¦ä¸²ã€‚

åœ¨è®¸å¤šç¼–ç¨‹è¯­è¨€ä¸­ï¼Œä¸å¿…ç»å¸¸è€ƒè™‘å †æ ˆå’Œå †ã€‚ä½†æ˜¯åœ¨åƒRustè¿™æ ·çš„ç³»ç»Ÿç¼–ç¨‹è¯­è¨€ä¸­ï¼Œå€¼æ˜¯åœ¨å †æ ˆä¸Šè¿˜æ˜¯åœ¨å †ä¸Šå¯¹è¯­è¨€çš„è¡Œä¸ºä»¥åŠä¸ºä»€ä¹ˆå¿…é¡»åšå‡ºæŸäº›å†³å®šçš„å½±å“æ›´å¤§ã€‚æ‰€æœ‰æƒçš„å„ä¸ªéƒ¨åˆ†å°†åœ¨æœ¬ç« åé¢çš„å †æ ˆå’Œå †ä¸­è¿›è¡Œä»‹ç»ï¼Œå› æ­¤è¿™é‡Œæ˜¯å‡†å¤‡å·¥ä½œçš„ç®€è¦è¯´æ˜ã€‚

å †æ ˆå’Œå †éƒ½æ˜¯å†…å­˜çš„ä¸€éƒ¨åˆ†ï¼Œçš„ä»£ç å¯åœ¨è¿è¡Œæ—¶ä½¿ç”¨ï¼Œä½†æ˜¯å®ƒä»¬çš„ç»“æ„ä¸åŒã€‚å †æ ˆæŒ‰è·å–å€¼çš„é¡ºåºå­˜å‚¨å€¼ï¼Œå¹¶ä»¥ç›¸åçš„é¡ºåºåˆ é™¤å€¼ã€‚è¿™ç§°ä¸ºåè¿›å…ˆå‡ºã€‚æƒ³æƒ³ä¸€å †ç›˜å­ï¼šæ·»åŠ æ›´å¤šç›˜å­æ—¶ï¼Œå°†å®ƒä»¬æ”¾åœ¨å †çš„é¡¶éƒ¨ï¼Œè€Œå½“éœ€è¦ç›˜å­æ—¶ï¼Œä»é¡¶éƒ¨å–ä¸‹ä¸€ä¸ªç›˜å­ã€‚ä»ä¸­é—´æˆ–åº•éƒ¨æ·»åŠ æˆ–åˆ é™¤æ¿éƒ½æ— æ³•æ­£å¸¸å·¥ä½œï¼æ·»åŠ æ•°æ®ç§°ä¸ºå‹å…¥å †æ ˆï¼Œè€Œåˆ é™¤æ•°æ®ç§°ä¸ºå¼¹å‡ºå †æ ˆã€‚

å †æ ˆä¸­å­˜å‚¨çš„æ‰€æœ‰æ•°æ®å¿…é¡»å…·æœ‰å·²çŸ¥çš„å›ºå®šå¤§å°ã€‚ç¼–è¯‘æ—¶å¤§å°æœªçŸ¥æˆ–å¤§å°å¯èƒ½æ›´æ”¹çš„æ•°æ®å¿…é¡»å­˜å‚¨åœ¨å †ä¸­ã€‚å †çš„ç»„ç»‡æ€§è¾ƒå·®ï¼šå°†æ•°æ®æ”¾åœ¨å †ä¸Šæ—¶ï¼Œéœ€è¦ä¸€å®šæ•°é‡çš„ç©ºé—´ã€‚æ“ä½œç³»ç»Ÿåœ¨å †ä¸­æ‰¾åˆ°ä¸€ä¸ªè¶³å¤Ÿå¤§çš„ç©ºç™½ç‚¹ï¼Œå°†å…¶æ ‡è®°ä¸ºæ­£åœ¨ä½¿ç”¨ä¸­ï¼Œç„¶åè¿”å›ä¸€ä¸ª æŒ‡é’ˆï¼Œè¯¥æŒ‡é’ˆæ˜¯è¯¥ä½ç½®çš„åœ°å€ã€‚æ­¤è¿‡ç¨‹ç§°ä¸º åœ¨å †ä¸Šåˆ†é…ï¼Œæœ‰æ—¶ä¹Ÿç®€ç§°ä¸ºallocatingã€‚å°†å€¼å‹å…¥å †æ ˆä¸è¢«è§†ä¸ºåˆ†é…ã€‚ç”±äºæŒ‡é’ˆæ˜¯å·²çŸ¥çš„å›ºå®šå¤§å°ï¼Œå› æ­¤å¯ä»¥å°†æŒ‡é’ˆå­˜å‚¨åœ¨å †æ ˆä¸Šï¼Œä½†æ˜¯å½“éœ€è¦å®é™…æ•°æ®æ—¶ï¼Œå¿…é¡»éµå¾ªæŒ‡é’ˆã€‚

#### Rustæ‰€æœ‰æƒè§„åˆ™

* Rustä¸­çš„æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªå˜é‡ï¼Œç§°ä¸ºå…¶æ‰€æœ‰è€…ã€‚
* ä¸€æ¬¡åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…ã€‚
* å½“æ‰€æœ‰è€…è¶…å‡ºèŒƒå›´æ—¶ï¼Œè¯¥å€¼å°†è¢«åˆ é™¤

å¯ä»¥æ”¹å˜çš„å­—ç¬¦ä¸²

```rust

#![allow(unused_variables)]
fn main() {
let mut s = String::from("hello");

s.push_str(", world!"); // push_str() appends a literal to a String

println!("{}", s); // This will print `hello, world!`
}

```

#### å†…å­˜å’Œåˆ†é…

å¯¹äºå­—ç¬¦ä¸²æ–‡å­—ï¼Œåœ¨ç¼–è¯‘æ—¶å°±çŸ¥é“äº†å†…å®¹ï¼Œå› æ­¤æ–‡æœ¬ç›´æ¥ç¡¬ç¼–ç åˆ°æœ€ç»ˆçš„å¯æ‰§è¡Œæ–‡ä»¶ä¸­ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆå­—ç¬¦ä¸²æ–‡å­—å¿«é€Ÿé«˜æ•ˆçš„åŸå› ã€‚ä½†æ˜¯è¿™äº›å±æ€§ä»…æ¥è‡ªå­—ç¬¦ä¸²æ–‡å­—çš„ä¸å˜æ€§ã€‚ä¸å¹¸çš„æ˜¯ï¼Œå¯¹äºåœ¨ç¼–è¯‘æ—¶æœªçŸ¥å¤§å°ä¸”åœ¨è¿è¡Œç¨‹åºæ—¶å¤§å°å¯èƒ½ä¼šæ”¹å˜çš„æ¯æ®µæ–‡æœ¬ï¼Œæ— æ³•å°†å†…å­˜å—æ”¾å…¥äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ã€‚

**å˜é‡ä¸æ•°æ®äº¤äº’çš„æ–¹å¼ï¼šå…‹éš†**

```rust

#![allow(unused_variables)]
fn main() {
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
}

```

#### Rustå¯æ‹·è´ç±»å‹

* æ‰€æœ‰æ•´æ•°ç±»å‹ï¼Œä¾‹å¦‚u32ã€‚
* å¸ƒå°”ç±»å‹ï¼Œboolå€¼trueå’Œfalseã€‚
* æ‰€æœ‰æµ®ç‚¹ç±»å‹ï¼Œä¾‹å¦‚f64ã€‚
* å­—ç¬¦ç±»å‹charã€‚
* å…ƒç»„ï¼ˆå¦‚æœå®ƒä»¬ä»…åŒ…å«alsoçš„ç±»å‹ï¼‰Copyã€‚ä¾‹å¦‚ï¼Œ (i32, i32)æ˜¯Copyï¼Œä½†(i32, String)ä¸æ˜¯ã€‚

```rust
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so itâ€™s okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.

```

#### è¿”å›å€¼å’ŒèŒƒå›´

è¿”å›å€¼ä¹Ÿå¯ä»¥è½¬ç§»æ‰€æœ‰æƒã€‚

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from("hello");     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
  // moved, so nothing happens. s1 goes out of scope and is dropped.

fn gives_ownership() -> String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from("hello"); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// takes_and_gives_back will take a String and return one
fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
```

å˜é‡çš„æ‰€æœ‰æƒæ¯æ¬¡éƒ½éµå¾ªç›¸åŒçš„æ¨¡å¼ï¼šå°†å€¼åˆ†é…ç»™å¦ä¸€ä¸ªå˜é‡å°†å…¶ç§»åŠ¨ã€‚å½“åŒ…å«å †ä¸Šæ•°æ®çš„å˜é‡è¶…å‡ºèŒƒå›´æ—¶ï¼Œå°†æ¸…é™¤è¯¥å€¼ï¼Œdropé™¤éå·²å°†æ•°æ®ç§»è‡³å¦ä¸€ä¸ªå˜é‡æ‰€æ‹¥æœ‰ã€‚

æ‹¥æœ‰æ‰€æœ‰æƒç„¶åè¿”å›æ‰€æœ‰åŠŸèƒ½çš„æ‰€æœ‰æƒæœ‰ç‚¹ä¹å‘³ã€‚å¦‚æœè¦è®©å‡½æ•°ä½¿ç”¨å€¼è€Œä¸æ˜¯æ‰€æœ‰æƒæ€ä¹ˆåŠï¼Ÿä»¤äººååˆ†çƒ¦æ¼çš„æ˜¯ï¼Œé™¤äº†å¯èƒ½è¿˜æƒ³è¿”å›çš„å‡½æ•°ä¸»ä½“æ‰€äº§ç”Ÿçš„ä»»ä½•æ•°æ®ä¹‹å¤–ï¼Œå¦‚æœæƒ³è¦å†æ¬¡ä½¿ç”¨å®ƒï¼Œåˆ™è¿˜éœ€è¦å°†è¿”å›çš„ä¿¡æ¯ä¼ é€’å›å»ã€‚

å¯ä»¥ä½¿ç”¨å…ƒç»„è¿”å›å¤šä¸ªå€¼ï¼Œ

```rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
```

#### Rustå¼•ç”¨

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

*æ³¨æ„ï¼šä½¿ç”¨`&`è¿›è¡Œå¼•ç”¨çš„åä¹‰è¯æ˜¯è§£å¼•ç”¨ï¼Œè¿™æ˜¯é€šè¿‡è§£å¼•ç”¨è¿ç®—ç¬¦æ¥å®Œæˆçš„`*`ã€‚*

å¦‚æœå˜é‡åœ¨é»˜è®¤æƒ…å†µä¸‹æ˜¯ä¸å¯å˜çš„ï¼Œå¼•ç”¨ä¹Ÿæ˜¯å¦‚æ­¤ï¼Œä¸å…è®¸ä¿®æ”¹å¼•ç”¨çš„å†…å®¹ã€‚

##### å¯å˜å¼•ç”¨

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

ä½†æ˜¯å¯å˜å¼•ç”¨æœ‰ä¸€ä¸ªå¾ˆå¤§çš„é™åˆ¶ï¼šåªèƒ½åœ¨ä¸€ä¸ªç‰¹å®šèŒƒå›´å†…å¯¹ä¸€ä¸ªç‰¹å®šçš„æ•°æ®è¿›è¡Œä¸€ä¸ªå¯å˜å¼•ç”¨ã€‚ä¸‹é¢ä»£ç å°†å¤±è´¥ï¼š

```rust
let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s;

println!("{}, {}", r1, r2);

```

è¯¥é™åˆ¶å…è®¸çªå˜ï¼Œä½†æ˜¯ä»¥éå¸¸å—æ§çš„æ–¹å¼ã€‚è¿™æ˜¯æ–°çš„Rustaceansè‹¦è‹¦æŒ£æ‰çš„äº‹æƒ…ï¼Œå› ä¸ºå¤§å¤šæ•°è¯­è¨€éƒ½å…è®¸éšæ—¶æ›´æ”¹ã€‚

å…·æœ‰æ­¤é™åˆ¶çš„å¥½å¤„æ˜¯Rustå¯ä»¥é˜²æ­¢åœ¨ç¼–è¯‘æ—¶å‘ç”Ÿæ•°æ®äº‰ç”¨ã€‚ä¸€ä¸ªæ•°æ®çš„æ¯”èµ›ç›¸ä¼¼ï¼Œç«äº‰æ¡ä»¶ï¼Œå½“è¿™ä¸‰ç§è¡Œä¸ºçš„å‘ç”Ÿæƒ…å†µï¼š

* ä¸¤ä¸ªæˆ–å¤šä¸ªæŒ‡é’ˆåŒæ—¶è®¿é—®ç›¸åŒçš„æ•°æ®ã€‚
* è‡³å°‘æœ‰ä¸€ä¸ªæŒ‡é’ˆç”¨äºå†™å…¥æ•°æ®ã€‚
* æ²¡æœ‰ç”¨äºåŒæ­¥å¯¹æ•°æ®çš„è®¿é—®çš„æœºåˆ¶ã€‚

ä¸å¾€å¸¸ä¸€æ ·ï¼Œå¯ä»¥ä½¿ç”¨å¤§æ‹¬å·åˆ›å»ºæ–°çš„èŒƒå›´ï¼Œä»è€Œå…è®¸å¤šä¸ªå¯å˜å¼•ç”¨ï¼Œè€Œä¸èƒ½åŒæ—¶å¼•ç”¨ï¼š

```rust
#![allow(unused_variables)]
fn main() {
let mut s = String::from("hello");

{
    let r1 = &mut s;

} // r1 goes out of scope here, so we can make a new reference with no problems.

let r2 = &mut s;
}
```

##### æ‚¬ç©ºå¼•ç”¨

åœ¨å¸¦æœ‰æŒ‡é’ˆçš„è¯­è¨€ä¸­ï¼Œå¾ˆå®¹æ˜“é”™è¯¯åœ°åˆ›å»ºä¸€ä¸ªæ‚¬ç©ºæŒ‡é’ˆï¼Œå³é€šè¿‡åœ¨ä¿ç•™æŒ‡å‘è¯¥å†…å­˜çš„æŒ‡é’ˆçš„åŒæ—¶é‡Šæ”¾ä¸€äº›å†…å­˜æ¥å¼•ç”¨å¯èƒ½å·²åˆ†é…ç»™ä»–äººçš„å†…å­˜ä¸­æŸä¸ªä½ç½®çš„æŒ‡é’ˆã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œåœ¨Rustä¸­ï¼Œç¼–è¯‘å™¨ä¿è¯å¼•ç”¨æ°¸è¿œä¸ä¼šæˆä¸ºæ‚¬æŒ‚å¼•ç”¨ï¼šå¦‚æœå¯¹æŸäº›æ•°æ®å…·æœ‰å¼•ç”¨ï¼Œåˆ™ç¼–è¯‘å™¨å°†ç¡®ä¿æ•°æ®ä¸ä¼šè¶…å‡ºå¯¹æ•°æ®çš„å¼•ç”¨èŒƒå›´ã€‚

è®©å°è¯•åˆ›å»ºä¸€ä¸ªæ‚¬ç©ºçš„å¼•ç”¨ï¼ŒRustå°†é€šè¿‡ç¼–è¯‘æ—¶é”™è¯¯é˜²æ­¢å®ƒï¼š

```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
```

è¿™æ˜¯é”™è¯¯:

```rust
error[E0106]: missing lifetime specifier
 --> main.rs:5:16
  |
5 | fn dangle() -> &String {
  |                ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is
  no value for it to be borrowed from
  = help: consider giving it a 'static lifetime
```

### Ruståˆ‡ç‰‡ç±»å‹

sliceä¹Ÿæ˜¯å¦ä¸€ä¸ªæ²¡æœ‰æ‰€æœ‰æƒçš„æ•°æ®ç±»å‹ã€‚åˆ‡ç‰‡ä½¿å¯ä»¥å¼•ç”¨é›†åˆä¸­è¿ç»­çš„å…ƒç´ åºåˆ—ï¼Œè€Œä¸æ˜¯æ•´ä¸ªé›†åˆã€‚

```rust

#![allow(unused_variables)]
fn main() {
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
}
```

```rust

#![allow(unused_variables)]
fn main() {
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
}
```

è¿™ç±»ä¼¼äºå¯¹æ•´ä½“è¿›è¡Œå¼•ç”¨ï¼Œ`String`ä½†è¦å¤šåŠ ä¸€ `[0..5]`ç‚¹ç‚¹ã€‚è€Œä¸æ˜¯æ•´ä¸ªå‚è€ƒStringï¼Œè€Œæ˜¯å¯¹çš„ä¸€éƒ¨åˆ†çš„å‚è€ƒStringã€‚

é€šè¿‡æŒ‡å®š`[starting_index..ending_index]`ï¼Œå¯ä»¥ä½¿ç”¨æ–¹æ‹¬å·å†…çš„èŒƒå›´æ¥åˆ›å»ºåˆ‡ç‰‡ ï¼Œå…¶ä¸­ï¼Œ`starting_index`æ˜¯åˆ‡ç‰‡ä¸­çš„ç¬¬ä¸€ä¸ªä½ç½®ï¼Œæ¯”åˆ‡ç‰‡ä¸­`ending_index`çš„æœ€åä¸€ä¸ªä½ç½®å¤§ã€‚åœ¨å†…éƒ¨ï¼Œåˆ‡ç‰‡æ•°æ®ç»“æ„å­˜å‚¨åˆ‡ç‰‡çš„èµ·å§‹ä½ç½®å’Œé•¿åº¦ï¼Œè¯¥é•¿åº¦ä¸`ending_indexminus` ç›¸å¯¹åº”`starting_index`ã€‚å› æ­¤ï¼Œåœ¨çš„æƒ…å†µä¸‹`let world = &s[6..11];`ï¼Œ`world`å°†æ˜¯ä¸€ä¸ªåˆ‡ç‰‡ï¼Œè¯¥åˆ‡ç‰‡åŒ…å«ä¸€ä¸ªæŒ‡å‘ç¬¬7ä¸ªå­—èŠ‚ï¼ˆä»1å¼€å§‹ï¼‰çš„æŒ‡é’ˆï¼Œå…¶`s`é•¿åº¦å€¼ä¸º5ã€‚

ä½¿ç”¨Rustçš„..rangeè¯­æ³•ï¼Œå¦‚æœè¦ä»ç¬¬ä¸€ä¸ªç´¢å¼•ï¼ˆé›¶ï¼‰å¼€å§‹ï¼Œåˆ™å¯ä»¥åœ¨ä¸¤ä¸ªå¥ç‚¹ä¹‹å‰åˆ é™¤è¯¥å€¼ã€‚æ¢å¥è¯è¯´ï¼Œè¿™äº›æ˜¯ç›¸ç­‰çš„ï¼š

```rust

#![allow(unused_variables)]
fn main() {
let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2];
}
```

åŒæ ·ï¼Œå¦‚æœçš„åˆ†ç‰‡åŒ…å«çš„æœ€åä¸€ä¸ªå­—èŠ‚ï¼Œåˆ™Stringå¯ä»¥åˆ é™¤å°¾éšæ•°å­—ã€‚è¿™æ„å‘³ç€è¿™äº›æ˜¯ç›¸ç­‰çš„ï¼š

```rust
#![allow(unused_variables)]
fn main() {
let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
}
```

è¿˜å¯ä»¥åˆ é™¤ä¸¤ä¸ªå€¼ä»¥æˆªå–æ•´ä¸ªå­—ç¬¦ä¸²çš„ä¸€éƒ¨åˆ†ã€‚æ‰€ä»¥è¿™äº›æ˜¯ç›¸ç­‰çš„ï¼š

```rust
#![allow(unused_variables)]
fn main() {
let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
}
```

*æ³¨æ„ï¼šå­—ç¬¦ä¸²åˆ‡ç‰‡èŒƒå›´ç´¢å¼•å¿…é¡»å‡ºç°åœ¨æœ‰æ•ˆçš„UTF-8å­—ç¬¦è¾¹ç•Œå¤„ã€‚å¦‚æœå°è¯•åœ¨å¤šå­—èŠ‚å­—ç¬¦çš„ä¸­é—´åˆ›å»ºå­—ç¬¦ä¸²ç‰‡æ®µï¼Œåˆ™ç¨‹åºå°†é€€å‡ºå¹¶æ˜¾ç¤ºé”™è¯¯ã€‚*

```rust

#![allow(unused_variables)]
fn main() {
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
}
```

```rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // error!

    println!("the first word is: {}", word);
}
```

è¿™æ˜¯ç¼–è¯‘å™¨é”™è¯¯ï¼š

```rust
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --> src/main.rs:18:5
   |
16 |     let word = first_word(&s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!("the first word is: {}", word);
   |                                       ---- immutable borrow later used here
```

##### æ•°ç»„åˆ‡ç‰‡

```rust

#![allow(unused_variables)]
fn main() {
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];
}
```

è¯¥åˆ‡ç‰‡å…·æœ‰ç±»å‹`&[i32]`ã€‚é€šè¿‡å­˜å‚¨å¯¹ç¬¬ä¸€ä¸ªå…ƒç´ å’Œé•¿åº¦çš„å¼•ç”¨ï¼Œå®ƒçš„å·¥ä½œæ–¹å¼ä¸å­—ç¬¦ä¸²åˆ‡ç‰‡ç›¸åŒã€‚

### Rustç»“æ„

è¦å®šä¹‰ä¸€ä¸ªç»“æ„ï¼Œè¾“å…¥å…³é”®å­—`struct`å¹¶å‘½åæ•´ä¸ªç»“æ„ã€‚ç»“æ„çš„åç§°åº”è¯´æ˜å°†æ•°æ®åˆ†ç»„åœ¨ä¸€èµ·çš„é‡è¦æ€§ã€‚ç„¶åï¼Œåœ¨å¤§æ‹¬å·å†…ï¼Œå®šä¹‰æ•°æ®æ®µçš„åç§°å’Œç±»å‹ï¼Œå°†å…¶ç§°ä¸ºfieldã€‚

```rust
#![allow(unused_variables)]
fn main() {
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
}
```

è¦åœ¨å®šä¹‰ç»“æ„åä½¿ç”¨ç»“æ„ï¼Œå¯ä»¥é€šè¿‡ä¸ºæ¯ä¸ªå­—æ®µæŒ‡å®šå…·ä½“å€¼æ¥åˆ›å»ºè¯¥ç»“æ„çš„å®ä¾‹ã€‚é€šè¿‡è¯´æ˜ç»“æ„çš„åç§°æ¥åˆ›å»ºå®ä¾‹ï¼Œç„¶åæ·»åŠ åŒ…å«`key: value`å¯¹çš„å¤§æ‹¬å·ï¼Œå…¶ä¸­é”®æ˜¯å­—æ®µçš„åç§°ï¼Œå€¼æ˜¯è¦å­˜å‚¨åœ¨è¿™äº›å­—æ®µä¸­çš„æ•°æ®ã€‚ä¸å¿…æŒ‰ç…§åœ¨ç»“æ„ä¸­å£°æ˜å®ƒä»¬çš„é¡ºåºæ¥æŒ‡å®šå­—æ®µã€‚æ¢å¥è¯è¯´ï¼Œç»“æ„å®šä¹‰å°±åƒè¯¥ç±»å‹çš„é€šç”¨æ¨¡æ¿ï¼Œå®ä¾‹ç”¨ç‰¹å®šçš„æ•°æ®å¡«å……è¯¥æ¨¡æ¿ä»¥åˆ›å»ºè¯¥ç±»å‹çš„å€¼ã€‚

```rust

#![allow(unused_variables)]
fn main() {
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

let mut user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};

user1.email = String::from("anotheremail@example.com");
}

```

#### ä½¿ç”¨ç»“æ„æ›´æ–°è¯­æ³•ä»å…¶ä»–å®ä¾‹åˆ›å»ºå®ä¾‹

```rust

#![allow(unused_variables)]
fn main() {
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

let user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};

let user2 = User {
    email: String::from("another@example.com"),
    username: String::from("anotherusername567"),
    ..user1
};
}
```

#### ä½¿ç”¨æ²¡æœ‰å‘½åå­—æ®µçš„å…ƒç»„ç»“æ„åˆ›å»ºä¸åŒçš„ç±»å‹

è¿˜å¯ä»¥å®šä¹‰çœ‹èµ·æ¥ç±»ä¼¼äºå…ƒç»„çš„ç»“æ„ï¼Œç§°ä¸ºå…ƒç»„ç»“æ„ã€‚å…ƒç»„ç»“æ„å…·æœ‰é™„åŠ çš„å«ä¹‰ï¼Œå³ç»“æ„åç§°æä¾›çš„å«ä¹‰ï¼Œä½†æ²¡æœ‰ä¸å…¶å­—æ®µå…³è”çš„åç§°ï¼›ç›¸åï¼Œå®ƒä»¬åªæ˜¯å­—æ®µçš„ç±»å‹ã€‚å½“æƒ³ç»™æ•´ä¸ªå…ƒç»„èµ·ä¸€ä¸ªåå­—å¹¶ä½¿å…ƒç»„æˆä¸ºä¸å…¶ä»–å…ƒç»„ä¸åŒçš„ç±»å‹æ—¶ï¼Œå…ƒç»„ç»“æ„å¾ˆæœ‰ç”¨ï¼Œå¹¶ä¸”åƒå¸¸è§„ç»“æ„ä¸­é‚£æ ·å‘½åæ¯ä¸ªå­—æ®µéƒ½æ˜¯å†—é•¿æˆ–å¤šä½™çš„ã€‚

è¦å®šä¹‰å…ƒç»„ç»“æ„ï¼Œè¯·ä»`struct`å…³é”®å­—å’Œç»“æ„åç§°å¼€å§‹ï¼Œåè·Ÿå…ƒç»„ä¸­çš„ç±»å‹ã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹æ˜¯ä¸¤ä¸ªåä¸º`Color`å’Œçš„å…ƒç»„ç»“æ„çš„å®šä¹‰å’Œç”¨æ³•`Point`ï¼š

```rust
#![allow(unused_variables)]
fn main() {
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
}
```

è¯·æ³¨æ„ï¼Œ`black`å’Œ`origin`å€¼æ˜¯ä¸åŒçš„ç±»å‹ï¼Œå› ä¸ºå®ƒä»¬æ˜¯ä¸åŒå…ƒç»„ç»“æ„çš„å®ä¾‹ã€‚å®šä¹‰çš„æ¯ä¸ªç»“æ„éƒ½æ˜¯å…¶è‡ªå·±çš„ç±»å‹ï¼Œå³ä½¿è¯¥ç»“æ„ä¸­çš„å­—æ®µå…·æœ‰ç›¸åŒçš„ç±»å‹ã€‚ä¾‹å¦‚ï¼Œå³ä½¿ä¸¤ä¸ªç±»å‹éƒ½ç”±ä¸‰ä¸ªå€¼ç»„æˆï¼Œ`Color`å¸¦æœ‰ç±»å‹å‚æ•°çš„å‡½æ•°ä¹Ÿä¸èƒ½å°†a `Point`ä½œä¸ºå‚æ•°`i32`ã€‚å¦åˆ™ï¼Œå…ƒç»„`struct`å®ä¾‹çš„è¡Œä¸ºç±»ä¼¼äºå…ƒç»„ï¼šå¯ä»¥å°†å®ƒä»¬åˆ†è§£ä¸ºå„è‡ªçš„ç‰‡æ®µï¼Œå¯ä»¥ä½¿ç”¨.åè·Ÿç´¢å¼•çš„ç´¢å¼•æ¥è®¿é—®å•ä¸ªå€¼ï¼Œä¾æ­¤ç±»æ¨ã€‚

#### æ²¡æœ‰ä»»ä½•å­—æ®µçš„ç±»ä¼¼å•å…ƒçš„ç»“æ„

è¿˜å¯ä»¥å®šä¹‰æ²¡æœ‰ä»»ä½•å­—æ®µçš„ç»“æ„ï¼è¿™äº›ä¹‹æ‰€ä»¥ç§°ä¸º å•å…ƒçŠ¶ç»“æ„ï¼Œæ˜¯å› ä¸ºå®ƒä»¬çš„è¡Œä¸ºç±»ä¼¼äº`()`å•å…ƒç±»å‹ã€‚åœ¨éœ€è¦åœ¨æŸç§ç±»å‹ä¸Šå®ç°ç‰¹å¾ä½†åˆä¸æƒ³åœ¨ç±»å‹æœ¬èº«ä¸­å­˜å‚¨ä»»ä½•æ•°æ®çš„æƒ…å†µä¸‹ï¼Œç±»ä¼¼å•å…ƒçš„ç»“æ„å¾ˆæœ‰ç”¨ã€‚

```rust
struct User {
    username: &str,
    email: &str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: "someone@example.com",
        username: "someusername123",
        active: true,
        sign_in_count: 1,
    };
}
```

#### ä½¿ç”¨ç»“æ„çš„ç¤ºä¾‹

```rust
fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        "The area of the rectangle is {} square pixels.",
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -> u32 {
    width * height
}
```

```rust
fn main() {
    let rect1 = (30, 50);

    println!(
        "The area of the rectangle is {} square pixels.",
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -> u32 {
    dimensions.0 * dimensions.1
}
```

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        "The area of the rectangle is {} square pixels.",
        area(&rect1)
    );
}

fn area(rectangle: &Rectangle) -> u32 {
    rectangle.width * rectangle.height
}
```

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!("rect1 is {:?}", rect1);
}
```

### Rustæ–¹æ³•

æ–¹æ³•ç±»ä¼¼äºå‡½æ•°ï¼šå®ƒä»¬ç”¨fnå…³é”®å­—åŠå…¶åç§°å£°æ˜ï¼Œå®ƒä»¬å¯ä»¥å…·æœ‰å‚æ•°å’Œè¿”å›å€¼ï¼Œå¹¶ä¸”å®ƒä»¬åŒ…å«ä¸€äº›ä»å…¶ä»–åœ°æ–¹è°ƒç”¨å®ƒä»¬æ—¶å°†è¿è¡Œçš„ä»£ç ã€‚ä½†æ˜¯ï¼Œæ–¹æ³•ä¸å‡½æ•°çš„ä¸åŒä¹‹å¤„åœ¨äºï¼Œå®ƒä»¬æ˜¯åœ¨structçš„ä¸Šä¸‹æ–‡ä¸­å®šä¹‰çš„ï¼Œå¹¶ä¸”å®ƒä»¬çš„ç¬¬ä¸€ä¸ªå‚æ•°å§‹ç»ˆä¸ºselfï¼Œå®ƒè¡¨ç¤ºè°ƒç”¨è¯¥æ–¹æ³•çš„structå®ä¾‹ã€‚

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```

```rust
fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 10, height: 40 };
    let rect3 = Rectangle { width: 60, height: 45 };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
}
```

```rust

#![allow(unused_variables)]
fn main() {
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
}
```

çš„å¦ä¸€ä¸ªæœ‰ç”¨çš„åŠŸèƒ½`impl`å—çš„æ˜¯ï¼Œèƒ½å®šä¹‰èŒƒå›´å†…çš„åŠŸèƒ½implå—æ˜¯ä¸å¸¦selfä½œä¸ºå‚æ•°ã€‚è¿™äº›è¢«ç§°ä¸ºå…³è”å‡½æ•°ï¼Œå› ä¸ºå®ƒä»¬ä¸ç»“æ„å…³è”ã€‚å®ƒä»¬ä»ç„¶æ˜¯å‡½æ•°ï¼Œè€Œä¸æ˜¯æ–¹æ³•ï¼Œå› ä¸ºå®ƒä»¬æ²¡æœ‰å¯ä½¿ç”¨çš„ç»“æ„å®ä¾‹ã€‚å·²ç»ä½¿ç”¨äº†String::fromå…³è”çš„åŠŸèƒ½ã€‚

å…³è”å‡½æ•°é€šå¸¸ç”¨äºå°†è¿”å›è¯¥ç»“æ„çš„æ–°å®ä¾‹çš„æ„é€ å‡½æ•°ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥æä¾›ä¸€ä¸ªå…³è”çš„å‡½æ•°ï¼Œè¯¥å‡½æ•°å°†å…·æœ‰ä¸€ä¸ªç»´åº¦å‚æ•°å¹¶å°†å…¶ç”¨ä½œå®½åº¦å’Œé«˜åº¦ï¼Œä»è€Œä½¿åˆ›å»ºæ­£æ–¹å½¢Rectangleè€Œä¸æ˜¯å¿…é¡»ä¸¤æ¬¡æŒ‡å®šç›¸åŒçš„å€¼å˜å¾—æ›´åŠ å®¹æ˜“ï¼š

```rust

#![allow(unused_variables)]
fn main() {
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn square(size: u32) -> Rectangle {
        Rectangle { width: size, height: size }
    }
}
}
```

æ¯ä¸ªç»“æ„å…è®¸å…·æœ‰å¤šä¸ª`impl`å—ã€‚

```rust

#![allow(unused_variables)]
fn main() {
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
}

```

### Rustæšä¸¾å’Œæ¨¡å¼åŒ¹é…

```rust

#![allow(unused_variables)]
fn main() {
enum IpAddrKind {
    V4,
    V6,
}
}
```

å¯ä»¥`IpAddrKind`åƒè¿™æ ·åˆ›å»ºä¸¤ä¸ªå˜ä½“çš„æ¯ä¸€ä¸ªçš„å®ä¾‹ï¼š

```rust

#![allow(unused_variables)]
fn main() {
enum IpAddrKind {
    V4,
    V6,
}

let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
}
```

è¯·æ³¨æ„ï¼Œæšä¸¾çš„å˜ä½“åœ¨å…¶æ ‡è¯†ç¬¦ä¸‹å‘½åç©ºé—´ï¼Œå¹¶ä¸”ä½¿ç”¨åŒå†’å·å°†ä¸¤è€…åˆ†å¼€ã€‚ä¹‹æ‰€ä»¥æœ‰ç”¨ï¼Œæ˜¯å› ä¸ºç°åœ¨ä¸¤ä¸ªå€¼`IpAddrKind::V4`å’Œ`IpAddrKind::V6`éƒ½å…·æœ‰ç›¸åŒçš„ç±»å‹ï¼š `IpAddrKind`ã€‚ä¾‹å¦‚ï¼Œç„¶åå¯ä»¥å®šä¹‰ä¸€ä¸ªæ¥å—ä»»æ„å€¼çš„å‡½æ•° `IpAddrKind`ï¼š

```rust

#![allow(unused_variables)]
fn main() {
enum IpAddrKind {
    V4,
    V6,
}

fn route(ip_kind: IpAddrKind) { }
}
```

```rust

#![allow(unused_variables)]
fn main() {
enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
};
}
```

é€šè¿‡å°†æ•°æ®ç›´æ¥æ”¾å…¥æ¯ä¸ªæšä¸¾å˜é‡ä¸­ï¼Œå¯ä»¥ä»…ä½¿ç”¨æšä¸¾è€Œä¸æ˜¯ç»“æ„å†…éƒ¨çš„æšä¸¾ä»¥æ›´ç®€æ´çš„æ–¹å¼è¡¨ç¤ºç›¸åŒçš„æ¦‚å¿µã€‚è¿™ä¸ªæ–°çš„`IpAddr`æšä¸¾å®šä¹‰è¡¨ç¤º`V4`å’Œ`V6` å˜ä½“éƒ½å°†å…·æœ‰å…³è”çš„`String`å€¼ï¼š

```rust

#![allow(unused_variables)]
fn main() {
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));

let loopback = IpAddr::V6(String::from("::1"));
}
```

```rust

#![allow(unused_variables)]
fn main() {
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
}
```

```rust

#![allow(unused_variables)]
fn main() {
struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
}
```

```rust

#![allow(unused_variables)]
fn main() {
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn call(&self) {
        // method body would be defined here
    }
}

let m = Message::Write(String::from("hello"));
m.call();
}
```

```rust

#![allow(unused_variables)]
fn main() {
enum Option<T> {
    Some(T),
    None,
}
}
```

è¯¥`Option<T>`æšä¸¾æ˜¯éå¸¸æœ‰ç”¨ï¼Œå®ƒç”šè‡³åŒ…æ‹¬ä¸­æ‹‰å¼€åºå¹•; æ— éœ€å°†å…¶æ˜ç¡®çº³å…¥èŒƒå›´ã€‚æ­¤å¤–ï¼Œå®ƒçš„å˜ä½“ä¹Ÿæ˜¯å¦‚æ­¤ï¼šå¯ä»¥ç›´æ¥ä½¿ç”¨`Some`å’Œ`None`ä¸å¸¦`Option::`å‰ç¼€ã€‚è¯¥ `Option<T>`æšä¸¾ä»ç„¶åªæ˜¯ä¸€ä¸ªæ™®é€šçš„æšä¸¾ï¼Œå¹¶`Some(T)`å’Œ`None`ç±»å‹ä»ç„¶å˜ç§`Option<T>`ã€‚

è¯¥`<T>`è¯­æ³•æ˜¯ï¼Œè¿˜æ²¡æœ‰è°ˆåˆ°å°šé”ˆçš„ç‰¹ç‚¹ã€‚è¿™æ˜¯ä¸€ä¸ªæ³›å‹ç±»å‹å‚æ•°ï¼Œå°†åœ¨ç¬¬10ç« ä¸­æ›´è¯¦ç»†åœ°ä»‹ç»æ³›å‹ã€‚ç°åœ¨ï¼Œåªéœ€è¦çŸ¥é“ï¼Œè¿™`<T>`æ„å‘³ç€æšä¸¾çš„Someå˜ä½“ Optionå¯ä»¥å®¹çº³ä»»ä½•ç±»å‹çš„æ•°æ®ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›ä½¿ç”¨Optionå€¼ä¿å­˜æ•°å­—ç±»å‹å’Œå­—ç¬¦ä¸²ç±»å‹çš„ç¤ºä¾‹ï¼š

```rust

#![allow(unused_variables)]
fn main() {
let some_number = Some(5);
let some_string = Some("a string");

let absent_number: Option<i32> = None;
}

```

#### Rustæ§åˆ¶æµè¿ç®—ç¬¦match

Rustå…·æœ‰ä¸€ä¸ªéå¸¸å¼ºå¤§çš„æ§åˆ¶æµè¿ç®—ç¬¦matchï¼Œè¯¥è¿ç®—ç¬¦ä½¿å¯ä»¥å°†å€¼ä¸ä¸€ç³»åˆ—æ¨¡å¼è¿›è¡Œæ¯”è¾ƒï¼Œç„¶åæ ¹æ®åŒ¹é…çš„æ¨¡å¼æ‰§è¡Œä»£ç ã€‚æ¨¡å¼å¯ä»¥ç”±æ–‡å­—å€¼ï¼Œå˜é‡åï¼Œé€šé…ç¬¦å’Œè®¸å¤šå…¶ä»–å†…å®¹ç»„æˆï¼›

```rust

#![allow(unused_variables)]
fn main() {
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
}
```

##### æ­é…Option<T>

```rust

#![allow(unused_variables)]
fn main() {
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
}

```

##### `_`å ä½ç¬¦

```rust

#![allow(unused_variables)]
fn main() {
let some_u8_value = 0u8;
match some_u8_value {
    1 => println!("one"),
    3 => println!("three"),
    5 => println!("five"),
    7 => println!("seven"),
    _ => (),
}
}

```

### Rustæ¨¡å—

æ–‡ä»¶src.lib.rs

```rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}

```

#### ä½¿ç”¨pubå…³é”®å­—å…¬å¼€è·¯å¾„

```rust
mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}

```

#### èµ·å§‹ç›¸å¯¹è·¯å¾„ super

```rust
fn serve_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::serve_order();
    }

    fn cook_order() {}
}
fn main() {}

```

#### å…¬å¼€ç»“æ„å’Œæšä¸¾

```rust

#![allow(unused_variables)]
fn main() {
mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    let mut meal = back_of_house::Breakfast::summer("Rye");
    // Change our mind about what bread we'd like
    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal
    // meal.seasonal_fruit = String::from("blueberries");
}
}

```

#### ä½¿ç”¨useå…³é”®å­—å°†è·¯å¾„çº³å…¥èŒƒå›´

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
fn main() {}

```

è¿˜å¯ä»¥é€šè¿‡`use`å’Œç›¸å¯¹è·¯å¾„å°†æŸé¡¹çº³å…¥èŒƒå›´ã€‚

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
fn main() {}

```

#### åˆ›å»ºæƒ¯ç”¨useè·¯å¾„

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
    add_to_waitlist();
    add_to_waitlist();
}
fn main() {}

```

#### ä½¿ç”¨aså…³é”®å­—æä¾›æ–°åç§°

```rust

#![allow(unused_variables)]
fn main() {
use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -> Result {
    // --snip--
    Ok(())
}

fn function2() -> IoResult<()> {
    // --snip--
    Ok(())
}
}

```

ç”¨ä»¥ä¸‹æ–¹å¼é‡æ–°å¯¼å‡ºåç§° pub use,å½“ä½¿ç”¨useå…³é”®å­—å°†åç§°å¸¦å…¥èŒƒå›´æ—¶ï¼Œæ–°èŒƒå›´ä¸­å¯ç”¨çš„åç§°æ˜¯ç§æœ‰çš„ã€‚ä¸ºäº†ä½¿è°ƒç”¨ä»£ç çš„ä»£ç èƒ½å¤Ÿåƒåœ¨è¯¥ä»£ç èŒƒå›´å†…å®šä¹‰è¯¥åç§°ä¸€æ ·å¼•ç”¨è¯¥åç§°ï¼Œå¯ä»¥å°†pub å’Œç»„åˆåœ¨ä¸€èµ·useã€‚è¿™é¡¹æŠ€æœ¯ç§°ä¸ºé‡æ–°å¯¼å‡ºï¼Œå› ä¸ºå°†æŸä¸ªé¡¹ç›®çº³å…¥èŒƒå›´ï¼ŒåŒæ—¶ä¹Ÿä½¿è¯¥é¡¹ç›®å¯ä¾›å…¶ä»–äººè¿›å…¥å…¶èŒƒå›´ã€‚

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
fn main() {}

```

é€šè¿‡ä½¿ç”¨pub useï¼Œå¤–éƒ¨ä»£ç ç°åœ¨å¯ä»¥add_to_waitlistä½¿ç”¨è°ƒç”¨è¯¥å‡½æ•°hosting::add_to_waitlistã€‚å¦‚æœæœªæŒ‡å®špub useï¼Œåˆ™è¯¥ eat_at_restaurantå‡½æ•°å¯ä»¥hosting::add_to_waitliståœ¨å…¶ä½œç”¨åŸŸå†…è°ƒç”¨ï¼Œä½†æ˜¯å¤–éƒ¨ä»£ç æ— æ³•åˆ©ç”¨æ­¤æ–°è·¯å¾„ã€‚

å½“ä»£ç çš„å†…éƒ¨ç»“æ„ä¸è°ƒç”¨ä»£ç çš„ç¨‹åºå‘˜å¯¹åŸŸçš„æ€è€ƒæ–¹å¼ä¸åŒæ—¶ï¼Œé‡æ–°å¯¼å‡ºå¾ˆæœ‰ç”¨ã€‚

#### ä½¿ç”¨å¤–éƒ¨è½¯ä»¶åŒ…

è¯¥é¡¹ç›®ä½¿ç”¨ä¸€ä¸ªåä¸ºçš„å¤–éƒ¨è½¯ä»¶åŒ…randæ¥è·å–éšæœºæ•°ã€‚è¦randåœ¨çš„é¡¹ç›®ä¸­ä½¿ç”¨ï¼Œå°†æ­¤è¡Œæ·»åŠ åˆ°Cargo.tomlä¸­ï¼š

```toml
[dependencies]
rand = "0.5.5"

```

```rust
use rand::Rng;
fn main() {
    let secret_number = rand::thread_rng().gen_range(1, 101);
}

```

Rustç¤¾åŒºçš„æˆå‘˜å·²ç»åœ¨crates.ioä¸Šæä¾›äº†è®¸å¤šè½¯ä»¶åŒ… ï¼Œ

#### ä½¿ç”¨åµŒå¥—è·¯å¾„æ¸…ç†å¤§useåˆ—è¡¨

```rust

#![allow(unused_variables)]
fn main() {
use std::{cmp::Ordering, io};
// ---snip---
}

```

è¿™ä¸¤ä¸ªè·¯å¾„çš„å…±åŒéƒ¨åˆ†æ˜¯std::ioï¼Œè¿™å°±æ˜¯å®Œæ•´çš„ç¬¬ä¸€ä¸ªè·¯å¾„ã€‚è¦å°†è¿™ä¸¤ä¸ªè·¯å¾„åˆå¹¶ä¸ºä¸€æ¡useè¯­å¥ï¼Œå¯ä»¥ä½¿ç”¨selfåµŒå¥—è·¯å¾„ï¼Œ

```rust

#![allow(unused_variables)]
fn main() {
use std::io::{self, Write};
}
r4
```

#### å…¨å±€è¿ç®—ç¬¦

å¦‚æœè¦å°†è·¯å¾„ä¸­å®šä¹‰çš„æ‰€æœ‰å…¬å…±é¡¹ç›®éƒ½çº³å…¥èŒƒå›´ï¼Œå¯ä»¥æŒ‡å®šè¯¥è·¯å¾„ï¼Œåè·Ÿ*ï¼Œå…¨å±€è¿ç®—ç¬¦ï¼š

```rust

#![allow(unused_variables)]
fn main() {
use std::collections::*;
}
```

### ç”¨å®¹å™¨å­˜å‚¨å€¼åˆ—è¡¨

è¦ç ”ç©¶çš„ç¬¬ä¸€ä¸ªé›†åˆç±»å‹æ˜¯å®¹å™¨`Vec<T>`ã€‚å®¹å™¨ä½¿å¯ä»¥åœ¨å•ä¸ªæ•°æ®ç»“æ„ä¸­å­˜å‚¨å¤šä¸ªå€¼ï¼Œè¯¥ç»“æ„å°†æ‰€æœ‰å€¼å½¼æ­¤ç›¸é‚»æ”¾ç½®åœ¨å†…å­˜ä¸­ã€‚

è¦åˆ›å»ºä¸€ä¸ªæ–°çš„ç©ºå®¹å™¨ï¼Œå¯ä»¥è°ƒç”¨è¯¥Vec::newå‡½æ•°ï¼Œ

```rust

#![allow(unused_variables)]
fn main() {
let v: Vec<i32> = Vec::new();
}

```

åœ¨æ›´å®é™…çš„ä»£ç ä¸­ï¼ŒRusté€šå¸¸å¯ä»¥åœ¨æ’å…¥å€¼åå°±æ¨æ–­å‡ºè¦å­˜å‚¨çš„å€¼çš„ç±»å‹ï¼Œå› æ­¤å‡ ä¹ä¸éœ€è¦æ‰§è¡Œæ­¤ç±»å‹æ³¨é‡Šã€‚åˆ›å»º`Vec<T>`å…·æœ‰åˆå§‹å€¼çš„æ›´ä¸ºå¸¸è§ï¼ŒRustæä¾›äº†è¯¥vec!å®ä»¥æ–¹ä¾¿ä½¿ç”¨ã€‚å®å°†åˆ›å»ºä¸€ä¸ªæ–°å®¹å™¨ï¼Œå…¶ä¸­åŒ…å«æä¾›çš„å€¼ã€‚

```rust

#![allow(unused_variables)]
fn main() {
let v = vec![1, 2, 3];
}
```

#### æ›´æ–°vector

```rust

#![allow(unused_variables)]
fn main() {
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
}
```

#### åˆ é™¤vectorå…ƒç´ 

```rust

#![allow(unused_variables)]
fn main() {
{
    let v = vec![1, 2, 3, 4];

    // do stuff with v

} // <- v goes out of scope and is freed here
}

```

æ—¢ç„¶çŸ¥é“å¦‚ä½•åˆ›å»ºï¼Œæ›´æ–°å’Œé”€æ¯å®¹å™¨ï¼Œé‚£ä¹ˆä¸‹ä¸€æ­¥å°±æ˜¯äº†è§£å¦‚ä½•è¯»å–å®¹å™¨çš„å†…å®¹ã€‚æœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥å¼•ç”¨å­˜å‚¨åœ¨å®¹å™¨ä¸­çš„å€¼ã€‚

```rust

#![allow(unused_variables)]
fn main() {
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2];
println!("The third element is {}", third);

match v.get(2) {
    Some(third) => println!("The third element is {}", third),
    None => println!("There is no third element."),
}
}
```

Rustæœ‰ä¸¤ç§å¼•ç”¨å…ƒç´ çš„æ–¹å¼ï¼Œå› æ­¤å¯ä»¥é€‰æ‹©åœ¨å°è¯•ä½¿ç”¨å‘é‡æ²¡æœ‰å…ƒç´ çš„ç´¢å¼•å€¼æ—¶ç¨‹åºçš„è¡Œä¸ºã€‚

```rust

#![allow(unused_variables)]
fn main() {
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &v[100];
let does_not_exist = v.get(100);
}

```

#### éå†å®¹å™¨ä¸­çš„å€¼

```rust

#![allow(unused_variables)]
fn main() {
let v = vec![100, 32, 57];
for i in &v {
    println!("{}", i);
}
}
```

#### è¿­ä»£å¯¹å‘é‡ä¸­å…ƒç´ çš„å¯å˜å¼•ç”¨

```rust

#![allow(unused_variables)]
fn main() {
let mut v = vec![100, 32, 57];
for i in &mut v {
    *i += 50;
}
}
```

#### å®šä¹‰å°†ä¸€ä¸ªenumä¸åŒç±»å‹çš„å€¼å­˜å‚¨åœ¨ä¸€ä¸ªå‘é‡ä¸­

```rust

#![allow(unused_variables)]
fn main() {
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
}

```

### Rustå­—ç¬¦ä¸²

ä»newåˆ›å»ºå­—ç¬¦ä¸²çš„å‡½æ•°

```rust

#![allow(unused_variables)]
fn main() {
let mut s = String::new();
}
```

#### ä½¿ç”¨è¯¥to_stringæ–¹æ³•Stringä»å­—ç¬¦ä¸²æ–‡å­—åˆ›å»ºä¸€ä¸ª

```rust

#![allow(unused_variables)]
fn main() {
let data = "initial contents";

let s = data.to_string();

// the method also works on a literal directly:
let s = "initial contents".to_string();
}

```

å­—ç¬¦ä¸²æ˜¯UTF-8ç¼–ç çš„ï¼Œå› æ­¤å¯ä»¥åœ¨å…¶ä¸­åŒ…å«ä»»ä½•æ­£ç¡®ç¼–ç çš„æ•°æ®ï¼Œ

```rust

#![allow(unused_variables)]
fn main() {
let hello = String::from("Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…");
let hello = String::from("DobrÃ½ den");
let hello = String::from("Hello");
let hello = String::from("×©Ö¸××œ×•Ö¹×");
let hello = String::from("à¤¨à¤®à¤¸à¥à¤¤à¥‡");
let hello = String::from("ã“ã‚“ã«ã¡ã¯");
let hello = String::from("ì•ˆë…•í•˜ì„¸ìš”");
let hello = String::from("ä½ å¥½");
let hello = String::from("OlÃ¡");
let hello = String::from("Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ");
let hello = String::from("Hola");
}
```

**æ›´æ–°å­—ç¬¦ä¸²**

```rust

#![allow(unused_variables)]
fn main() {
let mut s = String::from("foo");
s.push_str("bar");
}

```

**ä¸+è¿ç®—ç¬¦æˆ–format!å®ä¸²è”**

```rust

#![allow(unused_variables)]
fn main() {
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used
}

```

```rust

#![allow(unused_variables)]
fn main() {
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{}-{}-{}", s1, s2, s3);
}

```

**éå†å­—ç¬¦ä¸²**

```rust

#![allow(unused_variables)]
fn main() {
for c in "à¤¨à¤®à¤¸à¥à¤¤à¥‡".chars() {
    println!("{}", c);
}
}
```

```rust

#![allow(unused_variables)]
fn main() {
for b in "à¤¨à¤®à¤¸à¥à¤¤à¥‡".bytes() {
    println!("{}", b);
}
}

```

### Rustå“ˆå¸Œ

```rust

#![allow(unused_variables)]
fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);
}

```

```rust

#![allow(unused_variables)]
fn main() {
use std::collections::HashMap;

let teams  = vec![String::from("Blue"), String::from("Yellow")];
let initial_scores = vec![10, 50];

let scores: HashMap<_, _> = teams.iter().zip(initial_scores.iter()).collect();
}

```

**å“ˆå¸Œå’Œæ‰€æœ‰æƒ**

```rust

#![allow(unused_variables)]
fn main() {
use std::collections::HashMap;

let field_name = String::from("Favorite color");
let field_value = String::from("Blue");

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name and field_value are invalid at this point, try using them and
// see what compiler error you get!
}

```

**è®¿é—®éå†å“ˆå¸Œçš„å€¼**

```rust

#![allow(unused_variables)]
fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

let team_name = String::from("Blue");
let score = scores.get(&team_name);
}

```

```rust

#![allow(unused_variables)]
fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

for (key, value) in &scores {
    println!("{}: {}", key, value);
}
}

```

é€šå¸¸æ£€æŸ¥ç‰¹å®šé”®æ˜¯å¦å…·æœ‰å€¼ï¼Œå¦‚æœæ²¡æœ‰ï¼Œè¯·ä¸ºå…¶æ’å…¥å€¼ã€‚å“ˆå¸Œæ˜ å°„ä¸ºæ­¤æœ‰ä¸€ä¸ªç‰¹æ®Šçš„API entry ï¼Œå®ƒå°†æƒ³è¦æ£€æŸ¥çš„é”®ä½œä¸ºå‚æ•°ã€‚è¯¥entryæ–¹æ³•çš„è¿”å›å€¼ æ˜¯ä¸€ä¸ªç§°ä¸ºçš„æšä¸¾Entryï¼Œè¡¨ç¤ºå¯èƒ½å­˜åœ¨æˆ–å¯èƒ½ä¸å­˜åœ¨çš„å€¼ã€‚å‡è®¾è¦æ£€æŸ¥Yellowå›¢é˜Ÿçš„å¯†é’¥æ˜¯å¦å…·æœ‰ä¸å…¶å…³è”çš„å€¼ã€‚å¦‚æœä¸æ˜¯ï¼Œè¦æ’å…¥å€¼50ï¼Œè“è‰²å›¢é˜Ÿä¹Ÿè¦æ’å…¥å€¼50ã€‚ä½¿ç”¨entryAPIï¼Œ

```rust

#![allow(unused_variables)]
fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);

scores.entry(String::from("Yellow")).or_insert(50);
scores.entry(String::from("Blue")).or_insert(50);

println!("{:?}", scores);
}

```

**æ ¹æ®æ—§å€¼æ›´æ–°å€¼**

```rust

#![allow(unused_variables)]
fn main() {
use std::collections::HashMap;

let text = "hello world wonderful world";

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!("{:?}", map);
}

```

#### Rustæ•£åˆ—å‡½æ•°

é»˜è®¤æƒ…å†µä¸‹ï¼ŒHashMapä½¿ç”¨â€œåŠ å¯†å¼ºåº¦é«˜â€çš„1å“ˆå¸Œå‡½æ•°ï¼Œè¯¥å‡½æ•°å¯ä»¥æŠµæŠ—æ‹’ç»æœåŠ¡ï¼ˆDoSï¼‰æ”»å‡»ã€‚è¿™ä¸æ˜¯å¯ç”¨çš„æœ€å¿«çš„å“ˆå¸Œç®—æ³•ï¼Œä½†æ˜¯æ€§èƒ½ä¸‹é™å¸¦æ¥çš„æ›´å¥½å®‰å…¨æ€§çš„æƒè¡¡æ˜¯å€¼å¾—çš„ã€‚å¦‚æœå¯¹ä»£ç è¿›è¡Œæ¦‚è¦åˆ†æå¹¶å‘ç°é»˜è®¤çš„å“ˆå¸Œå‡½æ•°å¯¹äºçš„ç›®çš„è€Œè¨€å¤ªæ…¢ï¼Œåˆ™å¯ä»¥é€šè¿‡æŒ‡å®šå…¶ä»–hasheræ¥åˆ‡æ¢åˆ°å¦ä¸€ä¸ªå‡½æ•° ã€‚æ•£åˆ—å™¨æ˜¯å®ç°BuildHasherç‰¹å¾çš„ä¸€ç§ç±»å‹ã€‚

### Rusté”™è¯¯å¤„ç†

panic!å®å¼•å‘é”™è¯¯

#### å¯æ¢å¤é”™è¯¯Result

```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => {
            panic!("Problem opening the file: {:?}", error)
        },
    };
}

```

**åŒ¹é…ä¸åŒçš„é”™è¯¯**

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            other_error => panic!("Problem opening the file: {:?}", other_error),
        },
    };
}

```

File::openåœ¨Errå˜ä½“å†…éƒ¨è¿”å›çš„å€¼çš„ç±»å‹ä¸º io::Errorï¼Œè¿™æ˜¯æ ‡å‡†åº“æä¾›çš„ç»“æ„ã€‚è¯¥ç»“æ„å…·æœ‰ä¸€ä¸ªkindå¯ä»¥è°ƒç”¨ä»¥è·å–io::ErrorKindå€¼çš„æ–¹æ³•ã€‚æšä¸¾ io::ErrorKindç”±æ ‡å‡†åº“æä¾›ï¼Œå¹¶ä¸”å…·æœ‰è¡¨ç¤ºio æ“ä½œå¯èƒ½å¯¼è‡´çš„å„ç§é”™è¯¯çš„å˜ä½“ã€‚è¦ä½¿ç”¨çš„å˜ä½“æ˜¯ErrorKind::NotFoundï¼Œè¡¨ç¤ºè¦æ‰“å¼€çš„æ–‡ä»¶å°šä¸å­˜åœ¨ã€‚æ‰€ä»¥åŒ¹é…fï¼Œä½†ä¹Ÿæœ‰ä¸€ä¸ªå†…éƒ¨åŒ¹é…error.kind()ã€‚

è¦æ£€æŸ¥å†…éƒ¨åŒ¹é…é¡¹çš„æ¡ä»¶æ˜¯ï¼Œè¿”å›çš„å€¼æ˜¯å¦ä¸ºæšä¸¾error.kind()çš„NotFoundå˜ä½“ErrorKindã€‚å¦‚æœæ˜¯è¿™æ ·ï¼Œå°è¯•ä½¿ç”¨åˆ›å»ºæ–‡ä»¶File::createã€‚ä½†æ˜¯ï¼Œç”±äºFile::create ä¹Ÿå¯èƒ½å¤±è´¥ï¼Œå› æ­¤éœ€è¦åœ¨å†…éƒ¨matchè¡¨è¾¾å¼ä¸­æ·»åŠ ç¬¬äºŒä¸ªåˆ†æ”¯ã€‚æ— æ³•åˆ›å»ºæ–‡ä»¶æ—¶ï¼Œå°†è¾“å‡ºå…¶ä»–é”™è¯¯æ¶ˆæ¯ã€‚å¤–éƒ¨çš„ç¬¬äºŒä¸ªè‡‚matchä¿æŒä¸å˜ï¼Œå› æ­¤ç¨‹åºä¼šå› ç¼ºå°‘æ–‡ä»¶é”™è¯¯è€Œå¯¹ä»»ä½•é”™è¯¯æ„Ÿåˆ°é”™è¯¯ã€‚

å¥½å¤šmatchï¼è¯¥matchè¡¨è¾¾å¼éå¸¸æœ‰ç”¨ï¼Œä½†ä¹Ÿéå¸¸åŸå§‹ã€‚åœ¨ç¬¬13ç« ä¸­ï¼Œå°†å­¦ä¹ é—­åŒ…ã€‚è¯¥`Result<T, E>`ç±»å‹å…·æœ‰è®¸å¤šæ¥å—é—­åŒ…å¹¶ä½¿ç”¨matchè¡¨è¾¾å¼å®ç°çš„æ–¹æ³• ã€‚ä½¿ç”¨è¿™äº›æ–¹æ³•å°†ä½¿çš„ä»£ç æ›´ç®€æ´ã€‚

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {:?}", error);
            })
        } else {
            panic!("Problem opening the file: {:?}", error);
        }
    });
}
```

```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt").unwrap();
}

```

expectç±»ä¼¼äºçš„å¦ä¸€ç§æ–¹æ³•ï¼Œunwrapè®©ä¹Ÿå¯ä»¥é€‰æ‹© panic!é”™è¯¯æ¶ˆæ¯ã€‚ä½¿ç”¨expectä»£æ›¿unwrapå¹¶æä¾›è‰¯å¥½çš„é”™è¯¯æ¶ˆæ¯å¯ä»¥ä¼ è¾¾çš„æ„å›¾ï¼Œå¹¶ä½¿è·Ÿè¸ªé”™è¯¯çš„æ ¹æºæ›´åŠ å®¹æ˜“ã€‚

```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt").expect("Failed to open hello.txt");
}

```

**ä¼ æ’­é”™è¯¯**

å½“ç¼–å†™ä¸€ä¸ªå‡½æ•°çš„å®ç°è°ƒç”¨å¯èƒ½å¤±è´¥çš„å‡½æ•°æ—¶ï¼Œå¯ä»¥å°†é”™è¯¯è¿”å›ç»™è°ƒç”¨ä»£ç ï¼Œä»¥ä¾¿å®ƒå¯ä»¥å†³å®šè¦åšä»€ä¹ˆï¼Œè€Œä¸æ˜¯å¤„ç†è¯¥å‡½æ•°ä¸­çš„é”™è¯¯ã€‚è¿™è¢«ç§°ä¸º ä¼ æ’­é”™è¯¯ï¼Œå¹¶èµ‹äºˆäº†è°ƒç”¨ä»£ç æ›´å¤šçš„æ§åˆ¶æƒï¼Œåœ¨è¿™é‡Œï¼Œå¯èƒ½æœ‰æ›´å¤šçš„ä¿¡æ¯æˆ–é€»è¾‘è§„å®šäº†é”™è¯¯çš„å¤„ç†æ–¹å¼ï¼Œè€Œä¸æ˜¯åœ¨ä»£ç ä¸Šä¸‹æ–‡ä¸­å¯ç”¨çš„ä¿¡æ¯æˆ–é€»è¾‘ã€‚

```rust

#![allow(unused_variables)]
fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -> Result<String, io::Error> {
    let f = File::open("hello.txt");

    let mut f = match f {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&mut s) {
        Ok(_) => Ok(s),
        Err(e) => Err(e),
    }
}
}

```

**ä¼ æ’­é”™è¯¯çš„æ·å¾„ï¼š?è¿ç®—ç¬¦**

```rust

#![allow(unused_variables)]
fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut f = File::open("hello.txt")?;
    let mut s = String::new();
    f.read_to_string(&mut s)?;
    Ok(s)
}
}

```

```rust

#![allow(unused_variables)]
fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut s = String::new();

    File::open("hello.txt")?.read_to_string(&mut s)?;

    Ok(s)
}
}

```

å°†æ–‡ä»¶è¯»å…¥å­—ç¬¦ä¸²æ˜¯ä¸€ä¸ªç›¸å½“å¸¸è§çš„æ“ä½œï¼Œå› æ­¤Rustæä¾›äº†ä¾¿æ·çš„fs::read_to_stringåŠŸèƒ½æ¥æ‰“å¼€æ–‡ä»¶ï¼Œåˆ›å»ºæ–°æ–‡ä»¶ Stringï¼Œè¯»å–æ–‡ä»¶å†…å®¹ï¼Œå°†å†…å®¹æ”¾å…¥æ–‡ä»¶ä¸­Stringå¹¶è¿”å›ã€‚å½“ç„¶ï¼Œä½¿ç”¨fs::read_to_stringä¸ä¼šç»™æä¾›è§£é‡Šæ‰€æœ‰é”™è¯¯å¤„ç†çš„æœºä¼šï¼Œå› æ­¤é¦–å…ˆé‡‡ç”¨äº†æ›´é•¿çš„æ–¹æ³•ã€‚

```rust

#![allow(unused_variables)]
fn main() {
use std::io;
use std::fs;

fn read_username_from_file() -> Result<String, io::Error> {
    fs::read_to_string("hello.txt")
}
}

```

è®©çœ‹çœ‹å¦‚æœ?åœ¨mainå‡½æ•°ä¸­ä½¿ç”¨è¿ç®—ç¬¦ä¼šå‘ç”Ÿä»€ä¹ˆï¼Œä¼šè®°å¾—å®ƒçš„è¿”å›ç±»å‹ä¸º()ï¼š

```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt")?;
}

```

```rust
error[E0277]: the `?` operator can only be used in a function that returns
`Result` or `Option` (or another type that implements `std::ops::Try`)
 --> src/main.rs:4:13
  |
4 |     let f = File::open("hello.txt")?;
  |             ^^^^^^^^^^^^^^^^^^^^^^^^ cannot use the `?` operator in a
  function that returns `()`
  |
  = help: the trait `std::ops::Try` is not implemented for `()`
  = note: required by `std::ops::Try::from_error`

```

è¯¥é”™è¯¯æŒ‡å‡ºåªå…è®¸?åœ¨è¿”å›çš„å‡½æ•°`Result`æˆ–`Option`å®ç°çš„å…¶ä»–ç±»å‹ä¸­ ä½¿ç”¨è¿ç®—ç¬¦`std::ops::Try`ã€‚å½“åœ¨ä¸è¿”å›è¿™äº›ç±»å‹ä¹‹ä¸€çš„å‡½æ•°ä¸­ç¼–å†™ä»£ç æ—¶ï¼Œå¹¶ä¸”è¦?åœ¨è°ƒç”¨è¿”å›å…¶ä»–å‡½æ•°çš„å…¶ä»–å‡½æ•°æ—¶ä½¿ç”¨`Result<T, E>`ï¼Œæœ‰ä¸¤ç§é€‰æ‹©å¯ä»¥è§£å†³æ­¤é—®é¢˜ã€‚ä¸€ç§æŠ€æœ¯æ˜¯å°†å‡½æ•°çš„è¿”å›ç±»å‹æ›´æ”¹ä¸º`Result<T, E>`åœ¨æ²¡æœ‰é™åˆ¶çš„æƒ…å†µä¸‹è¿”å›ã€‚å¦ä¸€ç§æŠ€æœ¯æ˜¯ä½¿ç”¨ä¸€ç§matchæˆ–å¤šç§`Result<T, E>`æ–¹æ³•ä»¥`Result<T, E>`é€‚å½“çš„æ–¹å¼è¿›è¡Œå¤„ç†ã€‚

è¯¥mainå‡½æ•°æ˜¯ç‰¹æ®Šçš„ï¼Œå¹¶ä¸”å¯¹å®ƒçš„è¿”å›ç±»å‹å¿…é¡»æœ‰é™åˆ¶ã€‚mainçš„ä¸€ç§æœ‰æ•ˆè¿”å›ç±»å‹æ˜¯()ï¼Œå¹¶ä¸”æ–¹ä¾¿åœ°ï¼Œå¦ä¸€ç§æœ‰æ•ˆè¿”å›ç±»å‹æ˜¯Result<T, E>ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```rust
use std::error::Error;
use std::fs::File;

fn main() -> Result<(), Box<dyn Error>> {
    let f = File::open("hello.txt")?;

    Ok(())
}
```

è¯¥`Box<dyn Error>`ç±»å‹ç§°ä¸ºç‰¹å¾å¯¹è±¡ï¼Œ

### æ˜¯å¦ä½¿ç”¨panic!å‡½æ•°

```rust

#![allow(unused_variables)]
fn main() {
use std::net::IpAddr;

let home: IpAddr = "127.0.0.1".parse().unwrap();
}

```

IpAddré€šè¿‡è§£æç¡¬ç¼–ç å­—ç¬¦ä¸²æ¥åˆ›å»ºå®ä¾‹ã€‚å¯ä»¥çœ‹åˆ°è¿™127.0.0.1æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„IPåœ°å€ï¼Œå› æ­¤å¯ä»¥åœ¨unwrap æ­¤å¤„ä½¿ç”¨ã€‚ä½†æ˜¯ï¼Œä½¿ç”¨ç»è¿‡ç¡¬ç¼–ç çš„æœ‰æ•ˆå­—ç¬¦ä¸²ä¸ä¼šæ›´æ”¹æ–¹æ³•çš„è¿”å›ç±»å‹parseï¼šä»ç„¶ä¼šè·å¾—ä¸€ä¸ªResultå€¼ï¼Œå¹¶ä¸”ç¼–è¯‘å™¨ä»å°†ä½¿èƒ½å¤ŸResultåƒå¤„ç†Errå˜ä½“é‚£æ ·å¤„ç†è¯¥å˜é‡ï¼Œå› ä¸ºç¼–è¯‘å™¨ä¸å¤Ÿèªæ˜ï¼Œæ— æ³•çœ‹åˆ°æ­¤å­—ç¬¦ä¸²å§‹ç»ˆæ˜¯æœ‰æ•ˆçš„IPåœ°å€ã€‚å¦‚æœIPåœ°å€å­—ç¬¦ä¸²æ¥è‡ªç”¨æˆ·è€Œä¸æ˜¯ç¡¬ç¼–ç åˆ°ç¨‹åºä¸­ï¼Œå› æ­¤ç¡®å®æœ‰å¤±è´¥çš„å¯èƒ½æ€§ï¼Œè‚¯å®šå¸Œæœ›ä»¥Resultæ›´å¯é çš„æ–¹å¼å¤„ç†å®ƒã€‚

```rust
loop {
    // --snip--

    let guess: i32 = match guess.trim().parse() {
        Ok(num) => num,
        Err(_) => continue,
    };

    if guess < 1 || guess > 100 {
        println!("The secret number will be between 1 and 100.");
        continue;
    }

    match guess.cmp(&secret_number) {
    // --snip--
}

```

å¯ä»¥åˆ›å»ºä¸€ä¸ªæ–°ç±»å‹å¹¶å°†éªŒè¯æ”¾å…¥å‡½æ•°ä¸­ä»¥åˆ›å»ºè¯¥ç±»å‹çš„å®ä¾‹ï¼Œè€Œä¸æ˜¯åœ¨æ‰€æœ‰åœ°æ–¹é‡å¤è¿›è¡ŒéªŒè¯ã€‚è¿™æ ·ï¼Œå‡½æ•°åœ¨ç­¾åä¸­ä½¿ç”¨æ–°ç±»å‹å¹¶æ”¾å¿ƒä½¿ç”¨å…¶æ¥æ”¶çš„å€¼æ˜¯å®‰å…¨çš„ã€‚

```rust

#![allow(unused_variables)]
fn main() {
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }

        Guess {
            value
        }
    }

    pub fn value(&self) -> i32 {
        self.value
    }
}
}

```

### é€šç”¨ç±»å‹ï¼Œç‰¹å¾å’Œå¯¿å‘½

```rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
 assert_eq!(largest, 100);
}

```

```rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}

```

```rust
fn largest<T>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}

```

å¦‚æœç°åœ¨ç¼–è¯‘æ­¤ä»£ç ï¼Œåˆ™ä¼šæ”¶åˆ°æ­¤é”™è¯¯ï¼š

```rust
error[E0369]: binary operation `>` cannot be applied to type `T`
 --> src/main.rs:5:12
  |
5 |         if item > largest {
  |            ^^^^^^^^^^^^^^
  |
  = note: an implementation of `std::cmp::PartialOrd` might be missing for `T`

```

è¿˜å¯ä»¥ä½¿ç”¨`<>`è¯­æ³•åœ¨ä¸€ä¸ªæˆ–å¤šä¸ªå­—æ®µä¸­å®šä¹‰ç»“æ„ä»¥ä½¿ç”¨é€šç”¨ç±»å‹å‚æ•°ã€‚

```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}

```

åœ¨ç»“æ„å®šä¹‰ä¸­ä½¿ç”¨æ³›å‹çš„è¯­æ³•ç±»ä¼¼äºåœ¨å‡½æ•°å®šä¹‰ä¸­ä½¿ç”¨çš„è¯­æ³•ã€‚é¦–å…ˆï¼Œåœ¨ç»“æ„åç§°ä¹‹åçš„å°–æ‹¬å·å†…å£°æ˜ç±»å‹å‚æ•°çš„åç§°ã€‚ç„¶åï¼Œå¯ä»¥åœ¨ç»“æ„å®šä¹‰ä¸­ä½¿ç”¨æ³›å‹ç±»å‹ï¼Œå¦åˆ™å°†æŒ‡å®šå…·ä½“çš„æ•°æ®ç±»å‹ã€‚

è¯·æ³¨æ„ï¼Œå› ä¸ºåªç”¨ä¸€ä¸ªæ³›å‹ç±»å‹å®šä¹‰`Point<T>`ï¼Œè¿™ä¸ªå®šä¹‰è¯´ï¼Œ`Point<T>`ç»“æ„æ˜¯é€šç”¨åœ¨æŸç§ç±»å‹çš„Tï¼Œå’Œç”°é‡xï¼Œå¹¶yæœ‰ä¸¤ä¸ªåŒç±»å‹çš„ï¼Œæ— è®ºè¯¥ç±»å‹è€Œå®šã€‚å¦‚æœåˆ›å»ºä¸€ä¸ª`Point<T>`å…·æœ‰ä¸åŒç±»å‹å€¼çš„å®ä¾‹ï¼Œä»£ç å°†æ— æ³•ç¼–è¯‘ã€‚

```rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}

```

å¯ä»¥å®šä¹‰æšä¸¾ä»¥å°†é€šç”¨æ•°æ®ç±»å‹ä¿å­˜åœ¨å®ƒä»¬çš„å˜é‡ä¸­ã€‚çœ‹çœ‹`Option<T>`å’Œ`Result<T, E>`æ ‡å‡†åº“æä¾›çš„æšä¸¾ï¼Œ

```rust

#![allow(unused_variables)]
fn main() {
enum Option<T> {
    Some(T),
    None,
}
}
```

```rust

#![allow(unused_variables)]
fn main() {
enum Result<T, E> {
    Ok(T),
    Err(E),
}
}

```

**èŒƒå‹æ–¹æ³•**

```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
```

å¯ä»¥ä»…åœ¨`Point<f32>`å®ä¾‹ä¸Šå®ç°æ–¹æ³•ï¼Œè€Œä¸èƒ½åœ¨`Point<T>`å…·æœ‰ä»»ä½•æ³›å‹ç±»å‹çš„å®ä¾‹ä¸Šå®ç°æ–¹æ³•ã€‚

```rust

#![allow(unused_variables)]
fn main() {
struct Point<T> {
    x: T,
    y: T,
}

impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
}

```

ç»“æ„å®šä¹‰ä¸­çš„æ³›å‹ç±»å‹å‚æ•°å¹¶ä¸æ€»æ˜¯ä¸è¯¥ç»“æ„çš„æ–¹æ³•ç­¾åä¸­ä½¿ç”¨çš„å‚æ•°ç›¸åŒã€‚ä¾‹å¦‚ï¼Œ

```rust
struct Point<T, U> {
    x: T,
    y: U,
}

impl<T, U> Point<T, U> {
    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c'};

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}

```

Rusté€šè¿‡åœ¨ç¼–è¯‘æ—¶å¯¹ä½¿ç”¨æ³›å‹çš„ä»£ç è¿›è¡Œå•æ€åŒ–æ¥å®ç°è¿™ä¸€ç‚¹ã€‚å•è‰²åŒ–æ˜¯é€šè¿‡å¡«å……ç¼–è¯‘æ—¶ä½¿ç”¨çš„å…·ä½“ç±»å‹ï¼Œå°†é€šç”¨ä»£ç è½¬æ¢ä¸ºç‰¹å®šä»£ç çš„è¿‡ç¨‹ã€‚

åœ¨æ­¤è¿‡ç¨‹ä¸­ï¼Œ

### ç‰¹æ€§ï¼šå®šä¹‰å…±åŒçš„è¡Œä¸º

ç±»å‹çš„è¡Œä¸ºç”±å¯ä»¥åœ¨è¯¥ç±»å‹ä¸Šè°ƒç”¨çš„æ–¹æ³•ç»„æˆã€‚å¦‚æœå¯ä»¥å¯¹æ‰€æœ‰è¿™äº›ç±»å‹è°ƒç”¨ç›¸åŒçš„æ–¹æ³•ï¼Œåˆ™ä¸åŒçš„ç±»å‹å…·æœ‰ç›¸åŒçš„è¡Œä¸ºã€‚ç‰¹æ€§å®šä¹‰æ˜¯ä¸€ç§å°†æ–¹æ³•ç­¾åç»„åˆåœ¨ä¸€èµ·ä»¥å®šä¹‰å®ç°æŸäº›ç›®çš„æ‰€éœ€çš„è¡Œä¸ºçš„æ–¹æ³•ã€‚

ä¸¾ä¾‹æ¥è¯´ï¼Œå‡è®¾æœ‰å¤šç§ç»“æ„ï¼Œå¯å®¹çº³å„ç§ç±»å‹å’Œæ•°é‡çš„æ–‡æœ¬ï¼šä¸€ç§NewsArticleç»“æ„ï¼Œå¯å®¹çº³åœ¨ç‰¹å®šä½ç½®å½’æ¡£çš„æ–°é—»æŠ¥å¯¼ï¼Œå¹¶ä¸”ç»“æ„Tweetæœ€å¤šå¯åŒ…å«280ä¸ªå­—ç¬¦ä»¥åŠæŒ‡ç¤ºå®ƒæ˜¯å¦ä¸ºæ–°æ¨æ–‡çš„å…ƒæ•°æ®ï¼Œè½¬å‘æˆ–å›å¤å…¶ä»–æ¨æ–‡ã€‚

æƒ³è¦åˆ¶ä½œä¸€ä¸ªåª’ä½“èšåˆå™¨åº“ï¼Œä»¥æ˜¾ç¤ºå¯èƒ½å­˜å‚¨åœ¨NewsArticleæˆ–Tweetå®ä¾‹ä¸­çš„æ•°æ®æ‘˜è¦ã€‚ä¸ºæ­¤ï¼Œéœ€è¦æ¯ç§ç±»å‹çš„æ‘˜è¦ï¼Œå¹¶ä¸”éœ€è¦é€šè¿‡summarizeåœ¨å®ä¾‹ä¸Šè°ƒç”¨æ–¹æ³•æ¥è¯·æ±‚è¯¥æ‘˜è¦ ã€‚

```rust

#![allow(unused_variables)]
fn main() {
pub trait Summary {
    fn summarize(&self) -> String;
}
}

```

#### åœ¨ç±»å‹ä¸Šå®ç°ç‰¹è´¨

```rust

#![allow(unused_variables)]
fn main() {
pub trait Summary {
    fn summarize(&self) -> String;
}

pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
}

```

#### ç‰¹æ€§ä½œä¸ºå‚æ•°

```rust
pub fn notify(item: impl Summary) {
    println!("Breaking news! {}", item.summarize());
}

```

#### ç‰¹æ€§ç»‘å®šè¯­æ³•

```rust
pub fn notify<T: Summary>(item: T) {
    println!("Breaking news! {}", item.summarize());
}

```

è¯¥impl Traitè¯­æ³•æ˜¯æ–¹ä¾¿ï¼Œä½¿å¾—åœ¨ç®€å•çš„æƒ…å†µä¸‹ï¼Œæ›´ç®€æ´çš„ä»£ç ã€‚åœ¨å…¶ä»–æƒ…å†µä¸‹ï¼Œç‰¹å¾ç»‘å®šè¯­æ³•å¯ä»¥è¡¨ç¤ºæ›´å¤šçš„å¤æ‚æ€§ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥æœ‰ä¸¤ä¸ªå®ç°çš„å‚æ•°Summaryã€‚ä½¿ç”¨impl Traitè¯­æ³•å¦‚ä¸‹æ‰€ç¤ºï¼š

```rust
pub fn notify(item1: impl Summary, item2: impl Summary) {

```

æˆ–è€…

```rust
pub fn notify<T: Summary>(item1: T, item2: T) {

```

**ä½¿ç”¨+è¯­æ³•æŒ‡å®šå¤šä¸ªç‰¹å¾ç•Œçº¿**

```rust
pub fn notify(item: impl Summary + Display) {

```

```rust
pub fn notify<T: Summary + Display>(item: T) {

```

**å…·æœ‰whereæ¡æ¬¾çš„æ›´æ¸…æ™°çš„ç‰¹è´¨ç•Œé™**

```rust
fn some_function<T, U>(t: T, u: U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{

```

è¿˜å¯ä»¥impl Traitåœ¨è¿”å›ä½ç½®ä½¿ç”¨è¯­æ³•æ¥è¿”å›å®ç°ç‰¹å¾çš„æŸç§ç±»å‹çš„å€¼ï¼Œ

```rust
fn returns_summarizable() -> impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from("of course, as you probably already know, people"),
        reply: false,
        retweet: false,
    }
}

```

```rust
fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}

```

è¿‡ä½¿ç”¨ä¸implä½¿ç”¨é€šç”¨ç±»å‹å‚æ•°çš„å—ç»‘å®šçš„ç‰¹å¾ï¼Œå¯ä»¥æœ‰æ¡ä»¶åœ°ä¸ºå®ç°æŒ‡å®šç‰¹å¾çš„ç±»å‹å®ç°æ–¹æ³•ã€‚ä¾‹å¦‚ï¼Œ`Pair<T>`ç±»å‹å§‹ç»ˆå®ç°è¯¥ newåŠŸèƒ½ã€‚ä½†`Pair<T>`ä»…å®ç°cmp_displayæ–¹æ³•ï¼Œå¦‚æœå…¶å†…å‹Tå™¨å…·çš„PartialOrdï¼Œä½¿æ¯”è¾ƒæ€§çŠ¶å’Œ æ‰€è¿°Displayä½¿æ‰“å°æ€§çŠ¶ã€‚

```rust

#![allow(unused_variables)]
fn main() {
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self {
            x,
            y,
        }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
}

```

å¯¹äºä»»ä½•å®ç°äº†å¦ä¸€ä¸ªç‰¹å¾çš„ç±»å‹ï¼Œä¹Ÿå¯ä»¥æœ‰æ¡ä»¶åœ°å®ç°ä¸€ä¸ªç‰¹å¾ã€‚æ»¡è¶³ç‰¹å¾ç•Œé™çš„ä»»ä½•ç±»å‹çš„ç‰¹å¾å®ç°éƒ½ç§°ä¸ºè¦†ç›–å®ç°ï¼Œå¹¶ä¸”åœ¨Rustæ ‡å‡†åº“ä¸­å¾—åˆ°äº†å¹¿æ³›çš„ä½¿ç”¨ã€‚ä¾‹å¦‚ï¼Œæ ‡å‡†åº“å¯ä»¥åœ¨å®ç° ToStringç‰¹å¾çš„ä»»ä½•ç±»å‹ä¸Šå®ç°Displayç‰¹å¾ã€‚impl æ ‡å‡†åº“ä¸­çš„å—ç±»ä¼¼äºä»¥ä¸‹ä»£ç ï¼š

```rust
impl<T: Display> ToString for T {
    // --snip--
}

```

å› ä¸ºæ ‡å‡†åº“å…·æœ‰è¿™ç§å…¨é¢çš„å®ç°ï¼Œæ‰€ä»¥å¯ä»¥åœ¨å®ç°è¯¥ç‰¹æ€§çš„ä»»ä½•ç±»å‹ä¸Šè°ƒç”¨to_stringç”±ToStringtrait å®šä¹‰çš„ æ–¹æ³•Displayã€‚ä¾‹å¦‚ï¼Œå¯ä»¥Stringåƒè¿™æ ·å°†æ•´æ•°è½¬æ¢ä¸ºå…¶ç›¸åº”çš„ å€¼ï¼Œå› ä¸ºæ•´æ•°å®ç°Displayï¼š

```rust

#![allow(unused_variables)]
fn main() {
let s = 3.to_string();
}

```

ç‰¹è´¨å’Œç‰¹å¾è¾¹ç•Œä½¿å¯ä»¥ç¼–å†™ä½¿ç”¨é€šç”¨ç±»å‹å‚æ•°å‡å°‘é‡å¤çš„ä»£ç ï¼ŒåŒæ—¶è¿˜å‘ç¼–è¯‘å™¨æŒ‡å®šå¸Œæœ›é€šç”¨ç±»å‹å…·æœ‰ç‰¹å®šè¡Œä¸ºã€‚ç„¶åï¼Œç¼–è¯‘å™¨å¯ä»¥ä½¿ç”¨ç‰¹å¾ç»‘å®šä¿¡æ¯æ¥æ£€æŸ¥ä¸çš„ä»£ç ä¸€èµ·ä½¿ç”¨çš„æ‰€æœ‰å…·ä½“ç±»å‹æ˜¯å¦æä¾›æ­£ç¡®çš„è¡Œä¸ºã€‚åœ¨åŠ¨æ€ç±»å‹çš„è¯­è¨€ä¸­ï¼Œå¦‚æœåœ¨æœªå®ç°å®šä¹‰è¯¥æ–¹æ³•çš„ç±»å‹çš„ç±»å‹ä¸Šè°ƒç”¨æ–¹æ³•ï¼Œåˆ™åœ¨è¿è¡Œæ—¶ä¼šå‡ºé”™ã€‚ä½†æ˜¯Rustä¼šå°†è¿™äº›é”™è¯¯è½¬ç§»åˆ°ç¼–è¯‘æ—¶ï¼Œå› æ­¤ä¸å¾—ä¸åœ¨ä»£ç æ— æ³•è¿è¡Œä¹‹å‰è§£å†³é—®é¢˜ã€‚å¦å¤–ï¼Œä¸å¿…ç¼–å†™åœ¨è¿è¡Œæ—¶æ£€æŸ¥è¡Œä¸ºçš„ä»£ç ï¼Œå› ä¸ºå·²ç»åœ¨ç¼–è¯‘æ—¶è¿›è¡Œäº†æ£€æŸ¥ã€‚è¿™æ ·åšå¯ä»¥æé«˜æ€§èƒ½ï¼Œè€Œä¸å¿…æ”¾å¼ƒæ³›å‹çš„çµæ´»æ€§ã€‚

### ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸéªŒè¯å¼•ç”¨

ç”Ÿå‘½å‘¨æœŸçš„ä¸»è¦ç›®çš„æ˜¯é˜²æ­¢æ‚¬è€Œæœªå†³çš„å¼•ç”¨ï¼Œè¿™äº›å¼•ç”¨ä½¿ç¨‹åºå¼•ç”¨çš„ä¸æ˜¯å…¶è¦å¼•ç”¨çš„æ•°æ®ã€‚è€ƒè™‘ä¸‹é¢çš„ç¨‹åºï¼Œå®ƒå…·æœ‰ä¸€ä¸ªå¤–éƒ¨ä½œç”¨åŸŸå’Œä¸€ä¸ªå†…éƒ¨ä½œç”¨åŸŸã€‚

```rust
{
    let r;

    {
        let x = 5;
        r = &x;
    }

    println!("r: {}", r);
}
```

å¤–éƒ¨ä½œç”¨åŸŸå£°æ˜ä¸€ä¸ªræ²¡æœ‰åˆå§‹å€¼çš„å˜é‡ï¼Œå†…éƒ¨ä½œç”¨åŸŸå£°æ˜ä¸€ä¸ªxåˆå§‹å€¼5 çš„å˜é‡ã€‚åœ¨å†…éƒ¨ä½œç”¨åŸŸå†…ï¼Œå°è¯•å°†çš„å€¼è®¾ç½®rä¸ºå¯¹çš„å¼•ç”¨xã€‚ç„¶åå†…éƒ¨ä½œç”¨åŸŸç»“æŸï¼Œå°è¯•åœ¨ä¸­æ‰“å°å€¼rã€‚è¯¥ä»£ç ä¸ä¼šç¼–è¯‘ï¼Œå› ä¸ºråœ¨å°è¯•ä½¿ç”¨è¯¥å€¼ä¹‹å‰ï¼Œè¯¥å€¼å·²è¶…å‡ºèŒƒå›´ã€‚è¿™æ˜¯é”™è¯¯æ¶ˆæ¯ï¼š

```rust
error[E0597]: `x` does not live long enough
  --> src/main.rs:7:5
   |
6  |         r = &x;
   |              - borrow occurs here
7  |     }
   |     ^ `x` dropped here while still borrowed
...
10 | }
   | - borrowed value needs to live until here

```

#### å€Ÿç”¨æ£€æŸ¥å™¨

Rustç¼–è¯‘å™¨æœ‰ä¸€ä¸ªå€Ÿç”¨æ£€æŸ¥å™¨ï¼Œå¯ä»¥æ¯”è¾ƒä½œç”¨åŸŸä»¥ç¡®å®šæ‰€æœ‰å€Ÿç”¨æ˜¯å¦æœ‰æ•ˆã€‚ä¸‹é¢ä»£ç ä¸ä¸Šé¢ä»£ç ç›¸åŒï¼Œä½†å¸¦æœ‰æ³¨é‡Šï¼Œæ˜¾ç¤ºäº†å˜é‡çš„ç”Ÿå­˜æœŸã€‚

```rust
{
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {}", r); //          |
}                         // ---------+
```

#### å‡½æ•°çš„é€šç”¨ç”Ÿå‘½å‘¨æœŸ

è®©ç¼–å†™ä¸€ä¸ªè¿”å›ä¸¤ä¸ªå­—ç¬¦ä¸²åˆ‡ç‰‡ä¸­è¾ƒé•¿è€…çš„å‡½æ•°ã€‚æ­¤å‡½æ•°å°†è·å–ä¸¤ä¸ªå­—ç¬¦ä¸²åˆ‡ç‰‡å¹¶è¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²åˆ‡ç‰‡ã€‚å®ç°longestå‡½æ•°åï¼Œ

```rust
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
```

#### ç»ˆèº«æ³¨é‡Šè¯­æ³•

ç»ˆèº«æ³¨é‡Šä¸ä¼šæ›´æ”¹ä»»ä½•å¼•ç”¨çš„ç”Ÿå­˜æ—¶é—´ã€‚æ­£å¦‚ç­¾åå¯ä»¥æŒ‡å®šé€šç”¨ç±»å‹å‚æ•°æ—¶å‡½æ•°å¯ä»¥æ¥å—ä»»ä½•ç±»å‹ä¸€æ ·ï¼Œé€šè¿‡æŒ‡å®šé€šç”¨å¯¿å‘½å‚æ•°ï¼Œå‡½æ•°å¯ä»¥æ¥å—å…·æœ‰ä»»ä½•ç”Ÿå­˜æœŸçš„å¼•ç”¨ã€‚ç”Ÿå­˜æœŸæ‰¹æ³¨æè¿°äº†å¤šä¸ªå¼•ç”¨çš„ç”Ÿå­˜æœŸå½¼æ­¤ä¹‹é—´çš„å…³ç³»ï¼Œè€Œä¸ä¼šå½±å“ç”Ÿå­˜æœŸã€‚

ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šçš„è¯­æ³•ç•¥æœ‰ä¸åŒï¼šç”Ÿå‘½å‘¨æœŸå‚æ•°çš„åç§°å¿…é¡»ä»¥æ’‡å·ï¼ˆ'ï¼‰å¼€å¤´ï¼Œå¹¶ä¸”é€šå¸¸éƒ½æ˜¯å°å†™ä¸”éå¸¸çŸ­ï¼Œå°±åƒæ³›å‹ç±»å‹ä¸€æ ·ã€‚å¤§å¤šæ•°äººä½¿ç”¨è¿™ä¸ªåå­—'aã€‚å°†ç”Ÿå‘½å‘¨æœŸå‚æ•°æ³¨é‡Šæ”¾ç½®åœ¨&å¼•ç”¨çš„åé¢ï¼Œå¹¶ä½¿ç”¨ç©ºæ ¼å°†æ³¨é‡Šä¸å¼•ç”¨çš„ç±»å‹åˆ†å¼€ã€‚

ä»¥ä¸‹æ˜¯ä¸€äº›ç¤ºä¾‹ï¼šå¯¹i32ä¸å¸¦ç”Ÿå‘½å‘¨æœŸå‚æ•°çš„çš„å¼•ç”¨ï¼Œå¯¹i32å…·æœ‰ç”Ÿå‘½å‘¨æœŸå‚æ•°åä¸ºçš„çš„'aå¼•ç”¨ä»¥åŠi32å¯¹ä¹Ÿå…·æœ‰ç”Ÿå‘½å‘¨æœŸçš„çš„å¯å˜å¼•ç”¨'aã€‚

```rust
&i32        // a reference
&'a i32     // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime
```

#### æ–¹æ³•å®šä¹‰ä¸­çš„ç”Ÿå‘½å‘¨æœŸæ³¨é‡Š

åœ¨å…·æœ‰ç”Ÿå‘½å‘¨æœŸçš„ç»“æ„ä¸Šå®ç°æ–¹æ³•æ—¶ï¼Œä½¿ç”¨ä¸æ¸…å•10-11ä¸­æ‰€ç¤ºçš„æ³›å‹ç±»å‹å‚æ•°ç›¸åŒçš„è¯­æ³•ã€‚å£°æ˜å’Œä½¿ç”¨ç”Ÿå‘½å‘¨æœŸå‚æ•°çš„ä½ç½®å–å†³äºå®ƒä»¬æ˜¯å¦ä¸structå­—æ®µæˆ–æ–¹æ³•å‚æ•°ä»¥åŠè¿”å›å€¼ç›¸å…³ã€‚

å§‹ç»ˆéœ€è¦åœ¨impl å…³é”®å­—ä¹‹åå£°æ˜ç»“æ„å­—æ®µçš„ç”Ÿå‘½å‘¨æœŸåç§°ï¼Œç„¶ååœ¨ç»“æ„åç§°ä¹‹åä½¿ç”¨ï¼Œå› ä¸ºè¿™äº›ç”Ÿå‘½å‘¨æœŸæ˜¯ç»“æ„ç±»å‹çš„ä¸€éƒ¨åˆ†ã€‚

åœ¨implå—å†…çš„æ–¹æ³•ç­¾åä¸­ï¼Œå¼•ç”¨å¯èƒ½ä¸ç»“æ„å­—æ®µä¸­å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸç›¸å…³ï¼Œæˆ–è€…å®ƒä»¬å¯èƒ½æ˜¯ç‹¬ç«‹çš„ã€‚æ­¤å¤–ï¼Œç”Ÿå­˜æœŸçœç•¥è§„åˆ™é€šå¸¸ä½¿ä¹‹æˆä¸ºå¿…éœ€ï¼Œå› æ­¤åœ¨æ–¹æ³•ç­¾åä¸­ä¸éœ€è¦ç”Ÿå­˜æœŸæ‰¹æ³¨ã€‚è®©çœ‹ä¸€ä¸‹ä½¿ç”¨ImportantExcerptæ¸…å•10-25ä¸­å®šä¹‰çš„å‘½åç»“æ„çš„ä¸€äº›ç¤ºä¾‹ã€‚

é¦–å…ˆï¼Œå°†ä½¿ç”¨åä¸ºlevelçš„æ–¹æ³•ï¼Œè¯¥æ–¹æ³•çš„å”¯ä¸€å‚æ•°æ˜¯å¯¹çš„å¼•ç”¨ï¼Œ selfè€Œè¿”å›å€¼æ˜¯i32ï¼Œè€Œä¸æ˜¯å¯¹ä»»ä½•å†…å®¹çš„å¼•ç”¨ï¼š

```rust

#![allow(unused_variables)]
fn main() {
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
}
```

implè¦æ±‚åœ¨ç±»å‹åç§°åä½¿ç”¨ç”Ÿå‘½å‘¨æœŸå‚æ•°å£°æ˜ä»¥åŠåœ¨ç±»å‹åç§°åä½¿ç”¨å®ƒï¼Œä½†æ˜¯selfç”±äºç¬¬ä¸€ä¸ªçœç•¥è§„åˆ™ï¼Œä¸éœ€è¦æ³¨é‡Šå¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸã€‚

è¿™æ˜¯ç¬¬ä¸‰ä¸ªç”Ÿå­˜æœŸåˆ é™¤è§„åˆ™é€‚ç”¨çš„ç¤ºä¾‹ï¼š

```rust

#![allow(unused_variables)]
fn main() {
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part
    }
}
}

```

æœ‰ä¸¤ä¸ªè¾“å…¥å¯¿å‘½ï¼Œæ‰€ä»¥é”ˆç—…åº”ç”¨ç¬¬ä¸€ç”Ÿå­˜æ³•åˆ™çœéŸ³å¹¶ç»™å‡ºäº†ä¸¤ä¸ª&selfå’Œannouncementè‡ªå·±çš„å¯¿å‘½ã€‚ç„¶åï¼Œç”±äºå‚æ•°ä¹‹ä¸€æ˜¯&selfï¼Œè¿”å›ç±»å‹çš„ç”Ÿå­˜æœŸä¸º&selfï¼Œå¹¶ä¸”æ‰€æœ‰ç”Ÿå­˜æœŸå‡å·²è€ƒè™‘åœ¨å†…ã€‚

#### é™æ€å¯¿å‘½

éœ€è¦è®¨è®ºçš„ä¸€ä¸ªç‰¹æ®Šå¯¿å‘½æ˜¯'staticï¼Œè¿™æ„å‘³ç€è¯¥å¼•ç”¨å¯ä»¥åœ¨ç¨‹åºçš„æ•´ä¸ªè¿‡ç¨‹ä¸­æœ‰æ•ˆã€‚æ‰€æœ‰å­—ç¬¦ä¸²æ–‡å­—éƒ½æœ‰'staticç”Ÿå‘½å‘¨æœŸï¼Œå¯ä»¥å¦‚ä¸‹æ³¨é‡Šï¼š

```rust

#![allow(unused_variables)]
fn main() {
let s: &'static str = "I have a static lifetime.";
}

```

è¯¥å­—ç¬¦ä¸²çš„æ–‡æœ¬ç›´æ¥å­˜å‚¨åœ¨ç¨‹åºçš„äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ï¼Œè¯¥äºŒè¿›åˆ¶æ–‡ä»¶å§‹ç»ˆå¯ç”¨ã€‚å› æ­¤ï¼Œæ‰€æœ‰å­—ç¬¦ä¸²æ–‡å­—çš„ç”Ÿå­˜æœŸä¸º 'staticã€‚

å¯èƒ½ä¼š'staticåœ¨é”™è¯¯æ¶ˆæ¯ä¸­çœ‹åˆ°æœ‰å…³ä½¿ç”¨ç”Ÿå­˜æœŸçš„å»ºè®®ã€‚ä½†æ˜¯åœ¨æŒ‡å®š'staticä½œä¸ºå‚è€ƒçš„ç”Ÿå­˜æœŸä¹‹å‰ï¼Œè¯·è€ƒè™‘ä¸€ä¸‹æ‰€æ‹¥æœ‰çš„å‚è€ƒæ˜¯å¦çœŸæ­£å­˜åœ¨äºç¨‹åºçš„æ•´ä¸ªç”Ÿå­˜æœŸä¸­ã€‚å¯èƒ½ä¼šè€ƒè™‘æ˜¯å¦å¸Œæœ›å®ƒå¯¿å‘½è¿™ä¹ˆé•¿ï¼Œå³ä½¿å¯ä»¥ã€‚åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œé—®é¢˜æ˜¯ç”±äºå°è¯•åˆ›å»ºæ‚¬ç©ºå‚è€ƒæˆ–å¯ç”¨å¯¿å‘½ä¸åŒ¹é…è€Œå¯¼è‡´çš„ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè§£å†³æ–¹æ¡ˆå°†è§£å†³è¿™äº›é—®é¢˜ï¼Œè€Œä¸æŒ‡å®š'staticå¯¿å‘½ã€‚

#### é€šç”¨ç±»å‹å‚æ•°ï¼Œç‰¹è´¨ç•Œé™å’Œå¯¿å‘½

ç®€è¦åœ°çœ‹ä¸€ä¸‹åœ¨ä¸€ä¸ªå‡½æ•°ä¸­æŒ‡å®šæ³›å‹ç±»å‹å‚æ•°ï¼Œç‰¹å¾èŒƒå›´å’Œç”Ÿå­˜æœŸçš„è¯­æ³•ï¼

```rust

#![allow(unused_variables)]
fn main() {
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str
    where T: Display
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
}
```

### ç¼–å†™è‡ªåŠ¨åŒ–æµ‹è¯•

Edsger W. Dijkstraåœ¨1972å¹´çš„è®ºæ–‡â€œè°¦è™šçš„ç¨‹åºå‘˜â€ä¸­è¯´ï¼šâ€œç¨‹åºæµ‹è¯•å¯ä»¥æ˜¯æ˜¾ç¤ºé”™è¯¯å­˜åœ¨çš„éå¸¸æœ‰æ•ˆçš„æ–¹æ³•ï¼Œä½†æ˜¯å®ƒä¸è¶³ä»¥æ˜¾ç¤ºé”™è¯¯çš„å­˜åœ¨ã€‚â€ è¿™å¹¶ä¸æ„å‘³ç€ä¸åº”è¯¥å°è¯•å°½å¯èƒ½å¤šåœ°è¿›è¡Œæµ‹è¯•ï¼

ç¨‹åºä¸­çš„æ­£ç¡®æ€§æ˜¯çš„ä»£ç æŒ‰é¢„æœŸæ‰§è¡Œçš„ç¨‹åº¦ã€‚Rustçš„è®¾è®¡é«˜åº¦å…³æ³¨ç¨‹åºçš„æ­£ç¡®æ€§ï¼Œä½†æ˜¯æ­£ç¡®æ€§å¾ˆå¤æ‚å¹¶ä¸”ä¸å®¹æ˜“è¯æ˜ã€‚Rustçš„ç±»å‹ç³»ç»Ÿæ‰¿æ‹…äº†å¾ˆå¤§çš„è´Ÿæ‹…ï¼Œä½†æ˜¯ç±»å‹ç³»ç»Ÿæ— æ³•æ•è·å„ç§é”™è¯¯ã€‚å› æ­¤ï¼ŒRustæ”¯æŒä½¿ç”¨è¯¥è¯­è¨€ç¼–å†™è‡ªåŠ¨è½¯ä»¶æµ‹è¯•ã€‚

ä¾‹å¦‚ï¼Œå‡è®¾ç¼–å†™äº†ä¸€ä¸ªåä¸ºçš„å‡½æ•°add_twoï¼Œè¯¥å‡½æ•°ä¼šå°†ä¼ é€’ç»™å®ƒçš„ä»»ä½•æ•°å­—åŠ 2ã€‚è¯¥å‡½æ•°çš„ç­¾åæ¥å—ä¸€ä¸ªæ•´æ•°ä½œä¸ºå‚æ•°ï¼Œå¹¶è¿”å›ä¸€ä¸ªæ•´æ•°ä½œä¸ºç»“æœã€‚å½“å®ç°å¹¶ç¼–è¯‘è¯¥å‡½æ•°æ—¶ï¼ŒRustä¼šè¿›è¡Œåˆ°ç›®å‰ä¸ºæ­¢æ‰€å­¦çš„æ‰€æœ‰ç±»å‹æ£€æŸ¥å’Œå€Ÿä½æ£€æŸ¥ï¼Œä»¥ç¡®ä¿ä¾‹å¦‚ï¼Œä¸ä¼šStringå¯¹è¯¥å‡½æ•°ä¼ é€’å€¼æˆ–æ— æ•ˆå¼•ç”¨ã€‚ä½†æ˜¯Rust æ— æ³•æ£€æŸ¥æ­¤å‡½æ•°æ˜¯å¦èƒ½å¤Ÿå‡†ç¡®æ‰§è¡Œçš„é¢„æœŸï¼Œå³è¿”å›å‚æ•°åŠ 2è€Œä¸æ˜¯å‚æ•°åŠ 10æˆ–å‚æ•°å‡50ï¼é‚£å°±æ˜¯æµ‹è¯•çš„åœ°æ–¹ã€‚

å¯ä»¥ç¼–å†™æµ‹è¯•æ¥æ–­è¨€ä¾‹å¦‚ï¼Œå½“ä¼ é€’3ç»™ add_twoå‡½æ•°æ—¶ï¼Œè¿”å›çš„å€¼ä¸º5ã€‚åªè¦å¯¹ä»£ç è¿›è¡Œæ›´æ”¹ï¼Œå°±å¯ä»¥è¿è¡Œè¿™äº›æµ‹è¯•ï¼Œä»¥ç¡®ä¿ä»»ä½•ç°æœ‰çš„æ­£ç¡®è¡Œä¸ºéƒ½æ²¡æœ‰æ›´æ”¹ã€‚

æµ‹è¯•æ˜¯ä¸€é¡¹å¤æ‚çš„æŠ€èƒ½ï¼šå°½ç®¡ä¸èƒ½åœ¨ä¸€ç« ä¸­æ¶µç›–æœ‰å…³å¦‚ä½•ç¼–å†™è‰¯å¥½æµ‹è¯•çš„æ‰€æœ‰ç»†èŠ‚ï¼Œä½†å°†è®¨è®ºRustæµ‹è¯•è®¾æ–½çš„æœºåˆ¶ã€‚å°†è®¨è®ºç¼–å†™æµ‹è¯•æ—¶ä¸ºæä¾›çš„æ³¨é‡Šå’Œå®ï¼Œä¸ºè¿è¡Œæµ‹è¯•æä¾›çš„é»˜è®¤è¡Œä¸ºå’Œé€‰é¡¹ï¼Œä»¥åŠå¦‚ä½•å°†æµ‹è¯•ç»„ç»‡ä¸ºå•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•ã€‚

æµ‹è¯•æ˜¯Rustå‡½æ•°ï¼Œç”¨äºéªŒè¯éæµ‹è¯•ä»£ç æ˜¯å¦æŒ‰é¢„æœŸæ–¹å¼å·¥ä½œã€‚æµ‹è¯•åŠŸèƒ½çš„ä¸»ä½“é€šå¸¸æ‰§è¡Œä»¥ä¸‹ä¸‰ä¸ªæ“ä½œï¼š

* è®¾ç½®ä»»ä½•éœ€è¦çš„æ•°æ®æˆ–çŠ¶æ€ã€‚
* è¿è¡Œè¦æµ‹è¯•çš„ä»£ç ã€‚
* æ–­è¨€ç»“æœå°±æ˜¯æ‰€æœŸæœ›çš„ã€‚
* 
è®©çœ‹ä¸€ä¸‹Rustä¸ºç¼–å†™æ‰§è¡Œè¿™äº›æ“ä½œçš„æµ‹è¯•è€Œä¸“é—¨æä¾›çš„åŠŸèƒ½ï¼Œè¿™äº›æµ‹è¯•åŒ…æ‹¬`test`å±æ€§ï¼Œä¸€äº›å®å’Œ `should_panic`å±æ€§ã€‚

```rust
fn main() {}
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}

```

å‡½æ•°ä½“ä½¿ç”¨assert_eq!å®å£°æ˜2 + 2ç­‰äº4ã€‚æ­¤å£°æ˜ç”¨ä½œå…¸å‹æµ‹è¯•æ ¼å¼çš„ç¤ºä¾‹ã€‚è®©è¿è¡Œå®ƒä»¥æŸ¥çœ‹æ­¤æµ‹è¯•æ˜¯å¦é€šè¿‡ã€‚

è¯¥`cargo test`å‘½ä»¤è¿è¡Œé¡¹ç›®ä¸­çš„æ‰€æœ‰æµ‹è¯•ï¼Œ

```rust
fn main() {}
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
        panic!("Make this test fail");
    }
}

```

assert!å½“è¦ç¡®ä¿æµ‹è¯•ä¸­çš„æŸäº›æ¡ä»¶æ±‚å’Œæ—¶ï¼Œæ ‡å‡†åº“æä¾›çš„å®éå¸¸æœ‰ç”¨trueã€‚ç»™ assert!å®ä¸€ä¸ªå‚æ•°ï¼Œå…¶ç»“æœä¸ºå¸ƒå°”å€¼ã€‚å¦‚æœå€¼ä¸º trueï¼Œassert!åˆ™ä¸æ‰§è¡Œä»»ä½•æ“ä½œï¼Œæµ‹è¯•é€šè¿‡ã€‚å¦‚æœå€¼ä¸ºfalseï¼Œåˆ™assert!å®å°†è°ƒç”¨è¯¥panic!å®ï¼Œè¿™å°†å¯¼è‡´æµ‹è¯•å¤±è´¥ã€‚ä½¿ç”¨assert!å®æœ‰åŠ©äºæ£€æŸ¥ä»£ç æ˜¯å¦æŒ‰é¢„æœŸçš„æ–¹å¼è¿è¡Œã€‚

```rust
fn main() {}
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

```

```rust
fn main() {}
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

```

```rust
fn main() {}
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle { width: 8, height: 7 };
        let smaller = Rectangle { width: 5, height: 1 };

        assert!(larger.can_hold(&smaller));
    }
}

```

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œå·²ç»ç¼–å†™äº†åœ¨å¤±è´¥æ—¶ä¼šå‡ºç°å¼‚å¸¸çš„æµ‹è¯•ã€‚ä¹Ÿå¯ä»¥ç¼–å†™ä½¿ç”¨çš„æµ‹è¯•`Result<T, E>`ï¼è¿™æ˜¯æ¸…å•11-1ä¸­çš„æµ‹è¯•ï¼Œè¢«é‡å†™ä¸ºä½¿ç”¨`Result<T, E>`å¹¶è¿”å›a Errè€Œä¸æ˜¯å¼‚å¸¸ï¼š

```rust

#![allow(unused_variables)]
fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -> Result<(), String> {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
}
}

```

#### æ§åˆ¶æµ‹è¯•çš„è¿è¡Œæ–¹å¼

å°±åƒcargo runç¼–è¯‘ä»£ç ç„¶åè¿è¡Œç”Ÿæˆçš„äºŒè¿›åˆ¶æ–‡ä»¶ä¸€æ ·ï¼Œ cargo teståœ¨æµ‹è¯•æ¨¡å¼ä¸‹ç¼–è¯‘ä»£ç å¹¶è¿è¡Œç”Ÿæˆçš„æµ‹è¯•äºŒè¿›åˆ¶æ–‡ä»¶ã€‚å¯ä»¥æŒ‡å®šå‘½ä»¤è¡Œé€‰é¡¹æ¥æ›´æ”¹çš„é»˜è®¤è¡Œä¸º cargo testã€‚ä¾‹å¦‚ï¼Œç”Ÿæˆçš„äºŒè¿›åˆ¶æ–‡ä»¶çš„é»˜è®¤è¡Œä¸º cargo testæ˜¯å¹¶è¡Œè¿è¡Œæ‰€æœ‰æµ‹è¯•ï¼Œå¹¶æ•è·æµ‹è¯•è¿è¡ŒæœŸé—´ç”Ÿæˆçš„è¾“å‡ºï¼Œä»è€Œé˜»æ­¢æ˜¾ç¤ºè¾“å‡ºï¼Œå¹¶ä½¿è¯»å–ä¸æµ‹è¯•ç»“æœç›¸å…³çš„è¾“å‡ºæ›´åŠ å®¹æ˜“ã€‚

æœ‰äº›å‘½ä»¤è¡Œé€‰é¡¹è½¬åˆ°cargo testï¼Œæœ‰äº›è½¬åˆ°ç”Ÿæˆçš„æµ‹è¯•äºŒè¿›åˆ¶æ–‡ä»¶ã€‚è¦åˆ†éš”è¿™ä¸¤ç§ç±»å‹çš„å‚æ•°ï¼Œè¯·åˆ—å‡ºè¦ä¼ é€’çš„å‚æ•°ï¼Œcargo teståè·Ÿåˆ†éš”ç¬¦--ï¼Œç„¶ååˆ—å‡ºè¦ä¼ é€’è‡³æµ‹è¯•äºŒè¿›åˆ¶æ–‡ä»¶çš„å‚æ•°ã€‚è¿è¡Œcargo test --helpæ˜¾ç¤ºå¯ä»¥ä½¿ç”¨çš„é€‰é¡¹cargo testï¼Œè¿è¡Œcargo test -- --helpæ˜¾ç¤ºåœ¨åˆ†éš”ç¬¦ä¹‹åä½¿ç”¨çš„é€‰é¡¹--ã€‚

##### å¹¶è¡Œæˆ–è¿ç»­è¿è¡Œæµ‹è¯•

å½“è¿è¡Œå¤šä¸ªæµ‹è¯•æ—¶ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œå®ƒä»¬ä½¿ç”¨çº¿ç¨‹å¹¶è¡Œè¿è¡Œã€‚è¿™æ„å‘³ç€æµ‹è¯•å°†æ›´å¿«åœ°å®Œæˆè¿è¡Œï¼Œå› æ­¤å¯ä»¥æ›´å¿«åœ°è·å¾—æœ‰å…³ä»£ç æ˜¯å¦æ­£å¸¸å·¥ä½œçš„åé¦ˆã€‚ç”±äºæµ‹è¯•æ˜¯åŒæ—¶è¿è¡Œçš„ï¼Œå› æ­¤è¯·ç¡®ä¿çš„æµ‹è¯•ä¸ç›¸äº’ä¾èµ–ï¼Œä¹Ÿä¸ä¾èµ–ä»»ä½•å…±äº«çŠ¶æ€ï¼ŒåŒ…æ‹¬å…±äº«ç¯å¢ƒï¼Œä¾‹å¦‚å½“å‰çš„å·¥ä½œç›®å½•æˆ–ç¯å¢ƒå˜é‡ã€‚

ä¾‹å¦‚ï¼Œå‡è®¾çš„æ¯ä¸ªæµ‹è¯•éƒ½è¿è¡Œä¸€äº›ä»£ç ï¼Œè¿™äº›ä»£ç ä¼šåœ¨ç£ç›˜ä¸Šåˆ›å»ºä¸€ä¸ªåä¸ºtest-output.txtçš„æ–‡ä»¶ï¼Œå¹¶å°†ä¸€äº›æ•°æ®å†™å…¥è¯¥æ–‡ä»¶ã€‚ç„¶åï¼Œæ¯ä¸ªæµ‹è¯•è¯»å–è¯¥æ–‡ä»¶ä¸­çš„æ•°æ®ï¼Œå¹¶æ–­è¨€è¯¥æ–‡ä»¶åŒ…å«ä¸€ä¸ªç‰¹å®šå€¼ï¼Œè¯¥å€¼åœ¨æ¯ä¸ªæµ‹è¯•ä¸­éƒ½ä¸åŒã€‚å› ä¸ºæµ‹è¯•æ˜¯åŒæ—¶è¿è¡Œçš„ï¼Œæ‰€ä»¥åœ¨å¦ä¸€ä¸ªæµ‹è¯•å†™å…¥å’Œè¯»å–æ–‡ä»¶ä¹‹é—´ï¼Œä¸€ä¸ªæµ‹è¯•å¯èƒ½ä¼šè¦†ç›–æ–‡ä»¶ã€‚ç„¶åï¼Œç¬¬äºŒä¸ªæµ‹è¯•å°†å¤±è´¥ï¼Œè¿™ä¸æ˜¯å› ä¸ºä»£ç ä¸æ­£ç¡®ï¼Œè€Œæ˜¯å› ä¸ºåœ¨å¹¶è¡Œè¿è¡Œæ—¶æµ‹è¯•ä¹‹é—´ç›¸äº’å¹²æ‰°ã€‚ä¸€ç§è§£å†³æ–¹æ¡ˆæ˜¯ç¡®ä¿æ¯ä¸ªæµ‹è¯•éƒ½å†™å…¥ä¸åŒçš„æ–‡ä»¶ã€‚å¦ä¸€ç§è§£å†³æ–¹æ¡ˆæ˜¯ä¸€æ¬¡è¿è¡Œä¸€æ¬¡æµ‹è¯•ã€‚

å¦‚æœä¸æƒ³å¹¶è¡Œè¿è¡Œæµ‹è¯•ï¼Œæˆ–è€…æƒ³è¦å¯¹ä½¿ç”¨çš„çº¿ç¨‹æ•°è¿›è¡Œæ›´ç»†ç²’åº¦çš„æ§åˆ¶ï¼Œåˆ™å¯ä»¥å°†--test-threadsæ ‡å¿—å’Œè¦ä½¿ç”¨çš„çº¿ç¨‹æ•°å‘é€åˆ°æµ‹è¯•äºŒè¿›åˆ¶æ–‡ä»¶ã€‚çœ‹ä¸‹é¢çš„ä¾‹å­ï¼š

```
$ cargo test -- --test-threads=1
```

#### æ˜¾ç¤ºåŠŸèƒ½è¾“å‡º

é»˜è®¤æƒ…å†µä¸‹ï¼Œå¦‚æœæµ‹è¯•é€šè¿‡ï¼ŒRustçš„æµ‹è¯•åº“å°†æ•è·æ‰“å°åˆ°æ ‡å‡†è¾“å‡ºçš„æ‰€æœ‰å†…å®¹ã€‚ä¾‹å¦‚ï¼Œå¦‚æœè°ƒç”¨println!ä¸€ä¸ªæµ‹è¯•å¹¶ä¸”æµ‹è¯•é€šè¿‡ï¼Œåˆ™println!åœ¨ç»ˆç«¯ä¸­å°†çœ‹ä¸åˆ°è¾“å‡ºã€‚å°†ä»…çœ‹åˆ°æŒ‡ç¤ºæµ‹è¯•é€šè¿‡çš„è¡Œã€‚å¦‚æœæµ‹è¯•å¤±è´¥ï¼Œå°†åœ¨å…¶ä½™å¤±è´¥æ¶ˆæ¯ä¸­çœ‹åˆ°æ‰“å°åˆ°æ ‡å‡†è¾“å‡ºçš„æ‰€æœ‰å†…å®¹ã€‚

ä¾‹å¦‚ï¼Œæ¸…å•11-10å…·æœ‰ä¸€ä¸ªå‚»å‡½æ•°ï¼Œè¯¥å‡½æ•°æ‰“å°å…¶å‚æ•°çš„å€¼å¹¶è¿”å›10ï¼Œä»¥åŠé€šè¿‡å’Œå¤±è´¥çš„æµ‹è¯•ã€‚

```rust

#![allow(unused_variables)]
fn main() {
fn prints_and_returns_10(a: i32) -> i32 {
    println!("I got the value {}", a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}
}
```

#### æŒ‰åç§°è¿è¡Œæµ‹è¯•å­é›†

æœ‰æ—¶ï¼Œè¿è¡Œå®Œæ•´çš„æµ‹è¯•å¥—ä»¶å¯èƒ½éœ€è¦å¾ˆé•¿æ—¶é—´ã€‚å¦‚æœåœ¨ç‰¹å®šåŒºåŸŸä¸­å¤„ç†ä»£ç ï¼Œåˆ™å¯èƒ½åªæƒ³è¿è¡Œä¸è¯¥ä»£ç æœ‰å…³çš„æµ‹è¯•ã€‚å¯ä»¥é€šè¿‡ä¼ é€’cargo testè¦ä½œä¸ºå‚æ•°è¿è¡Œçš„æµ‹è¯•åç§°æ¥é€‰æ‹©è¦è¿è¡Œçš„æµ‹è¯•ã€‚

```rust

#![allow(unused_variables)]
fn main() {
pub fn add_two(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
}

```

#### è¿è¡Œå•é¡¹æµ‹è¯•

å¯ä»¥ä¼ é€’ä»»ä½•æµ‹è¯•å‡½æ•°çš„åç§°cargo testä»¥ä»…è¿è¡Œè¯¥æµ‹è¯•ï¼š

```rust
$ cargo test one_hundred
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-06a75b4a1f2515e9

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out

```

#### é™¤éç‰¹åˆ«è¦æ±‚ï¼Œå¦åˆ™å¿½ç•¥æŸäº›æµ‹è¯•

æœ‰æ—¶æ‰§è¡Œä¸€äº›ç‰¹å®šçš„æµ‹è¯•å¯èƒ½éå¸¸è€—æ—¶ï¼Œå› æ­¤å¯èƒ½å¸Œæœ›åœ¨å¤§å¤šæ•°è¿è¡ŒæœŸé—´å°†å…¶æ’é™¤cargo testã€‚å¯ä»¥ä½¿ç”¨ignoreå±æ€§å°†å®ƒä»¬æ’é™¤åœ¨å¤–ï¼Œè€Œä¸æ˜¯å°†æƒ³è¿è¡Œçš„æ‰€æœ‰æµ‹è¯•éƒ½åˆ—ä¸ºå‚æ•°ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```rust

#![allow(unused_variables)]
fn main() {
#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn expensive_test() {
    // code that takes an hour to run
}
}

```

### æµ‹è¯•ç»„ç»‡

å¦‚æœ¬ç« å¼€å¤´æ‰€è¿°ï¼Œæµ‹è¯•æ˜¯ä¸€é—¨å¤æ‚çš„å­¦ç§‘ï¼Œä¸åŒçš„äººä½¿ç”¨ä¸åŒçš„æœ¯è¯­å’Œç»„ç»‡ã€‚Rustç¤¾åŒºä»ä¸¤ä¸ªä¸»è¦ç±»åˆ«æ¥è€ƒè™‘æµ‹è¯•ï¼šå•å…ƒæµ‹è¯•å’Œ é›†æˆæµ‹è¯•ã€‚å•å…ƒæµ‹è¯•ä½“ç§¯å°ä¸”é‡ç‚¹çªå‡ºï¼Œå¯ä»¥ä¸€æ¬¡å•ç‹¬æµ‹è¯•ä¸€ä¸ªæ¨¡å—ï¼Œå¹¶ä¸”å¯ä»¥æµ‹è¯•ä¸“ç”¨æ¥å£ã€‚é›†æˆæµ‹è¯•å®Œå…¨åœ¨çš„åº“å¤–éƒ¨ï¼Œå¹¶ä¸”ä»¥ä¸å…¶ä»–ä»»ä½•å¤–éƒ¨ä»£ç ç›¸åŒçš„æ–¹å¼ä½¿ç”¨çš„ä»£ç ï¼Œä»…ä½¿ç”¨å…¬å…±æ¥å£ï¼Œå¹¶ä¸”æ¯ä¸ªæµ‹è¯•å¯èƒ½ä½¿ç”¨å¤šä¸ªæ¨¡å—ã€‚

ç¼–å†™ä¸¤ç§æµ‹è¯•å¯¹äºç¡®ä¿åº“ä¸­çš„å„ä¸ªéƒ¨åˆ†åˆ†åˆ«æˆ–ä¸€èµ·æ‰§è¡Œé¢„æœŸçš„å·¥ä½œéå¸¸é‡è¦ã€‚

#### å•å…ƒæµ‹è¯•

å•å…ƒæµ‹è¯•çš„ç›®çš„æ˜¯ä¸å…¶ä½™ä»£ç éš”ç¦»åœ°æµ‹è¯•æ¯ä¸ªä»£ç å•å…ƒï¼Œä»¥å¿«é€ŸæŸ¥æ˜ä»£ç åœ¨å“ªé‡Œæ­£å¸¸å·¥ä½œå’Œä¸æ­£å¸¸å·¥ä½œã€‚å°†ä½¿ç”¨å®ƒä»¬æ­£åœ¨æµ‹è¯•çš„ä»£ç å°†å•å…ƒæµ‹è¯•æ”¾åœ¨æ¯ä¸ªæ–‡ä»¶çš„srcç›®å½•ä¸­ã€‚çº¦å®šæ˜¯tests åœ¨æ¯ä¸ªæ–‡ä»¶ä¸­åˆ›å»ºä¸€ä¸ªå‘½åæ¨¡å—ä»¥åŒ…å«æµ‹è¯•åŠŸèƒ½ï¼Œå¹¶ä½¿ç”¨å¯¹å…¶è¿›è¡Œæ³¨é‡Š cfg(test)ã€‚

##### æµ‹è¯•æ¨¡å—å’Œ `#[cfg(test)]`

è¯¥`#[cfg(test)]`æµ‹è¯•æ¨¡å—ä¸Šçš„æ³¨è§£å‘Šè¯‰é”ˆç¼–è¯‘åªæœ‰å½“ä½ è¿è¡Œè¿è¡Œæµ‹è¯•ä»£ç cargo testï¼Œè€Œä¸æ˜¯å½“ä½ è¿è¡Œcargo buildã€‚å½“åªæƒ³æ„å»ºåº“æ—¶ï¼Œè¿™æ ·å¯ä»¥èŠ‚çœç¼–è¯‘æ—¶é—´ï¼Œå¹¶ä¸”ç”±äºä¸åŒ…æ‹¬æµ‹è¯•ï¼Œå› æ­¤å¯ä»¥èŠ‚çœç”Ÿæˆçš„ç¼–è¯‘å·¥ä»¶ä¸­çš„ç©ºé—´ã€‚ä¼šçœ‹åˆ°ï¼Œç”±äºé›†æˆæµ‹è¯•ä½äºä¸åŒçš„ç›®å½•ä¸­ï¼Œå› æ­¤å®ƒä»¬ä¸éœ€è¦`#[cfg(test)]`æ³¨é‡Šã€‚ä½†æ˜¯ï¼Œç”±äºå•å…ƒæµ‹è¯•ä¸ä»£ç ä½äºç›¸åŒçš„æ–‡ä»¶ä¸­ï¼Œå› æ­¤å°†ç”¨äº`#[cfg(test)]`æŒ‡å®šä¸åº”å°†å…¶åŒ…å«åœ¨ç¼–è¯‘ç»“æœä¸­ã€‚

```rust

#![allow(unused_variables)]
fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
}

```

æ­¤ä»£ç æ˜¯è‡ªåŠ¨ç”Ÿæˆçš„æµ‹è¯•æ¨¡å—ã€‚è¯¥å±æ€§cfg ä»£è¡¨é…ç½®ï¼Œå¹¶å‘Šè¯‰Rustä»…åœ¨å…·æœ‰ç‰¹å®šé…ç½®é€‰é¡¹çš„æƒ…å†µä¸‹æ‰åº”åŒ…æ‹¬ä»¥ä¸‹é¡¹ç›®ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œé…ç½®é€‰é¡¹ä¸ºtestï¼Œç”±Rustæä¾›ï¼Œç”¨äºç¼–è¯‘å’Œè¿è¡Œæµ‹è¯•ã€‚é€šè¿‡ä½¿ç”¨è¯¥cfgå±æ€§ï¼Œä»…å½“ä½¿ç”¨ç§¯æè¿è¡Œæµ‹è¯•æ—¶ï¼ŒCargoæ‰ä¼šç¼–è¯‘æµ‹è¯•ä»£ç cargo testã€‚é™¤äº†ä½¿ç”¨æ³¨é‡Šçš„åŠŸèƒ½å¤–ï¼Œå®ƒè¿˜åŒ…æ‹¬æ­¤æ¨¡å—ä¸­å¯èƒ½åŒ…å«çš„æ‰€æœ‰å¸®åŠ©ç¨‹åºåŠŸèƒ½`#[test]`ã€‚

##### æµ‹è¯•ç§æœ‰åŠŸèƒ½

åœ¨æµ‹è¯•ç¤¾åŒºä¸­ï¼Œæ˜¯å¦åº”ç›´æ¥æµ‹è¯•ç§æœ‰åŠŸèƒ½å­˜åœ¨äº‰è®ºï¼Œè€Œå…¶ä»–è¯­è¨€ä½¿æµ‹è¯•ç§æœ‰åŠŸèƒ½å˜å¾—å›°éš¾æˆ–ä¸å¯èƒ½ã€‚æ— è®ºéµå¾ªå“ªç§æµ‹è¯•æ€æƒ³ï¼ŒRustçš„éšç§è§„åˆ™éƒ½å¯ä»¥è®©æµ‹è¯•ç§æœ‰åŠŸèƒ½ã€‚

```rust
fn main() {}

pub fn add_two(a: i32) -> i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}

```

#### æ•´åˆæµ‹è¯•

åœ¨Rustä¸­ï¼Œé›†æˆæµ‹è¯•å®Œå…¨åœ¨çš„åº“å¤–éƒ¨ã€‚ä»–ä»¬ä»¥ä¸å…¶ä»–ä»»ä½•ä»£ç ç›¸åŒçš„æ–¹å¼ä½¿ç”¨çš„åº“ï¼Œè¿™æ„å‘³ç€å®ƒä»¬åªèƒ½è°ƒç”¨å±äºåº“çš„å…¬å…±APIçš„å‡½æ•°ã€‚å®ƒä»¬çš„ç›®çš„æ˜¯æµ‹è¯•åº“ä¸­çš„è®¸å¤šéƒ¨åˆ†æ˜¯å¦å¯ä»¥æ­£å¸¸ååŒå·¥ä½œã€‚å•ç‹¬å·¥ä½œçš„ä»£ç å•å…ƒåœ¨é›†æˆæ—¶å¯èƒ½ä¼šå‡ºç°é—®é¢˜ï¼Œå› æ­¤æµ‹è¯•é›†æˆä»£ç çš„è¦†ç›–èŒƒå›´ä¹Ÿå¾ˆé‡è¦ã€‚è¦åˆ›å»ºé›†æˆæµ‹è¯•ï¼Œé¦–å…ˆéœ€è¦ä¸€ä¸ªtestsç›®å½•ã€‚

```rust
use adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}

```

##### é›†æˆæµ‹è¯•ä¸­çš„å­æ¨¡å—

å½“æ·»åŠ æ›´å¤šé›†æˆæµ‹è¯•æ—¶ï¼Œå¯èƒ½å¸Œæœ›åœ¨testsç›®å½•ä¸­åˆ¶ä½œå¤šä¸ªæ–‡ä»¶æ¥å¸®åŠ©ç»„ç»‡å®ƒä»¬ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥æŒ‰æµ‹è¯•åŠŸèƒ½å¯¹æµ‹è¯•åŠŸèƒ½è¿›è¡Œåˆ†ç»„ã€‚å¦‚å‰æ‰€è¿°ï¼Œtestsç›®å½•ä¸­çš„æ¯ä¸ªæ–‡ä»¶éƒ½è¢«ç¼–è¯‘ä¸ºè‡ªå·±çš„å•ç‹¬æ¿æ¡ç®±ã€‚

å°†æ¯ä¸ªé›†æˆæµ‹è¯•æ–‡ä»¶è§†ä¸ºè‡ªå·±çš„æ¿æ¡ç®±å¯¹äºåˆ›å»ºå•ç‹¬çš„ä½œç”¨åŸŸéå¸¸æœ‰ç”¨ï¼Œè¿™äº›èŒƒå›´æ›´åƒæœ€ç»ˆç”¨æˆ·å°†ä½¿ç”¨çš„æ¿æ¡ç®±ã€‚ä½†æ˜¯ï¼Œè¿™æ„å‘³ç€testsç›®å½•ä¸­çš„æ–‡ä»¶ä¸srcä¸­çš„æ–‡ä»¶ä¸å…·æœ‰ç›¸åŒçš„è¡Œä¸ºï¼Œæ­£å¦‚åœ¨ç¬¬7ç« ä¸­äº†è§£çš„æœ‰å…³å¦‚ä½•å°†ä»£ç åˆ†ä¸ºæ¨¡å—å’Œæ–‡ä»¶çš„çŸ¥è¯†ä¸€æ ·ã€‚

å½“å…·æœ‰ä¸€ç»„åœ¨å¤šä¸ªé›†æˆæµ‹è¯•æ–‡ä»¶ä¸­æœ‰ç”¨çš„å¸®åŠ©ç¨‹åºåŠŸèƒ½å¹¶ä¸”å°è¯•æŒ‰ç…§ ç¬¬7ç« çš„â€œå°†æ¨¡å—åˆ†ä¸ºä¸åŒçš„æ–‡ä»¶â€ä¸€èŠ‚ä¸­çš„æ­¥éª¤æ“ä½œæ—¶ï¼Œtestsç›®å½•ä¸­æ–‡ä»¶çš„ä¸åŒè¡Œä¸ºæœ€ä¸ºæ˜æ˜¾ã€‚å°†å®ƒä»¬æå–åˆ°ä¸€ä¸ªé€šç”¨æ¨¡å—ä¸­ã€‚ä¾‹å¦‚ï¼Œå¦‚æœåˆ›å»ºtests / common.rså¹¶åœ¨å…¶ä¸­æ”¾ç½®ä¸€ä¸ªå‘½åå‡½æ•°ï¼Œåˆ™å¯ä»¥åœ¨å¤šä¸ªæµ‹è¯•æ–‡ä»¶ä¸­æ·»åŠ è¦ä»å¤šä¸ªæµ‹è¯•å‡½æ•°è°ƒç”¨çš„ä»£ç ï¼šsetupsetup

```rust
use adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}

```

### I/Oé¡¹ç›®ï¼šæ„å»ºå‘½ä»¤è¡Œç¨‹åº

#### æ¥å—å‘½ä»¤è¡Œå‚æ•°

##### è¯»å–å‚æ•°å€¼

éœ€è¦ä¸€ä¸ªRustæ ‡å‡†åº“ä¸­æä¾›çš„å‡½æ•° std::env::argsã€‚

```rust
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();
    println!("{:?}", args);
}

```

*æ³¨æ„ï¼šè¯·æ³¨æ„ï¼Œstd::env::argså¦‚æœä»»ä½•å‚æ•°åŒ…å«æ— æ•ˆçš„Unicode ï¼Œå°†æ„Ÿåˆ°å¼‚å¸¸ã€‚å¦‚æœçš„ç¨‹åºéœ€è¦æ¥å—åŒ…å«æ— æ•ˆUnicodeçš„å‚æ•°ï¼Œè¯·std::env::args_osæ”¹ç”¨ã€‚è¯¥å‡½æ•°è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼Œè¯¥è¿­ä»£å™¨ç”ŸæˆOsStringå€¼è€Œä¸æ˜¯Stringå€¼ã€‚ä¹‹æ‰€ä»¥é€‰æ‹©std::env::argsæ­¤å¤„ä¸ºç®€å•èµ·è§ï¼Œå› ä¸ºOsStringæ¯ä¸ªå¹³å°çš„å€¼ä¸åŒï¼Œå¹¶ä¸”ä½¿ç”¨èµ·æ¥Stringæ¯”å€¼æ›´å¤æ‚ã€‚*

#### å°†å‚æ•°å€¼ä¿å­˜åœ¨å˜é‡ä¸­

æ‰“å°å‚æ•°å‘é‡çš„å€¼è¯´æ˜è¯¥ç¨‹åºèƒ½å¤Ÿè®¿é—®æŒ‡å®šä¸ºå‘½ä»¤è¡Œå‚æ•°çš„å€¼ã€‚ç°åœ¨éœ€è¦å°†ä¸¤ä¸ªå‚æ•°çš„å€¼ä¿å­˜åœ¨å˜é‡ä¸­ï¼Œä»¥ä¾¿å¯ä»¥åœ¨ç¨‹åºçš„å…¶ä½™éƒ¨åˆ†ä¸­ä½¿ç”¨è¿™äº›å€¼ã€‚

```rust
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();

    let query = &args[1];
    let filename = &args[2];

    println!("Searching for {}", query);
    println!("In file {}", filename);
}

```

æ­£å¦‚çœ‹åˆ°çš„é‚£æ ·ï¼Œåœ¨æ‰“å°çŸ¢é‡æ—¶ï¼Œç¨‹åºçš„åç§°å æ®äº†çŸ¢é‡ä¸­çš„ç¬¬ä¸€ä¸ªå€¼`args[0]`ï¼Œå› æ­¤ä»indexå¼€å§‹1ã€‚ç¬¬ä¸€ä¸ªå‚æ•°minigrepæ˜¯è¦æœç´¢çš„å­—ç¬¦ä¸²ï¼Œå› æ­¤åœ¨å˜é‡ä¸­å¼•ç”¨äº†ç¬¬ä¸€ä¸ªå‚æ•°queryã€‚ç¬¬äºŒä¸ªå‚æ•°æ˜¯æ–‡ä»¶åï¼Œå› æ­¤åœ¨å˜é‡ä¸­å¼•ç”¨äº†ç¬¬äºŒä¸ªå‚æ•°filenameã€‚

```rust
use std::env;
use std::fs;

fn main() {
    let args: Vec<String> = env::args().collect();

    let query = &args[1];
    let filename = &args[2];

    println!("Searching for {}", query);
    // --snip--
    println!("In file {}", filename);

    let contents = fs::read_to_string(filename)
        .expect("Something went wrong reading the file");

    println!("With text:\n{}", contents);
}

```

#### æå–å‚æ•°è§£æå™¨

```rust
fn main() {
    let args: Vec<String> = env::args().collect();

    let (query, filename) = parse_config(&args);

    // --snip--
}

fn parse_config(args: &[String]) -> (&str, &str) {
    let query = &args[1];
    let filename = &args[2];

    (query, filename)
}

```

```rust
use std::env;
use std::fs;

fn main() {
    let args: Vec<String> = env::args().collect();

    let config = parse_config(&args);

    println!("Searching for {}", config.query);
    println!("In file {}", config.filename);

    let contents = fs::read_to_string(config.filename)
        .expect("Something went wrong reading the file");

    // --snip--
}

struct Config {
    query: String,
    filename: String,
}

fn parse_config(args: &[String]) -> Config {
    let query = args[1].clone();
    let filename = args[2].clone();

    Config { query, filename }
}

```

```rust
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args);

    // --snip--
}

struct Config {
    query: String,
    filename: String,
}

// --snip--

impl Config {
    fn new(args: &[String]) -> Config {
        let query = args[1].clone();
        let filename = args[2].clone();

        Config { query, filename }
    }
}

```

##### æ”¹å–„é”™è¯¯ä¿¡æ¯

```rust
// --snip--
fn new(args: &[String]) -> Config {
    if args.len() < 3 {
        panic!("not enough arguments");
    }
    // --snip--

```

```rust
impl Config {
    fn new(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}

```

###### è°ƒç”¨Config::newå’Œå¤„ç†é”™è¯¯

```rust
use std::process;

fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args).unwrap_or_else(|err| {
        println!("Problem parsing arguments: {}", err);
        process::exit(1);
    });

    // --snip--

```

åœ¨æ­¤ç¨‹åºä¸­ï¼Œä½¿ç”¨äº†ä»¥å‰æ²¡æœ‰æ¶‰åŠçš„æ–¹æ³•ï¼š unwrap_or_elseï¼Œå®ƒæ˜¯`Result<T, E>`ç”±æ ‡å‡†åº“å®šä¹‰çš„ã€‚ä½¿ç”¨unwrap_or_elseå…è®¸å®šä¹‰ä¸€äº›è‡ªå®šä¹‰çš„ï¼Œépanic!é”™è¯¯çš„å¤„ç†ã€‚å¦‚æœResultæ˜¯ä¸€ä¸ªOkå€¼ï¼Œåˆ™æ­¤æ–¹æ³•çš„è¡Œä¸ºç±»ä¼¼äºunwrapï¼šå®ƒè¿”å›OkåŒ…è£…çš„å†…éƒ¨å€¼ã€‚ä½†æ˜¯ï¼Œå¦‚æœå€¼æ˜¯ä¸€ä¸ªErrå€¼ï¼Œåˆ™æ­¤æ–¹æ³•å°†è°ƒç”¨é—­åŒ…ä¸­çš„ä»£ç ï¼Œè¯¥é—­åŒ…æ˜¯å®šä¹‰çš„åŒ¿åå‡½æ•°ï¼Œå¹¶ä½œä¸ºå‚æ•°ä¼ é€’ç»™unwrap_or_elseã€‚

#### ä»ä¸­æå–é€»è¾‘ main

```rust
fn main() {
    // --snip--

    println!("Searching for {}", config.query);
    println!("In file {}", config.filename);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.filename)
        .expect("Something went wrong reading the file");

    println!("With text:\n{}", contents);
}

// --snip--

```

#### ä»runå‡½æ•°è¿”å›é”™è¯¯

å°†å…¶ä½™çš„ç¨‹åºé€»è¾‘åˆ†ç¦»åˆ°runå‡½æ•°ä¸­ï¼Œå¯ä»¥åƒConfig::newæ¸…å•12-9ä¸­é‚£æ ·æ”¹è¿›é”™è¯¯å¤„ç†ã€‚å½“å‡ºç°é—®é¢˜æ—¶expectï¼Œrun å‡½æ•°å°†è¿”å›a ï¼Œè€Œä¸æ˜¯é€šè¿‡è°ƒç”¨ä½¿ç¨‹åºå¼‚å¸¸`Result<T, E>`ã€‚è¿™å°†ä½¿è¿›ä¸€æ­¥mainä»¥ç”¨æˆ·å‹å¥½çš„æ–¹å¼æ•´åˆåˆ°å¤„ç†é”™è¯¯çš„é€»è¾‘ä¸­ã€‚

```rust
use std::error::Error;

// --snip--

fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.filename)?;

    println!("With text:\n{}", contents);

    Ok(())
}

```

#### å¤„ç†é”™è¯¯è¿”å›ä»runåœ¨main

```rust
fn main() {
    // --snip--

    println!("Searching for {}", config.query);
    println!("In file {}", config.filename);

    if let Err(e) = run(config) {
        println!("Application error: {}", e);

        process::exit(1);
    }
}

```

ä½¿ç”¨if letè€Œä¸æ˜¯unwrap_or_elseæ£€æŸ¥æ˜¯å¦runè¿”å›Errå€¼ï¼Œç„¶åè°ƒç”¨è¿”å› å€¼process::exit(1)ã€‚è¯¥runå‡½æ•°ä¸ä¼šä»¥ è¿”å›å®ä¾‹unwrapçš„ç›¸åŒæ–¹å¼Config::newè¿”å›æƒ³è¦çš„å€¼Configã€‚å› ä¸ºåœ¨æˆåŠŸæƒ…å†µä¸‹runè¿”å›()ï¼Œæ‰€ä»¥åªå…³å¿ƒæ£€æµ‹é”™è¯¯ï¼Œå› æ­¤ä¸éœ€è¦unwrap_or_elseè¿”å›å±•å¼€çš„å€¼ï¼Œå› ä¸ºå®ƒåªä¼šæ˜¯()ã€‚

#### å°†ä»£ç æ‹†åˆ†ä¸ºä¸åŒçš„æ–‡ä»¶

```rust
use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub filename: String,
}

impl Config {
    pub fn new(args: &[String]) -> Result<Config, &'static str> {
        // --snip--
    }
}

pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    // --snip--
}

```

```rust
use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --snip--
    if let Err(e) = minigrep::run(config) {
        // --snip--
    }
}

```

### é€šè¿‡æµ‹è¯•é©±åŠ¨å¼€å‘æ¥å¼€å‘åº“çš„åŠŸèƒ½

ä½¿ç”¨æµ‹è¯•é©±åŠ¨çš„å¼€å‘ï¼ˆTDDï¼‰æµç¨‹å°†æœç´¢é€»è¾‘æ·»åŠ åˆ°ç¨‹åºä¸­ã€‚æ­¤è½¯ä»¶å¼€å‘æŠ€æœ¯éµå¾ªä»¥ä¸‹æ­¥éª¤ï¼š

1. ç¼–å†™ä¸€ä¸ªå¤±è´¥çš„æµ‹è¯•å¹¶è¿è¡Œå®ƒï¼Œä»¥ç¡®ä¿ç”±äºæœŸæœ›çš„åŸå› è€Œå¤±è´¥ã€‚
2. ç¼–å†™æˆ–ä¿®æ”¹è¶³å¤Ÿçš„ä»£ç ä»¥ä½¿æ–°çš„æµ‹è¯•é€šè¿‡ã€‚
3. é‡æ„åˆšåˆšæ·»åŠ æˆ–æ›´æ”¹çš„ä»£ç ï¼Œå¹¶ç¡®ä¿æµ‹è¯•ç»§ç»­é€šè¿‡ã€‚
4. ä»æ­¥éª¤1å¼€å§‹é‡å¤ï¼

æ­¤è¿‡ç¨‹åªæ˜¯ç¼–å†™è½¯ä»¶çš„è®¸å¤šæ–¹æ³•ä¹‹ä¸€ï¼Œä½†æ˜¯TDDä¹Ÿå¯ä»¥å¸®åŠ©é©±åŠ¨ä»£ç è®¾è®¡ã€‚åœ¨ç¼–å†™ä½¿æµ‹è¯•é€šè¿‡çš„ä»£ç ä¹‹å‰ç¼–å†™æµ‹è¯•æœ‰åŠ©äºåœ¨æ•´ä¸ªè¿‡ç¨‹ä¸­ä¿æŒè¾ƒé«˜çš„æµ‹è¯•è¦†ç›–ç‡ã€‚

#### ç¼–å†™å¤±è´¥çš„æµ‹è¯•

```rust

#![allow(unused_variables)]
fn main() {
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
     vec![]
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.";

        assert_eq!(
            vec!["safe, fast, productive."],
            search(query, contents)
        );
    }
}
}

```

```rust

#![allow(unused_variables)]
fn main() {
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    vec![]
}
}

```

è¦'aåœ¨ç­¾åä¸­å®šä¹‰çš„æ˜¾å¼ç”Ÿå­˜æœŸï¼Œ searchå¹¶ä¸contentså‚æ•°å’Œè¿”å›å€¼ä¸€èµ·ä½¿ç”¨ã€‚

#### ç¼–å†™ä»£ç é€šè¿‡æµ‹è¯•

ç›®å‰ï¼Œçš„æµ‹è¯•å¤±è´¥äº†ï¼Œå› ä¸ºæ€»æ˜¯è¿”å›ä¸€ä¸ªç©ºå‘é‡ã€‚è¦è§£å†³æ­¤é—®é¢˜å¹¶å®æ–½searchï¼Œçš„ç¨‹åºéœ€è¦éµå¾ªä»¥ä¸‹æ­¥éª¤ï¼š

* éå†å†…å®¹çš„æ¯ä¸€è¡Œã€‚
* æ£€æŸ¥è¯¥è¡Œæ˜¯å¦åŒ…å«çš„æŸ¥è¯¢å­—ç¬¦ä¸²ã€‚
* å¦‚æœæ˜¯è¿™æ ·ï¼Œè¯·å°†å…¶æ·»åŠ åˆ°è¦è¿”å›çš„å€¼åˆ—è¡¨ä¸­ã€‚
* å¦‚æœæ²¡æœ‰ï¼Œåˆ™ä»€ä¹ˆä¹Ÿä¸åšã€‚
* è¿”å›åŒ¹é…çš„ç»“æœåˆ—è¡¨ã€‚

è®©å®Œæˆæ¯ä¸ªæ­¥éª¤ï¼Œä»éå†è¡Œå¼€å§‹ã€‚

##### é€šè¿‡è¯¥linesæ–¹æ³•è¿­ä»£çº¿

```rust
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    for line in contents.lines() {
        // do something with line
    }
}
```

##### åœ¨æ¯ä¸€è¡Œä¸­æœç´¢æŸ¥è¯¢

æ¥ä¸‹æ¥ï¼Œå°†æ£€æŸ¥å½“å‰è¡Œæ˜¯å¦åŒ…å«æŸ¥è¯¢å­—ç¬¦ä¸²ã€‚å¹¸è¿çš„æ˜¯ï¼Œå­—ç¬¦ä¸²æœ‰ä¸€ä¸ªæœ‰ç”¨çš„åä¸ºçš„æ–¹æ³•containsï¼Œå¯ä»¥ä¸ºåšåˆ°è¿™ä¸€ç‚¹ï¼containsåœ¨searchå‡½æ•°ä¸­æ·»åŠ å¯¹æ–¹æ³•çš„è°ƒç”¨

```rust
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}

```

##### å­˜å‚¨åŒ¹é…çš„è¡Œ

è¿˜éœ€è¦ä¸€ä¸ªæ–¹æ³•æ¥å­˜å‚¨åŒ…å«æŸ¥è¯¢å­—ç¬¦ä¸²çš„è¡Œã€‚ä¸ºæ­¤å¯ä»¥åœ¨ for å¾ªç¯ä¹‹å‰åˆ›å»ºä¸€ä¸ªå¯å˜çš„ vector å¹¶è°ƒç”¨ push æ–¹æ³•åœ¨ vector ä¸­å­˜æ”¾ä¸€ä¸ª lineã€‚åœ¨ for å¾ªç¯ä¹‹åï¼Œè¿”å›è¿™ä¸ª vectorï¼Œ

```rust
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}

```

##### åœ¨ run å‡½æ•°ä¸­ä½¿ç”¨ search å‡½æ•°

ç°åœ¨ search å‡½æ•°æ˜¯å¯ä»¥å·¥ä½œå¹¶æµ‹è¯•é€šè¿‡äº†çš„ï¼Œéœ€è¦å®é™…åœ¨ run å‡½æ•°ä¸­è°ƒç”¨ searchã€‚éœ€è¦å°† config.query å€¼å’Œ run ä»æ–‡ä»¶ä¸­è¯»å–çš„ contents ä¼ é€’ç»™ search å‡½æ•°ã€‚æ¥ç€ run ä¼šæ‰“å°å‡º search è¿”å›çš„æ¯ä¸€è¡Œï¼š

```rust
pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.filename)?;

    for line in search(&config.query, &contents) {
        println!("{}", line);
    }

    Ok(())
}

```

#### ç¼–å†™ä¸€ä¸ªå¤§å°å†™ä¸æ•æ„Ÿ search å‡½æ•°çš„å¤±è´¥æµ‹è¯•

å¸Œæœ›å¢åŠ ä¸€ä¸ªæ–°å‡½æ•° search_case_insensitiveï¼Œå¹¶å°†ä¼šåœ¨è®¾ç½®äº†ç¯å¢ƒå˜é‡æ—¶è°ƒç”¨å®ƒã€‚è¿™é‡Œå°†ç»§ç»­éµå¾ª TDD è¿‡ç¨‹ï¼Œå…¶ç¬¬ä¸€æ­¥æ˜¯å†æ¬¡ç¼–å†™ä¸€ä¸ªå¤±è´¥æµ‹è¯•ã€‚å°†ä¸ºæ–°çš„å¤§å°å†™ä¸æ•æ„Ÿæœç´¢å‡½æ•°æ–°å¢ä¸€ä¸ªæµ‹è¯•å‡½æ•°ï¼Œå¹¶å°†è€çš„æµ‹è¯•å‡½æ•°ä» one_result æ”¹åä¸º case_sensitive æ¥æ›´æ¸…æ¥šçš„è¡¨æ˜è¿™ä¸¤ä¸ªæµ‹è¯•çš„åŒºåˆ«ï¼Œ

```rust

#![allow(unused_variables)]
fn main() {
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Duct tape.";

        assert_eq!(
            vec!["safe, fast, productive."],
            search(query, contents)
        );
    }

    #[test]
    fn case_insensitive() {
        let query = "rUsT";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Trust me.";

        assert_eq!(
            vec!["Rust:", "Trust me."],
            search_case_insensitive(query, contents)
        );
    }
}
}
```

æ³¨æ„ä¹Ÿæ”¹å˜äº†è€æµ‹è¯•ä¸­ contents çš„å€¼ã€‚è¿˜æ–°å¢äº†ä¸€ä¸ªå«æœ‰æ–‡æœ¬ "Duct tape." çš„è¡Œï¼Œå®ƒæœ‰ä¸€ä¸ªå¤§å†™çš„ Dï¼Œè¿™åœ¨å¤§å°å†™æ•æ„Ÿæœç´¢æ—¶ä¸åº”è¯¥åŒ¹é… "duct"ã€‚ä¿®æ”¹è¿™ä¸ªæµ‹è¯•ä»¥ç¡®ä¿ä¸ä¼šæ„å¤–ç ´åå·²ç»å®ç°çš„å¤§å°å†™æ•æ„Ÿæœç´¢åŠŸèƒ½ï¼›è¿™ä¸ªæµ‹è¯•ç°åœ¨åº”è¯¥èƒ½é€šè¿‡å¹¶åœ¨å¤„ç†å¤§å°å†™ä¸æ•æ„Ÿæœç´¢æ—¶åº”è¯¥èƒ½ä¸€ç›´é€šè¿‡ã€‚

å¤§å°å†™ ä¸æ•æ„Ÿ æœç´¢çš„æ–°æµ‹è¯•ä½¿ç”¨ "rUsT" ä½œä¸ºå…¶æŸ¥è¯¢å­—ç¬¦ä¸²ã€‚åœ¨å°†è¦å¢åŠ çš„ search_case_insensitive å‡½æ•°ä¸­ï¼Œ"rUsT" æŸ¥è¯¢åº”è¯¥åŒ…å«å¸¦æœ‰ä¸€ä¸ªå¤§å†™ R çš„ "Rust:" è¿˜æœ‰ "Trust me." è¿™ä¸¤è¡Œï¼Œå³ä¾¿ä»–ä»¬ä¸æŸ¥è¯¢çš„å¤§å°å†™éƒ½ä¸åŒã€‚è¿™ä¸ªæµ‹è¯•ç°åœ¨ä¼šç¼–è¯‘å¤±è´¥å› ä¸ºè¿˜æ²¡æœ‰å®šä¹‰ search_case_insensitive å‡½æ•°ã€‚è¯·éšæ„å¢åŠ ä¸€ä¸ªæ€»æ˜¯è¿”å›ç©º vector çš„éª¨æ¶å®ç°ï¼Œ

#### å®ç° search_case_insensitive å‡½æ•°

search_case_insensitive å‡½æ•°ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼Œå°†ä¸ search å‡½æ•°åŸºæœ¬ç›¸åŒã€‚å”¯ä¸€çš„åŒºåˆ«æ˜¯å®ƒä¼šå°† query å˜é‡å’Œæ¯ä¸€ line éƒ½å˜ä¸ºå°å†™ï¼Œè¿™æ ·ä¸ç®¡è¾“å…¥å‚æ•°æ˜¯å¤§å†™è¿˜æ˜¯å°å†™ï¼Œåœ¨æ£€æŸ¥è¯¥è¡Œæ˜¯å¦åŒ…å«æŸ¥è¯¢å­—ç¬¦ä¸²æ—¶éƒ½ä¼šæ˜¯å°å†™ã€‚

```rust

#![allow(unused_variables)]
fn main() {
pub fn search_case_insensitive<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&query) {
            results.push(line);
        }
    }

    results
}
}
```

é¦–å…ˆå°† query å­—ç¬¦ä¸²è½¬æ¢ä¸ºå°å†™ï¼Œå¹¶å°†å…¶è¦†ç›–åˆ°åŒåçš„å˜é‡ä¸­ã€‚å¯¹æŸ¥è¯¢å­—ç¬¦ä¸²è°ƒç”¨ to_lowercase æ˜¯å¿…éœ€çš„ï¼Œè¿™æ ·ä¸ç®¡ç”¨æˆ·çš„æŸ¥è¯¢æ˜¯ "rust"ã€"RUST"ã€"Rust" æˆ–è€… "rUsT"ï¼Œéƒ½å°†å…¶å½“ä½œ "rust" å¤„ç†å¹¶å¯¹å¤§å°å†™ä¸æ•æ„Ÿã€‚

æ³¨æ„ query ç°åœ¨æ˜¯ä¸€ä¸ª String è€Œä¸æ˜¯å­—ç¬¦ä¸² sliceï¼Œå› ä¸ºè°ƒç”¨ to_lowercase æ˜¯åœ¨åˆ›å»ºæ–°æ•°æ®ï¼Œè€Œä¸æ˜¯å¼•ç”¨ç°æœ‰æ•°æ®ã€‚å¦‚æœæŸ¥è¯¢å­—ç¬¦ä¸²æ˜¯ "rUsT"ï¼Œè¿™ä¸ªå­—ç¬¦ä¸² slice å¹¶ä¸åŒ…å«å¯ä¾›ä½¿ç”¨çš„å°å†™çš„ u æˆ– tï¼Œæ‰€ä»¥å¿…éœ€åˆ†é…ä¸€ä¸ªåŒ…å« "rust" çš„æ–° Stringã€‚ç°åœ¨å½“å°† query ä½œä¸ºä¸€ä¸ªå‚æ•°ä¼ é€’ç»™ contains æ–¹æ³•æ—¶ï¼Œéœ€è¦å¢åŠ ä¸€ä¸ª & å› ä¸º contains çš„ç­¾åè¢«å®šä¹‰ä¸ºè·å–ä¸€ä¸ªå­—ç¬¦ä¸² sliceã€‚

æ¥ä¸‹æ¥åœ¨æ£€æŸ¥æ¯ä¸ª line æ˜¯å¦åŒ…å« search ä¹‹å‰å¢åŠ äº†ä¸€ä¸ª to_lowercase è°ƒç”¨å°†ä»–ä»¬éƒ½å˜ä¸ºå°å†™ã€‚ç°åœ¨å°† line å’Œ query éƒ½è½¬æ¢æˆäº†å°å†™ï¼Œè¿™æ ·å°±å¯ä»¥ä¸ç®¡æŸ¥è¯¢çš„å¤§å°å†™è¿›è¡ŒåŒ¹é…äº†ã€‚

```rust

#![allow(unused_variables)]
fn main() {
pub struct Config {
    pub query: String,
    pub filename: String,
    pub case_sensitive: bool,
}
}
```

è¿™é‡Œå¢åŠ äº† case_sensitive å­—ç¬¦æ¥å­˜æ”¾ä¸€ä¸ªå¸ƒå°”å€¼ã€‚æ¥ç€éœ€è¦ run å‡½æ•°æ£€æŸ¥ case_sensitive å­—æ®µçš„å€¼å¹¶ä½¿ç”¨å®ƒæ¥å†³å®šæ˜¯å¦è°ƒç”¨ search å‡½æ•°æˆ– search_case_insensitive å‡½æ•°ï¼Œ

```rust

#![allow(unused_variables)]
fn main() {
use std::error::Error;
use std::fs::{self, File};
use std::io::prelude::*;

pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
     vec![]
}

pub fn search_case_insensitive<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
     vec![]
}

pub struct Config {
    query: String,
    filename: String,
    case_sensitive: bool,
}

pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.filename)?;

    let results = if config.case_sensitive {
        search(&config.query, &contents)
    } else {
        search_case_insensitive(&config.query, &contents)
    };

    for line in results {
        println!("{}", line);
    }

    Ok(())
}
}
```

æœ€åéœ€è¦å®é™…æ£€æŸ¥ç¯å¢ƒå˜é‡ã€‚å¤„ç†ç¯å¢ƒå˜é‡çš„å‡½æ•°ä½äºæ ‡å‡†åº“çš„ env æ¨¡å—ä¸­ï¼Œæ‰€ä»¥éœ€è¦åœ¨ src/lib.rs çš„å¼€å¤´å¢åŠ ä¸€ä¸ª use std::env; è¡Œå°†è¿™ä¸ªæ¨¡å—å¼•å…¥ä½œç”¨åŸŸä¸­ã€‚æ¥ç€åœ¨ Config::new ä¸­ä½¿ç”¨ env æ¨¡å—çš„ var æ–¹æ³•æ¥æ£€æŸ¥ä¸€ä¸ªå«åš CASE_INSENSITIVE çš„ç¯å¢ƒå˜é‡ï¼Œ

```rust

#![allow(unused_variables)]
fn main() {
use std::env;
struct Config {
    query: String,
    filename: String,
    case_sensitive: bool,
}

// --snip--

impl Config {
    pub fn new(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var("CASE_INSENSITIVE").is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
}
```

è¿™é‡Œåˆ›å»ºäº†ä¸€ä¸ªæ–°å˜é‡ case_sensitiveã€‚ä¸ºäº†è®¾ç½®å®ƒçš„å€¼ï¼Œéœ€è¦è°ƒç”¨ env::var å‡½æ•°å¹¶ä¼ é€’éœ€è¦å¯»æ‰¾çš„ç¯å¢ƒå˜é‡åç§°ï¼ŒCASE_INSENSITIVEã€‚env::var è¿”å›ä¸€ä¸ª Resultï¼Œå®ƒåœ¨ç¯å¢ƒå˜é‡è¢«è®¾ç½®æ—¶è¿”å›åŒ…å«å…¶å€¼çš„ Ok æˆå‘˜ï¼Œå¹¶åœ¨ç¯å¢ƒå˜é‡æœªè¢«è®¾ç½®æ—¶è¿”å› Err æˆå‘˜ã€‚

ä½¿ç”¨ Result çš„ is_err æ–¹æ³•æ¥æ£€æŸ¥å…¶æ˜¯å¦æ˜¯ä¸€ä¸ª errorï¼ˆä¹Ÿå°±æ˜¯ç¯å¢ƒå˜é‡æœªè¢«è®¾ç½®çš„æƒ…å†µï¼‰ï¼Œè¿™ä¹Ÿå°±æ„å‘³ç€ éœ€è¦ è¿›è¡Œä¸€ä¸ªå¤§å°å†™æ•æ„Ÿæœç´¢ã€‚å¦‚æœCASE_INSENSITIVE ç¯å¢ƒå˜é‡è¢«è®¾ç½®ä¸ºä»»ä½•å€¼ï¼Œis_err ä¼šè¿”å› false å¹¶å°†è¿›è¡Œå¤§å°å†™ä¸æ•æ„Ÿæœç´¢ã€‚å¹¶ä¸å…³å¿ƒç¯å¢ƒå˜é‡æ‰€è®¾ç½®çš„ å€¼ï¼Œåªå…³å¿ƒå®ƒæ˜¯å¦è¢«è®¾ç½®äº†ï¼Œæ‰€ä»¥æ£€æŸ¥ is_err è€Œä¸æ˜¯ unwrapã€expect æˆ–ä»»ä½•å·²ç»è§è¿‡çš„ Result çš„æ–¹æ³•ã€‚

å°†å˜é‡ case_sensitive çš„å€¼ä¼ é€’ç»™ Config å®ä¾‹ï¼Œè¿™æ · run å‡½æ•°å¯ä»¥è¯»å–å…¶å€¼å¹¶å†³å®šæ˜¯å¦è°ƒç”¨ search æˆ–è€…ç¤ºä¾‹ 12-22 ä¸­å®ç°çš„ search_case_insensitiveã€‚

#### æ£€æŸ¥é”™è¯¯åº”è¯¥å†™å…¥ä½•å¤„

é¦–å…ˆï¼Œè®©è§‚å¯Ÿä¸€ä¸‹ç›®å‰ minigrep æ‰“å°çš„æ‰€æœ‰å†…å®¹æ˜¯å¦‚ä½•è¢«å†™å…¥æ ‡å‡†è¾“å‡ºçš„ï¼ŒåŒ…æ‹¬é‚£äº›åº”è¯¥è¢«å†™å…¥æ ‡å‡†é”™è¯¯çš„é”™è¯¯ä¿¡æ¯ã€‚å¯ä»¥é€šè¿‡å°†æ ‡å‡†è¾“å‡ºæµé‡å®šå‘åˆ°ä¸€ä¸ªæ–‡ä»¶åŒæ—¶æœ‰æ„äº§ç”Ÿä¸€ä¸ªé”™è¯¯æ¥åšåˆ°è¿™ä¸€ç‚¹ã€‚æ²¡æœ‰é‡å®šå‘æ ‡å‡†é”™è¯¯æµï¼Œæ‰€ä»¥ä»»ä½•å‘é€åˆ°æ ‡å‡†é”™è¯¯çš„å†…å®¹å°†ä¼šç»§ç»­æ˜¾ç¤ºåœ¨å±å¹•ä¸Šã€‚

å‘½ä»¤è¡Œç¨‹åºè¢«æœŸæœ›å°†é”™è¯¯ä¿¡æ¯å‘é€åˆ°æ ‡å‡†é”™è¯¯æµï¼Œè¿™æ ·å³ä¾¿é€‰æ‹©å°†æ ‡å‡†è¾“å‡ºæµé‡å®šå‘åˆ°æ–‡ä»¶ä¸­æ—¶ä»ç„¶èƒ½çœ‹åˆ°é”™è¯¯ä¿¡æ¯ã€‚ç›®å‰çš„ç¨‹åºå¹¶ä¸ç¬¦åˆæœŸæœ›ï¼›ç›¸åå°†çœ‹åˆ°å®ƒå°†é”™è¯¯ä¿¡æ¯è¾“å‡ºä¿å­˜åˆ°äº†æ–‡ä»¶ä¸­ã€‚

#### å°†é”™è¯¯æ‰“å°åˆ°æ ‡å‡†é”™è¯¯

```rust
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {}", err);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!("Application error: {}", e);

        process::exit(1);
    }
}

```

### Rust ä¸­çš„å‡½æ•°å¼è¯­è¨€åŠŸèƒ½ï¼šè¿­ä»£å™¨ä¸é—­åŒ…

Rust çš„è®¾è®¡çµæ„Ÿæ¥æºäºå¾ˆå¤šç°å­˜çš„è¯­è¨€å’ŒæŠ€æœ¯ã€‚å…¶ä¸­ä¸€ä¸ªæ˜¾è‘—çš„å½±å“å°±æ˜¯ å‡½æ•°å¼ç¼–ç¨‹ï¼ˆfunctional programmingï¼‰ã€‚å‡½æ•°å¼ç¼–ç¨‹é£æ ¼é€šå¸¸åŒ…å«å°†å‡½æ•°ä½œä¸ºå‚æ•°å€¼æˆ–å…¶ä»–å‡½æ•°çš„è¿”å›å€¼ã€å°†å‡½æ•°èµ‹å€¼ç»™å˜é‡ä»¥ä¾›ä¹‹åæ‰§è¡Œç­‰ç­‰ã€‚

æœ¬ç« ä¸ä¼šè®¨è®ºå‡½æ•°å¼ç¼–ç¨‹æ˜¯æˆ–ä¸æ˜¯ä»€ä¹ˆçš„é—®é¢˜ï¼Œè€Œæ˜¯å±•ç¤º Rust çš„ä¸€äº›åœ¨åŠŸèƒ½ä¸Šä¸å…¶ä»–è¢«è®¤ä¸ºæ˜¯å‡½æ•°å¼è¯­è¨€ç±»ä¼¼çš„ç‰¹æ€§ã€‚

æ›´å…·ä½“çš„ï¼Œå°†è¦æ¶‰åŠï¼š

* **é—­åŒ…ï¼ˆClosuresï¼‰**ï¼Œä¸€ä¸ªå¯ä»¥å‚¨å­˜åœ¨å˜é‡é‡Œçš„ç±»ä¼¼å‡½æ•°çš„ç»“æ„
* **è¿­ä»£å™¨ï¼ˆIteratorsï¼‰**ï¼Œä¸€ç§å¤„ç†å…ƒç´ åºåˆ—çš„æ–¹å¼

#### é—­åŒ…ï¼šå¯ä»¥æ•è·ç¯å¢ƒçš„åŒ¿åå‡½æ•°

Rust çš„ é—­åŒ…ï¼ˆclosuresï¼‰æ˜¯å¯ä»¥ä¿å­˜è¿›å˜é‡æˆ–ä½œä¸ºå‚æ•°ä¼ é€’ç»™å…¶ä»–å‡½æ•°çš„åŒ¿åå‡½æ•°ã€‚å¯ä»¥åœ¨ä¸€ä¸ªåœ°æ–¹åˆ›å»ºé—­åŒ…ï¼Œç„¶ååœ¨ä¸åŒçš„ä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œé—­åŒ…è¿ç®—ã€‚ä¸åŒäºå‡½æ•°ï¼Œé—­åŒ…å…è®¸æ•è·è°ƒç”¨è€…ä½œç”¨åŸŸä¸­çš„å€¼ã€‚å°†å±•ç¤ºé—­åŒ…çš„è¿™äº›åŠŸèƒ½å¦‚ä½•å¤ç”¨ä»£ç å’Œè‡ªå®šä¹‰è¡Œä¸ºã€‚

#### ä½¿ç”¨é—­åŒ…åˆ›å»ºè¡Œä¸ºçš„æŠ½è±¡

è®©æ¥çœ‹ä¸€ä¸ªå­˜å‚¨ç¨åè¦æ‰§è¡Œçš„é—­åŒ…çš„ç¤ºä¾‹ã€‚å…¶é—´ä¼šè®¨è®ºé—­åŒ…çš„è¯­æ³•ã€ç±»å‹æ¨æ–­å’Œ traitã€‚

è€ƒè™‘ä¸€ä¸‹è¿™ä¸ªå‡æƒ³çš„æƒ…å†µï¼šåœ¨ä¸€ä¸ªé€šè¿‡ app ç”Ÿæˆè‡ªå®šä¹‰å¥èº«è®¡åˆ’çš„åˆåˆ›ä¼ä¸šå·¥ä½œã€‚å…¶åç«¯ä½¿ç”¨ Rust ç¼–å†™ï¼Œè€Œç”Ÿæˆå¥èº«è®¡åˆ’çš„ç®—æ³•éœ€è¦è€ƒè™‘å¾ˆå¤šä¸åŒçš„å› ç´ ï¼Œæ¯”å¦‚ç”¨æˆ·çš„å¹´é¾„ã€èº«ä½“è´¨é‡æŒ‡æ•°ï¼ˆBody Mass Indexï¼‰ã€ç”¨æˆ·å–œå¥½ã€æœ€è¿‘çš„å¥èº«æ´»åŠ¨å’Œç”¨æˆ·æŒ‡å®šçš„å¼ºåº¦ç³»æ•°ã€‚æœ¬ä¾‹ä¸­å®é™…çš„ç®—æ³•å¹¶ä¸é‡è¦ï¼Œé‡è¦çš„æ˜¯è¿™ä¸ªè®¡ç®—åªèŠ±è´¹å‡ ç§’é’Ÿã€‚åªå¸Œæœ›åœ¨éœ€è¦æ—¶è°ƒç”¨ç®—æ³•ï¼Œå¹¶ä¸”åªå¸Œæœ›è°ƒç”¨ä¸€æ¬¡ï¼Œè¿™æ ·å°±ä¸ä¼šè®©ç”¨æˆ·ç­‰å¾—å¤ªä¹…ã€‚

```rust

#![allow(unused_variables)]
fn main() {
use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: u32) -> u32 {
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    intensity
}
}
```

æ¥ä¸‹æ¥ï¼Œmain å‡½æ•°ä¸­å°†ä¼šåŒ…å«æœ¬ä¾‹çš„å¥èº« app ä¸­çš„é‡è¦éƒ¨åˆ†ã€‚è¿™ä»£è¡¨å½“ç”¨æˆ·è¯·æ±‚å¥èº«è®¡åˆ’æ—¶ app ä¼šè°ƒç”¨çš„ä»£ç ã€‚å› ä¸ºä¸ app å‰ç«¯çš„äº¤äº’ä¸é—­åŒ…çš„ä½¿ç”¨å¹¶ä¸ç›¸å…³ï¼Œæ‰€ä»¥å°†ç¡¬ç¼–ç ä»£è¡¨ç¨‹åºè¾“å…¥çš„å€¼å¹¶æ‰“å°è¾“å‡ºã€‚

æ‰€éœ€çš„è¾“å…¥æœ‰è¿™äº›ï¼š

* ä¸€ä¸ªæ¥è‡ªç”¨æˆ·çš„ intensity æ•°å­—ï¼Œè¯·æ±‚å¥èº«è®¡åˆ’æ—¶æŒ‡å®šï¼Œå®ƒä»£è¡¨ç”¨æˆ·å–œå¥½ä½å¼ºåº¦è¿˜æ˜¯é«˜å¼ºåº¦å¥èº«ã€‚
* ä¸€ä¸ªéšæœºæ•°ï¼Œå…¶ä¼šåœ¨å¥èº«è®¡åˆ’ä¸­ç”Ÿæˆå˜åŒ–ã€‚

ç¨‹åºçš„è¾“å‡ºå°†ä¼šæ˜¯å»ºè®®çš„é”»ç‚¼è®¡åˆ’ã€‚ç¤ºä¾‹ 13-2 å±•ç¤ºäº†å°†è¦ä½¿ç”¨çš„ main å‡½æ•°ï¼š

```rust
fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;

    generate_workout(
        simulated_user_specified_value,
        simulated_random_number
    );
}
fn generate_workout(intensity: u32, random_number: u32) {}

```

å‡ºäºç®€å•è€ƒè™‘è¿™é‡Œç¡¬ç¼–ç äº† simulated_user_specified_value å˜é‡çš„å€¼ä¸º 10 å’Œ simulated_random_number å˜é‡çš„å€¼ä¸º 7ï¼›ä¸€ä¸ªå®é™…çš„ç¨‹åºä¼šä» app å‰ç«¯è·å–å¼ºåº¦ç³»æ•°å¹¶ä½¿ç”¨ rand crate æ¥ç”Ÿæˆéšæœºæ•°ï¼Œæ­£å¦‚ç¬¬äºŒç« çš„çŒœçŒœçœ‹æ¸¸æˆæ‰€åšçš„é‚£æ ·ã€‚main å‡½æ•°ä½¿ç”¨æ¨¡æ‹Ÿçš„è¾“å…¥å€¼è°ƒç”¨ generate_workout å‡½æ•°ï¼š

ç°åœ¨æœ‰äº†æ‰§è¡Œä¸Šä¸‹æ–‡ï¼Œè®©ç¼–å†™ç®—æ³•ã€‚ç¤ºä¾‹ 13-3 ä¸­çš„ generate_workout å‡½æ•°åŒ…å«æœ¬ä¾‹ä¸­æœ€å…³å¿ƒçš„ app ä¸šåŠ¡é€»è¾‘ã€‚æœ¬ä¾‹ä¸­ä½™ä¸‹çš„ä»£ç ä¿®æ”¹éƒ½å°†åœ¨è¿™ä¸ªå‡½æ•°ä¸­è¿›è¡Œï¼š

```rust

#![allow(unused_variables)]
fn main() {
use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(num: u32) -> u32 {
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    num
}

fn generate_workout(intensity: u32, random_number: u32) {
    if intensity < 25 {
        println!(
            "Today, do {} pushups!",
            simulated_expensive_calculation(intensity)
        );
        println!(
            "Next, do {} situps!",
            simulated_expensive_calculation(intensity)
        );
    } else {
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!(
                "Today, run for {} minutes!",
                simulated_expensive_calculation(intensity)
            );
        }
    }
}
}
```

ç°åœ¨è¿™ä»½ä»£ç èƒ½å¤Ÿåº”å¯¹çš„éœ€æ±‚äº†ï¼Œä½†æ•°æ®ç§‘å­¦éƒ¨é—¨çš„åŒå­¦å‘ŠçŸ¥å°†æ¥ä¼šå¯¹è°ƒç”¨ simulated_expensive_calculation çš„æ–¹å¼åšå‡ºä¸€äº›æ”¹å˜ã€‚ä¸ºäº†åœ¨è¦åšè¿™äº›æ”¹åŠ¨çš„æ—¶å€™ç®€åŒ–æ›´æ–°æ­¥éª¤ï¼Œå°†é‡æ„ä»£ç æ¥è®©å®ƒåªè°ƒç”¨ simulated_expensive_calculation ä¸€æ¬¡ã€‚åŒæ—¶è¿˜å¸Œæœ›å»æ‰ç›®å‰å¤šä½™çš„è¿ç»­ä¸¤æ¬¡å‡½æ•°è°ƒç”¨ï¼Œå¹¶ä¸å¸Œæœ›åœ¨è®¡ç®—è¿‡ç¨‹ä¸­å¢åŠ ä»»ä½•å…¶ä»–æ­¤å‡½æ•°çš„è°ƒç”¨ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸å¸Œæœ›åœ¨å®Œå…¨æ— éœ€å…¶ç»“æœçš„æƒ…å†µè°ƒç”¨å‡½æ•°ï¼Œä¸è¿‡ä»ç„¶å¸Œæœ›åªè°ƒç”¨å‡½æ•°ä¸€æ¬¡ã€‚

#### ä½¿ç”¨å‡½æ•°é‡æ„

```rust

#![allow(unused_variables)]
fn main() {
use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(num: u32) -> u32 {
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    num
}

fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_result =
        simulated_expensive_calculation(intensity);

    if intensity < 25 {
        println!(
            "Today, do {} pushups!",
            expensive_result
        );
        println!(
            "Next, do {} situps!",
            expensive_result
        );
    } else {
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!(
                "Today, run for {} minutes!",
                expensive_result
            );
        }
    }
}
}
```

#### é‡æ„ä½¿ç”¨é—­åŒ…å‚¨å­˜ä»£ç 

ä¸åŒäºæ€»æ˜¯åœ¨ if å—ä¹‹å‰è°ƒç”¨ simulated_expensive_calculation å‡½æ•°å¹¶å‚¨å­˜å…¶ç»“æœï¼Œå¯ä»¥å®šä¹‰ä¸€ä¸ªé—­åŒ…å¹¶å°†å…¶å‚¨å­˜åœ¨å˜é‡ä¸­ï¼Œå¦‚ç¤ºä¾‹ 13-5 æ‰€ç¤ºã€‚å®é™…ä¸Šå¯ä»¥é€‰æ‹©å°†æ•´ä¸ª simulated_expensive_calculation å‡½æ•°ä½“ç§»åŠ¨åˆ°è¿™é‡Œå¼•å…¥çš„é—­åŒ…ä¸­ï¼š

```rust

#![allow(unused_variables)]
fn main() {
use std::thread;
use std::time::Duration;

let expensive_closure = |num| {
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    num
};
expensive_closure(5);
}
```

é—­åŒ…å®šä¹‰æ˜¯ expensive_closure èµ‹å€¼çš„ = ä¹‹åçš„éƒ¨åˆ†ã€‚é—­åŒ…çš„å®šä¹‰ä»¥ä¸€å¯¹ç«–çº¿ï¼ˆ|ï¼‰å¼€å§‹ï¼Œåœ¨ç«–çº¿ä¸­æŒ‡å®šé—­åŒ…çš„å‚æ•°ï¼›ä¹‹æ‰€ä»¥é€‰æ‹©è¿™ä¸ªè¯­æ³•æ˜¯å› ä¸ºå®ƒä¸ Smalltalk å’Œ Ruby çš„é—­åŒ…å®šä¹‰ç±»ä¼¼ã€‚è¿™ä¸ªé—­åŒ…æœ‰ä¸€ä¸ªå‚æ•° numï¼›å¦‚æœæœ‰å¤šäºä¸€ä¸ªå‚æ•°ï¼Œå¯ä»¥ä½¿ç”¨é€—å·åˆ†éš”ï¼Œæ¯”å¦‚ |param1, param2|ã€‚

å‚æ•°ä¹‹åæ˜¯å­˜æ”¾é—­åŒ…ä½“çš„å¤§æ‹¬å· â€”â€” å¦‚æœé—­åŒ…ä½“åªæœ‰ä¸€è¡Œåˆ™å¤§æ‹¬å·æ˜¯å¯ä»¥çœç•¥çš„ã€‚å¤§æ‹¬å·ä¹‹åé—­åŒ…çš„ç»“å°¾ï¼Œéœ€è¦ç”¨äº let è¯­å¥çš„åˆ†å·ã€‚å› ä¸ºé—­åŒ…ä½“çš„æœ€åä¸€è¡Œæ²¡æœ‰åˆ†å·ï¼ˆæ­£å¦‚å‡½æ•°ä½“ä¸€æ ·ï¼‰ï¼Œæ‰€ä»¥é—­åŒ…ä½“ï¼ˆnumï¼‰æœ€åä¸€è¡Œçš„è¿”å›å€¼ä½œä¸ºè°ƒç”¨é—­åŒ…æ—¶çš„è¿”å›å€¼ ã€‚

æ³¨æ„è¿™ä¸ª let è¯­å¥æ„å‘³ç€ expensive_closure åŒ…å«ä¸€ä¸ªåŒ¿åå‡½æ•°çš„ å®šä¹‰ï¼Œä¸æ˜¯è°ƒç”¨åŒ¿åå‡½æ•°çš„ è¿”å›å€¼ã€‚å›å¿†ä¸€ä¸‹ä½¿ç”¨é—­åŒ…çš„åŸå› æ˜¯éœ€è¦åœ¨ä¸€ä¸ªä½ç½®å®šä¹‰ä»£ç ï¼Œå‚¨å­˜ä»£ç ï¼Œå¹¶åœ¨ä¹‹åçš„ä½ç½®å®é™…è°ƒç”¨å®ƒï¼›æœŸæœ›è°ƒç”¨çš„ä»£ç ç°åœ¨å‚¨å­˜åœ¨ expensive_closure ä¸­ã€‚

å®šä¹‰äº†é—­åŒ…ä¹‹åï¼Œå¯ä»¥æ”¹å˜ if å—ä¸­çš„ä»£ç æ¥è°ƒç”¨é—­åŒ…ä»¥æ‰§è¡Œä»£ç å¹¶è·å–ç»“æœå€¼ã€‚è°ƒç”¨é—­åŒ…ç±»ä¼¼äºè°ƒç”¨å‡½æ•°ï¼›æŒ‡å®šå­˜æ”¾é—­åŒ…å®šä¹‰çš„å˜é‡åå¹¶åè·ŸåŒ…å«æœŸæœ›ä½¿ç”¨çš„å‚æ•°çš„æ‹¬å·ï¼Œ

```rust

#![allow(unused_variables)]
fn main() {
use std::thread;
use std::time::Duration;

fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num| {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };

    if intensity < 25 {
        println!(
            "Today, do {} pushups!",
            expensive_closure(intensity)
        );
        println!(
            "Next, do {} situps!",
            expensive_closure(intensity)
        );
    } else {
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!(
                "Today, run for {} minutes!",
                expensive_closure(intensity)
            );
        }
    }
}
}
```

ä»ç„¶åœ¨ç¬¬ä¸€ä¸ª if å—ä¸­è°ƒç”¨äº†é—­åŒ…ä¸¤æ¬¡ï¼Œè¿™è°ƒç”¨äº†æ…¢è®¡ç®—ä»£ç ä¸¤æ¬¡è€Œä½¿å¾—ç”¨æˆ·éœ€è¦å¤šç­‰å¾…ä¸€å€çš„æ—¶é—´ã€‚å¯ä»¥é€šè¿‡åœ¨ if å—ä¸­åˆ›å»ºä¸€ä¸ªæœ¬åœ°å˜é‡å­˜æ”¾é—­åŒ…è°ƒç”¨çš„ç»“æœæ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä¸è¿‡é—­åŒ…å¯ä»¥æä¾›å¦å¤–ä¸€ç§è§£å†³æ–¹æ¡ˆã€‚ç¨åä¼šè®¨è®ºè¿™ä¸ªæ–¹æ¡ˆï¼Œä¸è¿‡ç›®å‰è®©é¦–å…ˆè®¨è®ºä¸€ä¸‹ä¸ºä½•é—­åŒ…å®šä¹‰ä¸­å’Œæ‰€æ¶‰åŠçš„ trait ä¸­æ²¡æœ‰ç±»å‹æ³¨è§£ã€‚

#### é—­åŒ…ç±»å‹æ¨æ–­å’Œæ³¨è§£

é—­åŒ…ä¸è¦æ±‚åƒ fn å‡½æ•°é‚£æ ·åœ¨å‚æ•°å’Œè¿”å›å€¼ä¸Šæ³¨æ˜ç±»å‹ã€‚å‡½æ•°ä¸­éœ€è¦ç±»å‹æ³¨è§£æ˜¯å› ä¸ºä»–ä»¬æ˜¯æš´éœ²ç»™ç”¨æˆ·çš„æ˜¾å¼æ¥å£çš„ä¸€éƒ¨åˆ†ã€‚ä¸¥æ ¼çš„å®šä¹‰è¿™äº›æ¥å£å¯¹äºä¿è¯æ‰€æœ‰äººéƒ½è®¤åŒå‡½æ•°ä½¿ç”¨å’Œè¿”å›å€¼çš„ç±»å‹æ¥è¯´æ˜¯å¾ˆé‡è¦çš„ã€‚ä½†æ˜¯é—­åŒ…å¹¶ä¸ç”¨äºè¿™æ ·æš´éœ²åœ¨å¤–çš„æ¥å£ï¼šä»–ä»¬å‚¨å­˜åœ¨å˜é‡ä¸­å¹¶è¢«ä½¿ç”¨ï¼Œä¸ç”¨å‘½åä»–ä»¬æˆ–æš´éœ²ç»™åº“çš„ç”¨æˆ·è°ƒç”¨ã€‚

é—­åŒ…é€šå¸¸å¾ˆçŸ­å¹¶åªä¸å¯¹åº”ç›¸å¯¹ä»»æ„çš„åœºæ™¯è¾ƒå°çš„ä¸Šä¸‹æ–‡ä¸­ã€‚åœ¨è¿™äº›æœ‰é™åˆ¶çš„ä¸Šä¸‹æ–‡ä¸­ï¼Œç¼–è¯‘å™¨èƒ½å¯é çš„æ¨æ–­å‚æ•°å’Œè¿”å›å€¼çš„ç±»å‹ï¼Œç±»ä¼¼äºå®ƒæ˜¯å¦‚ä½•èƒ½å¤Ÿæ¨æ–­å¤§éƒ¨åˆ†å˜é‡çš„ç±»å‹ä¸€æ ·ã€‚

å¼ºåˆ¶åœ¨è¿™äº›å°çš„åŒ¿åå‡½æ•°ä¸­æ³¨æ˜ç±»å‹æ˜¯å¾ˆæ¼äººçš„ï¼Œå¹¶ä¸”ä¸ç¼–è¯‘å™¨å·²çŸ¥çš„ä¿¡æ¯å­˜åœ¨å¤§é‡çš„é‡å¤ã€‚

ç±»ä¼¼äºå˜é‡ï¼Œå¦‚æœç›¸æ¯”ä¸¥æ ¼çš„å¿…è¦æ€§ä½ æ›´å¸Œæœ›å¢åŠ æ˜ç¡®æ€§å¹¶å˜å¾—æ›´å•°å—¦ï¼Œå¯ä»¥é€‰æ‹©å¢åŠ ç±»å‹æ³¨è§£ï¼›

```rust

#![allow(unused_variables)]
fn main() {
use std::thread;
use std::time::Duration;

let expensive_closure = |num: u32| -> u32 {
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    num
};
}
```

æœ‰äº†ç±»å‹æ³¨è§£é—­åŒ…çš„è¯­æ³•å°±æ›´ç±»ä¼¼å‡½æ•°äº†ã€‚å¦‚ä¸‹æ˜¯ä¸€ä¸ªå¯¹å…¶å‚æ•°åŠ ä¸€çš„å‡½æ•°çš„å®šä¹‰ä¸æ‹¥æœ‰ç›¸åŒè¡Œä¸ºé—­åŒ…è¯­æ³•çš„çºµå‘å¯¹æ¯”ã€‚è¿™é‡Œå¢åŠ äº†ä¸€äº›ç©ºæ ¼æ¥å¯¹é½ç›¸åº”éƒ¨åˆ†ã€‚è¿™å±•ç¤ºäº†é—­åŒ…è¯­æ³•å¦‚ä½•ç±»ä¼¼äºå‡½æ•°è¯­æ³•ï¼Œé™¤äº†ä½¿ç”¨ç«–çº¿è€Œä¸æ˜¯æ‹¬å·ä»¥åŠå‡ ä¸ªå¯é€‰çš„è¯­æ³•ä¹‹å¤–ï¼š

```rust
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;

```

ç¬¬ä¸€è¡Œå±•ç¤ºäº†ä¸€ä¸ªå‡½æ•°å®šä¹‰ï¼Œè€Œç¬¬äºŒè¡Œå±•ç¤ºäº†ä¸€ä¸ªå®Œæ•´æ ‡æ³¨çš„é—­åŒ…å®šä¹‰ã€‚ç¬¬ä¸‰è¡Œé—­åŒ…å®šä¹‰ä¸­çœç•¥äº†ç±»å‹æ³¨è§£ï¼Œè€Œç¬¬å››è¡Œå»æ‰äº†å¯é€‰çš„å¤§æ‹¬å·ï¼Œå› ä¸ºé—­åŒ…ä½“åªæœ‰ä¸€è¡Œã€‚è¿™äº›éƒ½æ˜¯æœ‰æ•ˆçš„é—­åŒ…å®šä¹‰ï¼Œå¹¶åœ¨è°ƒç”¨æ—¶äº§ç”Ÿç›¸åŒçš„è¡Œä¸ºã€‚

é—­åŒ…å®šä¹‰ä¼šä¸ºæ¯ä¸ªå‚æ•°å’Œè¿”å›å€¼æ¨æ–­ä¸€ä¸ªå…·ä½“ç±»å‹ã€‚ä¾‹å¦‚ï¼Œä¸‹ä¾‹ä¸­å±•ç¤ºäº†ä»…ä»…å°†å‚æ•°ä½œä¸ºè¿”å›å€¼çš„ç®€çŸ­çš„é—­åŒ…å®šä¹‰ã€‚é™¤äº†ä½œä¸ºç¤ºä¾‹çš„ç›®çš„è¿™ä¸ªé—­åŒ…å¹¶ä¸æ˜¯å¾ˆå®ç”¨ã€‚æ³¨æ„å…¶å®šä¹‰å¹¶æ²¡æœ‰å¢åŠ ä»»ä½•ç±»å‹æ³¨è§£ï¼šå¦‚æœå°è¯•è°ƒç”¨é—­åŒ…ä¸¤æ¬¡ï¼Œç¬¬ä¸€æ¬¡ä½¿ç”¨ String ç±»å‹ä½œä¸ºå‚æ•°è€Œç¬¬äºŒæ¬¡ä½¿ç”¨ u32ï¼Œåˆ™ä¼šå¾—åˆ°ä¸€ä¸ªé”™è¯¯ï¼š

```rust
let example_closure = |x| x;

let s = example_closure(String::from("hello"));
let n = example_closure(5);

```

#### ä½¿ç”¨å¸¦æœ‰æ³›å‹å’Œ Fn trait çš„é—­åŒ…

ä»ç„¶è°ƒç”¨äº†å¤šäºéœ€è¦çš„æ…¢è®¡ç®—é—­åŒ…ã€‚è§£å†³è¿™ä¸ªé—®é¢˜çš„ä¸€ä¸ªæ–¹æ³•æ˜¯åœ¨å…¨éƒ¨ä»£ç ä¸­çš„æ¯ä¸€ä¸ªéœ€è¦å¤šä¸ªæ…¢è®¡ç®—é—­åŒ…ç»“æœçš„åœ°æ–¹ï¼Œå¯ä»¥å°†ç»“æœä¿å­˜è¿›å˜é‡ä»¥ä¾›å¤ç”¨ï¼Œè¿™æ ·å°±å¯ä»¥ä½¿ç”¨å˜é‡è€Œä¸æ˜¯å†æ¬¡è°ƒç”¨é—­åŒ…ã€‚ä½†æ˜¯è¿™æ ·å°±ä¼šæœ‰å¾ˆå¤šé‡å¤çš„ä¿å­˜ç»“æœå˜é‡çš„åœ°æ–¹ã€‚

å¹¸è¿çš„æ˜¯ï¼Œè¿˜æœ‰å¦ä¸€ä¸ªå¯ç”¨çš„æ–¹æ¡ˆã€‚å¯ä»¥åˆ›å»ºä¸€ä¸ªå­˜æ”¾é—­åŒ…å’Œè°ƒç”¨é—­åŒ…ç»“æœçš„ç»“æ„ä½“ã€‚è¯¥ç»“æ„ä½“åªä¼šåœ¨éœ€è¦ç»“æœæ—¶æ‰§è¡Œé—­åŒ…ï¼Œå¹¶ä¼šç¼“å­˜ç»“æœå€¼ï¼Œè¿™æ ·ä½™ä¸‹çš„ä»£ç å°±ä¸å¿…å†è´Ÿè´£ä¿å­˜ç»“æœå¹¶å¯ä»¥å¤ç”¨è¯¥å€¼ã€‚ä½ å¯èƒ½è§è¿‡è¿™ç§æ¨¡å¼è¢«ç§° memoization æˆ– lazy evaluationã€‚

ä¸ºäº†è®©ç»“æ„ä½“å­˜æ”¾é—­åŒ…ï¼Œéœ€è¦æŒ‡å®šé—­åŒ…çš„ç±»å‹ï¼Œå› ä¸ºç»“æ„ä½“å®šä¹‰éœ€è¦çŸ¥é“å…¶æ¯ä¸€ä¸ªå­—æ®µçš„ç±»å‹ã€‚æ¯ä¸€ä¸ªé—­åŒ…å®ä¾‹æœ‰å…¶è‡ªå·±ç‹¬æœ‰çš„åŒ¿åç±»å‹ï¼šä¹Ÿå°±æ˜¯è¯´ï¼Œå³ä¾¿ä¸¤ä¸ªé—­åŒ…æœ‰ç€ç›¸åŒçš„ç­¾åï¼Œä»–ä»¬çš„ç±»å‹ä»ç„¶å¯ä»¥è¢«è®¤ä¸ºæ˜¯ä¸åŒã€‚ä¸ºäº†å®šä¹‰ä½¿ç”¨é—­åŒ…çš„ç»“æ„ä½“ã€æšä¸¾æˆ–å‡½æ•°å‚æ•°ï¼Œéœ€è¦åƒç¬¬åç« è®¨è®ºçš„é‚£æ ·ä½¿ç”¨æ³›å‹å’Œ trait boundã€‚

Fn ç³»åˆ— trait ç”±æ ‡å‡†åº“æä¾›ã€‚æ‰€æœ‰çš„é—­åŒ…éƒ½å®ç°äº† trait Fnã€FnMut æˆ– FnOnce ä¸­çš„ä¸€ä¸ªã€‚åœ¨ â€œé—­åŒ…ä¼šæ•è·å…¶ç¯å¢ƒâ€ éƒ¨åˆ†ä¼šè®¨è®ºè¿™äº› trait çš„åŒºåˆ«ï¼›åœ¨è¿™ä¸ªä¾‹å­ä¸­å¯ä»¥ä½¿ç”¨ Fn traitã€‚

ä¸ºäº†æ»¡è¶³ Fn trait bound å¢åŠ äº†ä»£è¡¨é—­åŒ…æ‰€å¿…é¡»çš„å‚æ•°å’Œè¿”å›å€¼ç±»å‹çš„ç±»å‹ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œé—­åŒ…æœ‰ä¸€ä¸ª u32 çš„å‚æ•°å¹¶è¿”å›ä¸€ä¸ª u32ï¼Œè¿™æ ·æ‰€æŒ‡å®šçš„ trait bound å°±æ˜¯ Fn(u32) -> u32ã€‚

```rust

#![allow(unused_variables)]
fn main() {
struct Cacher<T>
    where T: Fn(u32) -> u32
{
    calculation: T,
    value: Option<u32>,
}
}
```

ç»“æ„ä½“ Cacher æœ‰ä¸€ä¸ªæ³›å‹ T çš„å­—æ®µ calculationã€‚T çš„ trait bound æŒ‡å®šäº† T æ˜¯ä¸€ä¸ªä½¿ç”¨ Fn çš„é—­åŒ…ã€‚ä»»ä½•å¸Œæœ›å‚¨å­˜åˆ° Cacher å®ä¾‹çš„ calculation å­—æ®µçš„é—­åŒ…å¿…é¡»æœ‰ä¸€ä¸ª u32 å‚æ•°ï¼ˆç”± Fn ä¹‹åçš„æ‹¬å·çš„å†…å®¹æŒ‡å®šï¼‰å¹¶å¿…é¡»è¿”å›ä¸€ä¸ª u32ï¼ˆç”± -> ä¹‹åçš„å†…å®¹ï¼‰ã€‚

å­—æ®µ value æ˜¯ `Option<u32>` ç±»å‹çš„ã€‚åœ¨æ‰§è¡Œé—­åŒ…ä¹‹å‰ï¼Œvalue å°†æ˜¯ Noneã€‚å¦‚æœä½¿ç”¨ Cacher çš„ä»£ç è¯·æ±‚é—­åŒ…çš„ç»“æœï¼Œè¿™æ—¶ä¼šæ‰§è¡Œé—­åŒ…å¹¶å°†ç»“æœå‚¨å­˜åœ¨ value å­—æ®µçš„ Some æˆå‘˜ä¸­ã€‚æ¥ç€å¦‚æœä»£ç å†æ¬¡è¯·æ±‚é—­åŒ…çš„ç»“æœï¼Œè¿™æ—¶ä¸å†æ‰§è¡Œé—­åŒ…ï¼Œè€Œæ˜¯ä¼šè¿”å›å­˜æ”¾åœ¨ Some æˆå‘˜ä¸­çš„ç»“æœã€‚

```rust

#![allow(unused_variables)]
fn main() {
struct Cacher<T>
    where T: Fn(u32) -> u32
{
    calculation: T,
    value: Option<u32>,
}

impl<T> Cacher<T>
    where T: Fn(u32) -> u32
{
    fn new(calculation: T) -> Cacher<T> {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&mut self, arg: u32) -> u32 {
        match self.value {
            Some(v) => v,
            None => {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            },
        }
    }
}
}
```

Cacher ç»“æ„ä½“çš„å­—æ®µæ˜¯ç§æœ‰çš„ï¼Œå› ä¸ºå¸Œæœ› Cacher ç®¡ç†è¿™äº›å€¼è€Œä¸æ˜¯ä»»ç”±è°ƒç”¨ä»£ç æ½œåœ¨çš„ç›´æ¥æ”¹å˜ä»–ä»¬ã€‚

Cacher::new å‡½æ•°è·å–ä¸€ä¸ªæ³›å‹å‚æ•° Tï¼Œå®ƒå®šä¹‰äº impl å—ä¸Šä¸‹æ–‡ä¸­å¹¶ä¸ Cacher ç»“æ„ä½“æœ‰ç€ç›¸åŒçš„ trait boundã€‚Cacher::new è¿”å›ä¸€ä¸ªåœ¨ calculation å­—æ®µä¸­å­˜æ”¾äº†æŒ‡å®šé—­åŒ…å’Œåœ¨ value å­—æ®µä¸­å­˜æ”¾äº† None å€¼çš„ Cacher å®ä¾‹ï¼Œå› ä¸ºè¿˜æœªæ‰§è¡Œé—­åŒ…ã€‚

å½“è°ƒç”¨ä»£ç éœ€è¦é—­åŒ…çš„æ‰§è¡Œç»“æœæ—¶ï¼Œä¸åŒäºç›´æ¥è°ƒç”¨é—­åŒ…ï¼Œå®ƒä¼šè°ƒç”¨ value æ–¹æ³•ã€‚è¿™ä¸ªæ–¹æ³•ä¼šæ£€æŸ¥ self.value æ˜¯å¦å·²ç»æœ‰äº†ä¸€ä¸ª Some çš„ç»“æœå€¼ï¼›å¦‚æœæœ‰ï¼Œå®ƒè¿”å› Some ä¸­çš„å€¼å¹¶ä¸ä¼šå†æ¬¡æ‰§è¡Œé—­åŒ…ã€‚

å¦‚æœ self.value æ˜¯ Noneï¼Œåˆ™ä¼šè°ƒç”¨ self.calculation ä¸­å‚¨å­˜çš„é—­åŒ…ï¼Œå°†ç»“æœä¿å­˜åˆ° self.value ä»¥ä¾¿å°†æ¥ä½¿ç”¨ï¼Œå¹¶åŒæ—¶è¿”å›ç»“æœå€¼ã€‚

```rust

#![allow(unused_variables)]
fn main() {
use std::thread;
use std::time::Duration;

struct Cacher<T>
    where T: Fn(u32) -> u32
{
    calculation: T,
    value: Option<u32>,
}

impl<T> Cacher<T>
    where T: Fn(u32) -> u32
{
    fn new(calculation: T) -> Cacher<T> {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&mut self, arg: u32) -> u32 {
        match self.value {
            Some(v) => v,
            None => {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            },
        }
    }
}

fn generate_workout(intensity: u32, random_number: u32) {
    let mut expensive_result = Cacher::new(|num| {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    });

    if intensity < 25 {
        println!(
            "Today, do {} pushups!",
            expensive_result.value(intensity)
        );
        println!(
            "Next, do {} situps!",
            expensive_result.value(intensity)
        );
    } else {
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!(
                "Today, run for {} minutes!",
                expensive_result.value(intensity)
            );
        }
    }
}
}
```

#### Cacher å®ç°çš„é™åˆ¶

å€¼ç¼“å­˜æ˜¯ä¸€ç§æ›´åŠ å¹¿æ³›çš„å®ç”¨è¡Œä¸ºï¼Œå¯èƒ½å¸Œæœ›åœ¨ä»£ç ä¸­çš„å…¶ä»–é—­åŒ…ä¸­ä¹Ÿä½¿ç”¨ä»–ä»¬ã€‚ç„¶è€Œï¼Œç›®å‰ Cacher çš„å®ç°å­˜åœ¨ä¸¤ä¸ªå°é—®é¢˜ï¼Œè¿™ä½¿å¾—åœ¨ä¸åŒä¸Šä¸‹æ–‡ä¸­å¤ç”¨å˜å¾—å¾ˆå›°éš¾ã€‚

```rust
#[test]
fn call_with_different_values() {
    let mut c = Cacher::new(|a| a);

    let v1 = c.value(1);
    let v2 = c.value(2);

    assert_eq!(v2, 2);
}

```

è¿™ä¸ªæµ‹è¯•ä½¿ç”¨è¿”å›ä¼ é€’ç»™å®ƒçš„å€¼çš„é—­åŒ…åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„ Cacher å®ä¾‹ã€‚ä½¿ç”¨ä¸º 1 çš„ arg å’Œä¸º 2 çš„ arg è°ƒç”¨ Cacher å®ä¾‹çš„ value æ–¹æ³•ï¼ŒåŒæ—¶æœŸæœ›ä½¿ç”¨ä¸º 2 çš„ arg è°ƒç”¨ value ä¼šè¿”å› 2ã€‚

è¿™é‡Œçš„é—®é¢˜æ˜¯ç¬¬ä¸€æ¬¡ä½¿ç”¨ 1 è°ƒç”¨ c.valueï¼ŒCacher å®ä¾‹å°† Some(1) ä¿å­˜è¿› self.valueã€‚åœ¨è¿™ä¹‹åï¼Œæ— è®ºä¼ é€’ä»€ä¹ˆå€¼è°ƒç”¨ valueï¼Œå®ƒæ€»æ˜¯ä¼šè¿”å› 1ã€‚

å°è¯•ä¿®æ”¹ Cacher å­˜æ”¾ä¸€ä¸ªå“ˆå¸Œ map è€Œä¸æ˜¯å•ç‹¬ä¸€ä¸ªå€¼ã€‚å“ˆå¸Œ map çš„ key å°†æ˜¯ä¼ é€’è¿›æ¥çš„ arg å€¼ï¼Œè€Œ value åˆ™æ˜¯å¯¹åº” key è°ƒç”¨é—­åŒ…çš„ç»“æœå€¼ã€‚ç›¸æ¯”ä¹‹å‰æ£€æŸ¥ self.value ç›´æ¥æ˜¯ Some è¿˜æ˜¯ None å€¼ï¼Œç°åœ¨ value å‡½æ•°ä¼šåœ¨å“ˆå¸Œ map ä¸­å¯»æ‰¾ argï¼Œå¦‚æœæ‰¾åˆ°çš„è¯å°±è¿”å›å…¶å¯¹åº”çš„å€¼ã€‚å¦‚æœä¸å­˜åœ¨ï¼ŒCacher ä¼šè°ƒç”¨é—­åŒ…å¹¶å°†ç»“æœå€¼ä¿å­˜åœ¨å“ˆå¸Œ map å¯¹åº” arg å€¼çš„ä½ç½®ã€‚

å½“å‰ Cacher å®ç°çš„ç¬¬äºŒä¸ªé—®é¢˜æ˜¯å®ƒçš„åº”ç”¨è¢«é™åˆ¶ä¸ºåªæ¥å—è·å–ä¸€ä¸ª u32 å€¼å¹¶è¿”å›ä¸€ä¸ª u32 å€¼çš„é—­åŒ…ã€‚æ¯”å¦‚è¯´ï¼Œå¯èƒ½éœ€è¦èƒ½å¤Ÿç¼“å­˜ä¸€ä¸ªè·å–å­—ç¬¦ä¸² slice å¹¶è¿”å› usize å€¼çš„é—­åŒ…çš„ç»“æœã€‚è¯·å°è¯•å¼•å…¥æ›´å¤šæ³›å‹å‚æ•°æ¥å¢åŠ  Cacher åŠŸèƒ½çš„çµæ´»æ€§ã€‚

#### é—­åŒ…ä¼šæ•è·å…¶ç¯å¢ƒ

```rust
fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}

```

```rust
fn main() {
    let x = 4;

    fn equal_to_x(z: i32) -> bool { z == x }

    let y = 4;

    assert!(equal_to_x(y));
}

```

ç¼–è¯‘å™¨ç”šè‡³ä¼šæç¤ºè¿™åªèƒ½ç”¨äºé—­åŒ…ï¼

å½“é—­åŒ…ä»ç¯å¢ƒä¸­æ•è·ä¸€ä¸ªå€¼ï¼Œé—­åŒ…ä¼šåœ¨é—­åŒ…ä½“ä¸­å‚¨å­˜è¿™ä¸ªå€¼ä»¥ä¾›ä½¿ç”¨ã€‚è¿™ä¼šä½¿ç”¨å†…å­˜å¹¶äº§ç”Ÿé¢å¤–çš„å¼€é”€ï¼Œåœ¨æ›´ä¸€èˆ¬çš„åœºæ™¯ä¸­ï¼Œå½“ä¸éœ€è¦é—­åŒ…æ¥æ•è·ç¯å¢ƒæ—¶ï¼Œä¸å¸Œæœ›äº§ç”Ÿè¿™äº›å¼€é”€ã€‚å› ä¸ºå‡½æ•°ä»æœªå…è®¸æ•è·ç¯å¢ƒï¼Œå®šä¹‰å’Œä½¿ç”¨å‡½æ•°ä¹Ÿå°±ä»ä¸ä¼šæœ‰è¿™äº›é¢å¤–å¼€é”€ã€‚

é—­åŒ…å¯ä»¥é€šè¿‡ä¸‰ç§æ–¹å¼æ•è·å…¶ç¯å¢ƒï¼Œä»–ä»¬ç›´æ¥å¯¹åº”å‡½æ•°çš„ä¸‰ç§è·å–å‚æ•°çš„æ–¹å¼ï¼šè·å–æ‰€æœ‰æƒï¼Œå¯å˜å€Ÿç”¨å’Œä¸å¯å˜å€Ÿç”¨ã€‚è¿™ä¸‰ç§æ•è·å€¼çš„æ–¹å¼è¢«ç¼–ç ä¸ºå¦‚ä¸‹ä¸‰ä¸ª Fn traitï¼š

* FnOnce æ¶ˆè´¹ä»å‘¨å›´ä½œç”¨åŸŸæ•è·çš„å˜é‡ï¼Œé—­åŒ…å‘¨å›´çš„ä½œç”¨åŸŸè¢«ç§°ä¸ºå…¶ ç¯å¢ƒï¼Œenvironmentã€‚ä¸ºäº†æ¶ˆè´¹æ•è·åˆ°çš„å˜é‡ï¼Œé—­åŒ…å¿…é¡»è·å–å…¶æ‰€æœ‰æƒå¹¶åœ¨å®šä¹‰é—­åŒ…æ—¶å°†å…¶ç§»åŠ¨è¿›é—­åŒ…ã€‚å…¶åç§°çš„ Once éƒ¨åˆ†ä»£è¡¨äº†é—­åŒ…ä¸èƒ½å¤šæ¬¡è·å–ç›¸åŒå˜é‡çš„æ‰€æœ‰æƒçš„äº‹å®ï¼Œæ‰€ä»¥å®ƒåªèƒ½è¢«è°ƒç”¨ä¸€æ¬¡ã€‚
* FnMut è·å–å¯å˜çš„å€Ÿç”¨å€¼æ‰€ä»¥å¯ä»¥æ”¹å˜å…¶ç¯å¢ƒ
* Fn ä»å…¶ç¯å¢ƒè·å–ä¸å¯å˜çš„å€Ÿç”¨å€¼

å½“åˆ›å»ºä¸€ä¸ªé—­åŒ…æ—¶ï¼ŒRust æ ¹æ®å…¶å¦‚ä½•ä½¿ç”¨ç¯å¢ƒä¸­å˜é‡æ¥æ¨æ–­å¸Œæœ›å¦‚ä½•å¼•ç”¨ç¯å¢ƒã€‚ç”±äºæ‰€æœ‰é—­åŒ…éƒ½å¯ä»¥è¢«è°ƒç”¨è‡³å°‘ä¸€æ¬¡ï¼Œæ‰€ä»¥æ‰€æœ‰é—­åŒ…éƒ½å®ç°äº† FnOnce ã€‚é‚£äº›å¹¶æ²¡æœ‰ç§»åŠ¨è¢«æ•è·å˜é‡çš„æ‰€æœ‰æƒåˆ°é—­åŒ…å†…çš„é—­åŒ…ä¹Ÿå®ç°äº† FnMut ï¼Œè€Œä¸éœ€è¦å¯¹è¢«æ•è·çš„å˜é‡è¿›è¡Œå¯å˜è®¿é—®çš„é—­åŒ…åˆ™ä¹Ÿå®ç°äº† Fn ã€‚

```rust
fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    println!("can't use x here: {:?}", x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}

```

è¿™ä¸ªä¾‹å­å¹¶ä¸èƒ½ç¼–è¯‘ï¼Œä¼šäº§ç”Ÿä»¥ä¸‹é”™è¯¯ï¼š

```rust
error[E0382]: use of moved value: `x`
 --> src/main.rs:6:40
  |
4 |     let equal_to_x = move |z| z == x;
  |                      -------- value moved (into closure) here
5 |
6 |     println!("can't use x here: {:?}", x);
  |                                        ^ value used here after move
  |
  = note: move occurs because `x` has type `std::vec::Vec<i32>`, which does not
  implement the `Copy` trait

```

x è¢«ç§»åŠ¨è¿›äº†é—­åŒ…ï¼Œå› ä¸ºé—­åŒ…ä½¿ç”¨ move å…³é”®å­—å®šä¹‰ã€‚æ¥ç€é—­åŒ…è·å–äº† x çš„æ‰€æœ‰æƒï¼ŒåŒæ—¶ main å°±ä¸å†å…è®¸åœ¨ println! è¯­å¥ä¸­ä½¿ç”¨ x äº†ã€‚å»æ‰ println! å³å¯ä¿®å¤é—®é¢˜ã€‚

å¤§éƒ¨åˆ†éœ€è¦æŒ‡å®šä¸€ä¸ª Fn ç³»åˆ— trait bound çš„æ—¶å€™ï¼Œå¯ä»¥ä» Fn å¼€å§‹ï¼Œè€Œç¼–è¯‘å™¨ä¼šæ ¹æ®é—­åŒ…ä½“ä¸­çš„æƒ…å†µå‘Šè¯‰ä½ æ˜¯å¦éœ€è¦ FnMut æˆ– FnOnceã€‚

ä¸ºäº†å±•ç¤ºé—­åŒ…ä½œä¸ºå‡½æ•°å‚æ•°æ—¶æ•è·å…¶ç¯å¢ƒçš„ä½œç”¨ï¼Œè®©ç»§ç»­ä¸‹ä¸€ä¸ªä¸»é¢˜ï¼šè¿­ä»£å™¨ã€‚

#### ä½¿ç”¨è¿­ä»£å™¨å¤„ç†å…ƒç´ åºåˆ—

è¿­ä»£å™¨æ¨¡å¼å…è®¸ä½ å¯¹ä¸€ä¸ªé¡¹çš„åºåˆ—è¿›è¡ŒæŸäº›å¤„ç†ã€‚è¿­ä»£å™¨ï¼ˆiteratorï¼‰è´Ÿè´£éå†åºåˆ—ä¸­çš„æ¯ä¸€é¡¹å’Œå†³å®šåºåˆ—ä½•æ—¶ç»“æŸçš„é€»è¾‘ã€‚å½“ä½¿ç”¨è¿­ä»£å™¨æ—¶ï¼Œæ— éœ€é‡æ–°å®ç°è¿™äº›é€»è¾‘ã€‚

åœ¨ Rust ä¸­ï¼Œè¿­ä»£å™¨æ˜¯ æƒ°æ€§çš„ï¼ˆlazyï¼‰ï¼Œè¿™æ„å‘³ç€åœ¨è°ƒç”¨æ–¹æ³•ä½¿ç”¨è¿­ä»£å™¨ä¹‹å‰å®ƒéƒ½ä¸ä¼šæœ‰æ•ˆæœã€‚

```rust

#![allow(unused_variables)]
fn main() {
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
}
```

```rust

#![allow(unused_variables)]
fn main() {
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!("Got: {}", val);
}
}
```

åœ¨æ ‡å‡†åº“ä¸­æ²¡æœ‰æä¾›è¿­ä»£å™¨çš„è¯­è¨€ä¸­ï¼Œå¯èƒ½ä¼šä½¿ç”¨ä¸€ä¸ªä» 0 å¼€å§‹çš„ç´¢å¼•å˜é‡ï¼Œä½¿ç”¨è¿™ä¸ªå˜é‡ç´¢å¼• vector ä¸­çš„å€¼ï¼Œå¹¶å¾ªç¯å¢åŠ å…¶å€¼ç›´åˆ°è¾¾åˆ° vector çš„å…ƒç´ æ•°é‡ã€‚

è¿­ä»£å™¨ä¸ºå¤„ç†äº†æ‰€æœ‰è¿™äº›é€»è¾‘ï¼Œè¿™å‡å°‘äº†é‡å¤ä»£ç å¹¶æ¶ˆé™¤äº†æ½œåœ¨çš„æ··ä¹±ã€‚å¦å¤–ï¼Œè¿­ä»£å™¨çš„å®ç°æ–¹å¼æä¾›äº†å¯¹å¤šç§ä¸åŒçš„åºåˆ—ä½¿ç”¨ç›¸åŒé€»è¾‘çš„çµæ´»æ€§ï¼Œè€Œä¸ä»…ä»…æ˜¯åƒ vector è¿™æ ·å¯ç´¢å¼•çš„æ•°æ®ç»“æ„.è®©çœ‹çœ‹è¿­ä»£å™¨æ˜¯å¦‚ä½•åšåˆ°è¿™äº›çš„ã€‚

#### Iterator trait å’Œ next æ–¹æ³•

è¿­ä»£å™¨éƒ½å®ç°äº†ä¸€ä¸ªå«åš Iterator çš„å®šä¹‰äºæ ‡å‡†åº“çš„ traitã€‚è¿™ä¸ª trait çš„å®šä¹‰çœ‹èµ·æ¥åƒè¿™æ ·ï¼š

```rust

#![allow(unused_variables)]
fn main() {
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // æ­¤å¤„çœç•¥äº†æ–¹æ³•çš„é»˜è®¤å®ç°
}
}
```

æ³¨æ„è¿™é‡Œæœ‰ä¸€ä¸‹è¿˜æœªè®²åˆ°çš„æ–°è¯­æ³•ï¼štype Item å’Œ Self::Itemï¼Œä»–ä»¬å®šä¹‰äº† trait çš„ å…³è”ç±»å‹ï¼ˆassociated typeï¼‰ã€‚ç¬¬åä¹ç« ä¼šæ·±å…¥è®²è§£å…³è”ç±»å‹ï¼Œä¸è¿‡ç°åœ¨åªéœ€çŸ¥é“è¿™æ®µä»£ç è¡¨æ˜å®ç° Iterator trait è¦æ±‚åŒæ—¶å®šä¹‰ä¸€ä¸ª Item ç±»å‹ï¼Œè¿™ä¸ª Item ç±»å‹è¢«ç”¨ä½œ next æ–¹æ³•çš„è¿”å›å€¼ç±»å‹ã€‚æ¢å¥è¯è¯´ï¼ŒItem ç±»å‹å°†æ˜¯è¿­ä»£å™¨è¿”å›å…ƒç´ çš„ç±»å‹ã€‚

next æ˜¯ Iterator å®ç°è€…è¢«è¦æ±‚å®šä¹‰çš„å”¯ä¸€æ–¹æ³•ã€‚next ä¸€æ¬¡è¿”å›è¿­ä»£å™¨ä¸­çš„ä¸€ä¸ªé¡¹ï¼Œå°è£…åœ¨ Some ä¸­ï¼Œå½“è¿­ä»£å™¨ç»“æŸæ—¶ï¼Œå®ƒè¿”å› Noneã€‚

å¯ä»¥ç›´æ¥è°ƒç”¨è¿­ä»£å™¨çš„ next æ–¹æ³•ï¼›ä¸‹ä¾‹  æœ‰ä¸€ä¸ªæµ‹è¯•å±•ç¤ºäº†é‡å¤è°ƒç”¨ç”± vector åˆ›å»ºçš„è¿­ä»£å™¨çš„ next æ–¹æ³•æ‰€å¾—åˆ°çš„å€¼ï¼š

```rust

#![allow(unused_variables)]
fn main() {
#[test]
fn iterator_demonstration() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();

    assert_eq!(v1_iter.next(), Some(&1));
    assert_eq!(v1_iter.next(), Some(&2));
    assert_eq!(v1_iter.next(), Some(&3));
    assert_eq!(v1_iter.next(), None);
}
}
```

æ³¨æ„ v1_iter éœ€è¦æ˜¯å¯å˜çš„ï¼šåœ¨è¿­ä»£å™¨ä¸Šè°ƒç”¨ next æ–¹æ³•æ”¹å˜äº†è¿­ä»£å™¨ä¸­ç”¨æ¥è®°å½•åºåˆ—ä½ç½®çš„çŠ¶æ€ã€‚æ¢å¥è¯è¯´ï¼Œä»£ç  æ¶ˆè´¹ï¼ˆconsumeï¼‰äº†ï¼Œæˆ–ä½¿ç”¨äº†è¿­ä»£å™¨ã€‚æ¯ä¸€ä¸ª next è°ƒç”¨éƒ½ä¼šä»è¿­ä»£å™¨ä¸­æ¶ˆè´¹ä¸€ä¸ªé¡¹ã€‚ä½¿ç”¨ for å¾ªç¯æ—¶æ— éœ€ä½¿ v1_iter å¯å˜å› ä¸º for å¾ªç¯ä¼šè·å– v1_iter çš„æ‰€æœ‰æƒå¹¶åœ¨åå°ä½¿ v1_iter å¯å˜ã€‚

å¦å¤–éœ€è¦æ³¨æ„åˆ°ä» next è°ƒç”¨ä¸­å¾—åˆ°çš„å€¼æ˜¯ vector çš„ä¸å¯å˜å¼•ç”¨ã€‚iter æ–¹æ³•ç”Ÿæˆä¸€ä¸ªä¸å¯å˜å¼•ç”¨çš„è¿­ä»£å™¨ã€‚å¦‚æœéœ€è¦ä¸€ä¸ªè·å– v1 æ‰€æœ‰æƒå¹¶è¿”å›æ‹¥æœ‰æ‰€æœ‰æƒçš„è¿­ä»£å™¨ï¼Œåˆ™å¯ä»¥è°ƒç”¨ into_iter è€Œä¸æ˜¯ iterã€‚ç±»ä¼¼çš„ï¼Œå¦‚æœå¸Œæœ›è¿­ä»£å¯å˜å¼•ç”¨ï¼Œåˆ™å¯ä»¥è°ƒç”¨ iter_mut è€Œä¸æ˜¯ iterã€‚

#### æ¶ˆè´¹è¿­ä»£å™¨çš„æ–¹æ³•

Iterator trait æœ‰ä¸€ç³»åˆ—ä¸åŒçš„ç”±æ ‡å‡†åº“æä¾›é»˜è®¤å®ç°çš„æ–¹æ³•ï¼›ä½ å¯ä»¥åœ¨ Iterator trait çš„æ ‡å‡†åº“ API æ–‡æ¡£ä¸­æ‰¾åˆ°æ‰€æœ‰è¿™äº›æ–¹æ³•ã€‚ä¸€äº›æ–¹æ³•åœ¨å…¶å®šä¹‰ä¸­è°ƒç”¨äº† next æ–¹æ³•ï¼Œè¿™ä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆåœ¨å®ç° Iterator trait æ—¶è¦æ±‚å®ç° next æ–¹æ³•çš„åŸå› ã€‚

è¿™äº›è°ƒç”¨ next æ–¹æ³•çš„æ–¹æ³•è¢«ç§°ä¸º æ¶ˆè´¹é€‚é…å™¨ï¼ˆconsuming adaptorsï¼‰ï¼Œå› ä¸ºè°ƒç”¨ä»–ä»¬ä¼šæ¶ˆè€—è¿­ä»£å™¨ã€‚ä¸€ä¸ªæ¶ˆè´¹é€‚é…å™¨çš„ä¾‹å­æ˜¯ sum æ–¹æ³•ã€‚è¿™ä¸ªæ–¹æ³•è·å–è¿­ä»£å™¨çš„æ‰€æœ‰æƒå¹¶åå¤è°ƒç”¨ next æ¥éå†è¿­ä»£å™¨ï¼Œå› è€Œä¼šæ¶ˆè´¹è¿­ä»£å™¨ã€‚å½“å…¶éå†æ¯ä¸€ä¸ªé¡¹æ—¶ï¼Œå®ƒå°†æ¯ä¸€ä¸ªé¡¹åŠ æ€»åˆ°ä¸€ä¸ªæ€»å’Œå¹¶åœ¨è¿­ä»£å®Œæˆæ—¶è¿”å›æ€»å’Œã€‚

```rust

#![allow(unused_variables)]
fn main() {
#[test]
fn iterator_sum() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);
}
}
```

è°ƒç”¨ sum ä¹‹åä¸å†å…è®¸ä½¿ç”¨ v1_iter å› ä¸ºè°ƒç”¨ sum æ—¶å®ƒä¼šè·å–è¿­ä»£å™¨çš„æ‰€æœ‰æƒã€‚

#### äº§ç”Ÿå…¶ä»–è¿­ä»£å™¨çš„æ–¹æ³•

Iterator trait ä¸­å®šä¹‰äº†å¦ä¸€ç±»æ–¹æ³•ï¼Œè¢«ç§°ä¸º è¿­ä»£å™¨é€‚é…å™¨ï¼ˆiterator adaptorsï¼‰ï¼Œä»–ä»¬å…è®¸å°†å½“å‰è¿­ä»£å™¨å˜ä¸ºä¸åŒç±»å‹çš„è¿­ä»£å™¨ã€‚å¯ä»¥é“¾å¼è°ƒç”¨å¤šä¸ªè¿­ä»£å™¨é€‚é…å™¨ã€‚ä¸è¿‡å› ä¸ºæ‰€æœ‰çš„è¿­ä»£å™¨éƒ½æ˜¯æƒ°æ€§çš„ï¼Œå¿…é¡»è°ƒç”¨ä¸€ä¸ªæ¶ˆè´¹é€‚é…å™¨æ–¹æ³•ä»¥ä¾¿è·å–è¿­ä»£å™¨é€‚é…å™¨è°ƒç”¨çš„ç»“æœã€‚

ä¸‹ä¾‹ å±•ç¤ºäº†ä¸€ä¸ªè°ƒç”¨è¿­ä»£å™¨é€‚é…å™¨æ–¹æ³• map çš„ä¾‹å­ï¼Œè¯¥ map æ–¹æ³•ä½¿ç”¨é—­åŒ…æ¥è°ƒç”¨æ¯ä¸ªå…ƒç´ ä»¥ç”Ÿæˆæ–°çš„è¿­ä»£å™¨ã€‚ è¿™é‡Œçš„é—­åŒ…åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„è¿­ä»£å™¨ï¼Œå¯¹å…¶ä¸­ vector ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½è¢«åŠ  1ã€‚ä¸è¿‡è¿™äº›ä»£ç ä¼šäº§ç”Ÿä¸€ä¸ªè­¦å‘Šï¼š

```rust

#![allow(unused_variables)]
fn main() {
let v1: Vec<i32> = vec![1, 2, 3];

v1.iter().map(|x| x + 1);
}
```

å¾—åˆ°çš„è­¦å‘Šæ˜¯ï¼š

```rust
warning: unused `std::iter::Map` which must be used: iterator adaptors are lazy
and do nothing unless consumed
 --> src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: #[warn(unused_must_use)] on by default

```

åœ¨ ä¸‹ä¾‹ ä¸­ï¼Œå°†éå†ç”± map è°ƒç”¨ç”Ÿæˆçš„è¿­ä»£å™¨çš„ç»“æœæ”¶é›†åˆ°ä¸€ä¸ª vector ä¸­ï¼Œå®ƒå°†ä¼šå«æœ‰åŸå§‹ vector ä¸­æ¯ä¸ªå…ƒç´ åŠ  1 çš„ç»“æœï¼š

```rust

#![allow(unused_variables)]
fn main() {
let v1: Vec<i32> = vec![1, 2, 3];

let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
}
```

å› ä¸º map è·å–ä¸€ä¸ªé—­åŒ…ï¼Œå¯ä»¥æŒ‡å®šä»»ä½•å¸Œæœ›åœ¨éå†çš„æ¯ä¸ªå…ƒç´ ä¸Šæ‰§è¡Œçš„æ“ä½œã€‚è¿™æ˜¯ä¸€ä¸ªå±•ç¤ºå¦‚ä½•ä½¿ç”¨é—­åŒ…æ¥è‡ªå®šä¹‰è¡Œä¸ºåŒæ—¶åˆå¤ç”¨ Iterator trait æä¾›çš„è¿­ä»£è¡Œä¸ºçš„ç»ä½³ä¾‹å­ã€‚

#### ä½¿ç”¨é—­åŒ…è·å–ç¯å¢ƒ

ç°åœ¨ä»‹ç»äº†è¿­ä»£å™¨ï¼Œè®©å±•ç¤ºä¸€ä¸ªé€šè¿‡ä½¿ç”¨ filter è¿­ä»£å™¨é€‚é…å™¨å’Œæ•è·ç¯å¢ƒçš„é—­åŒ…çš„å¸¸è§„ç”¨ä¾‹ã€‚è¿­ä»£å™¨çš„ filter æ–¹æ³•è·å–ä¸€ä¸ªä½¿ç”¨è¿­ä»£å™¨çš„æ¯ä¸€ä¸ªé¡¹å¹¶è¿”å›å¸ƒå°”å€¼çš„é—­åŒ…ã€‚å¦‚æœé—­åŒ…è¿”å› trueï¼Œå…¶å€¼å°†ä¼šåŒ…å«åœ¨ filter æä¾›çš„æ–°è¿­ä»£å™¨ä¸­ã€‚å¦‚æœé—­åŒ…è¿”å› falseï¼Œå…¶å€¼ä¸ä¼šåŒ…å«åœ¨ç»“æœè¿­ä»£å™¨ä¸­ã€‚

```rust

#![allow(unused_variables)]
fn main() {
#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_my_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    shoes.into_iter()
        .filter(|s| s.size == shoe_size)
        .collect()
}

#[test]
fn filters_by_size() {
    let shoes = vec![
        Shoe { size: 10, style: String::from("sneaker") },
        Shoe { size: 13, style: String::from("sandal") },
        Shoe { size: 10, style: String::from("boot") },
    ];

    let in_my_size = shoes_in_my_size(shoes, 10);

    assert_eq!(
        in_my_size,
        vec![
            Shoe { size: 10, style: String::from("sneaker") },
            Shoe { size: 10, style: String::from("boot") },
        ]
    );
}
}
```

shoes_in_my_size å‡½æ•°è·å–ä¸€ä¸ªé‹å­ vector çš„æ‰€æœ‰æƒå’Œä¸€ä¸ªé‹å­å¤§å°ä½œä¸ºå‚æ•°ã€‚å®ƒè¿”å›ä¸€ä¸ªåªåŒ…å«æŒ‡å®šå¤§å°é‹å­çš„ vectorã€‚

shoes_in_my_size å‡½æ•°ä½“ä¸­è°ƒç”¨äº† into_iter æ¥åˆ›å»ºä¸€ä¸ªè·å– vector æ‰€æœ‰æƒçš„è¿­ä»£å™¨ã€‚æ¥ç€è°ƒç”¨ filter å°†è¿™ä¸ªè¿­ä»£å™¨é€‚é…æˆä¸€ä¸ªåªå«æœ‰é‚£äº›é—­åŒ…è¿”å› true çš„å…ƒç´ çš„æ–°è¿­ä»£å™¨ã€‚

é—­åŒ…ä»ç¯å¢ƒä¸­æ•è·äº† shoe_size å˜é‡å¹¶ä½¿ç”¨å…¶å€¼ä¸æ¯ä¸€åªé‹çš„å¤§å°ä½œæ¯”è¾ƒï¼Œåªä¿ç•™æŒ‡å®šå¤§å°çš„é‹å­ã€‚æœ€ç»ˆï¼Œè°ƒç”¨ collect å°†è¿­ä»£å™¨é€‚é…å™¨è¿”å›çš„å€¼æ”¶é›†è¿›ä¸€ä¸ª vector å¹¶è¿”å›ã€‚

#### å®ç° Iterator trait æ¥åˆ›å»ºè‡ªå®šä¹‰è¿­ä»£å™¨

å·²ç»å±•ç¤ºäº†å¯ä»¥é€šè¿‡åœ¨ vector ä¸Šè°ƒç”¨ iterã€into_iter æˆ– iter_mut æ¥åˆ›å»ºä¸€ä¸ªè¿­ä»£å™¨ã€‚ä¹Ÿå¯ä»¥ç”¨æ ‡å‡†åº“ä¸­å…¶ä»–çš„é›†åˆç±»å‹åˆ›å»ºè¿­ä»£å™¨ï¼Œæ¯”å¦‚å“ˆå¸Œ mapã€‚å¦å¤–ï¼Œå¯ä»¥å®ç° Iterator trait æ¥åˆ›å»ºä»»ä½•å¸Œæœ›çš„è¿­ä»£å™¨ã€‚æ­£å¦‚ä¹‹å‰æåˆ°çš„ï¼Œå®šä¹‰ä¸­å”¯ä¸€è¦æ±‚æä¾›çš„æ–¹æ³•å°±æ˜¯ next æ–¹æ³•ã€‚ä¸€æ—¦å®šä¹‰äº†å®ƒï¼Œå°±å¯ä»¥ä½¿ç”¨æ‰€æœ‰å…¶ä»–ç”± Iterator trait æä¾›çš„æ‹¥æœ‰é»˜è®¤å®ç°çš„æ–¹æ³•æ¥åˆ›å»ºè‡ªå®šä¹‰è¿­ä»£å™¨äº†ï¼

ä½œä¸ºå±•ç¤ºï¼Œè®©åˆ›å»ºä¸€ä¸ªåªä¼šä» 1 æ•°åˆ° 5 çš„è¿­ä»£å™¨ã€‚é¦–å…ˆï¼Œåˆ›å»ºä¸€ä¸ªç»“æ„ä½“æ¥å­˜æ”¾ä¸€äº›å€¼ï¼Œæ¥ç€å®ç° Iterator trait å°†è¿™ä¸ªç»“æ„ä½“æ”¾å…¥è¿­ä»£å™¨ä¸­å¹¶åœ¨æ­¤å®ç°ä¸­ä½¿ç”¨å…¶å€¼ã€‚

```rust

#![allow(unused_variables)]
fn main() {
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -> Counter {
        Counter { count: 0 }
    }
}
}
```

Counter ç»“æ„ä½“æœ‰ä¸€ä¸ªå­—æ®µ countã€‚è¿™ä¸ªå­—æ®µå­˜æ”¾ä¸€ä¸ª u32 å€¼ï¼Œå®ƒä¼šè®°å½•å¤„ç† 1 åˆ° 5 çš„è¿­ä»£è¿‡ç¨‹ä¸­çš„ä½ç½®ã€‚count æ˜¯ç§æœ‰çš„å› ä¸ºå¸Œæœ› Counter çš„å®ç°æ¥ç®¡ç†è¿™ä¸ªå€¼ã€‚new å‡½æ•°é€šè¿‡æ€»æ˜¯ä»ä¸º 0 çš„ count å­—æ®µå¼€å§‹æ–°å®ä¾‹æ¥ç¡®ä¿éœ€è¦çš„è¡Œä¸ºã€‚

æ¥ä¸‹æ¥å°†ä¸º Counter ç±»å‹å®ç° Iterator traitï¼Œé€šè¿‡å®šä¹‰ next æ–¹æ³•æ¥æŒ‡å®šä½¿ç”¨è¿­ä»£å™¨æ—¶çš„è¡Œä¸ºï¼Œå¦‚ ä¸‹ä¾‹ æ‰€ç¤ºï¼š

```rust

#![allow(unused_variables)]
fn main() {
struct Counter {
    count: u32,
}

impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        self.count += 1;

        if self.count < 6 {
            Some(self.count)
        } else {
            None
        }
    }
}
}
```

è¿™é‡Œå°†è¿­ä»£å™¨çš„å…³è”ç±»å‹ Item è®¾ç½®ä¸º u32ï¼Œæ„å‘³ç€è¿­ä»£å™¨ä¼šè¿”å› u32 å€¼é›†åˆã€‚å†ä¸€æ¬¡ï¼Œè¿™é‡Œä»æ— éœ€æ‹…å¿ƒå…³è”ç±»å‹ï¼Œç¬¬åä¹ç« ä¼šè®²åˆ°ã€‚

å¸Œæœ›è¿­ä»£å™¨å¯¹å…¶å†…éƒ¨çŠ¶æ€åŠ ä¸€ï¼Œè¿™ä¹Ÿå°±æ˜¯ä¸ºä½•å°† count åˆå§‹åŒ–ä¸º 0ï¼šå¸Œæœ›è¿­ä»£å™¨é¦–å…ˆè¿”å› 1ã€‚å¦‚æœ count å€¼å°äº 6ï¼Œnext ä¼šè¿”å›å°è£…åœ¨ Some ä¸­çš„å½“å‰å€¼ï¼Œä¸è¿‡å¦‚æœ count å¤§äºæˆ–ç­‰äº 6ï¼Œè¿­ä»£å™¨ä¼šè¿”å› Noneã€‚

#### ä½¿ç”¨ Counter è¿­ä»£å™¨çš„ next æ–¹æ³•

ä¸€æ—¦å®ç°äº† Iterator traitï¼Œå°±æœ‰äº†ä¸€ä¸ªè¿­ä»£å™¨ï¼ä¸‹ä¾‹ å±•ç¤ºäº†ä¸€ä¸ªæµ‹è¯•ç”¨æ¥æ¼”ç¤ºä½¿ç”¨ Counter ç»“æ„ä½“çš„è¿­ä»£å™¨åŠŸèƒ½ï¼Œé€šè¿‡ç›´æ¥è°ƒç”¨ next æ–¹æ³•ï¼Œ

```rust

#![allow(unused_variables)]
fn main() {
struct Counter {
    count: u32,
}

impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        self.count += 1;

        if self.count < 6 {
            Some(self.count)
        } else {
            None
        }
    }
}

#[test]
fn calling_next_directly() {
    let mut counter = Counter::new();

    assert_eq!(counter.next(), Some(1));
    assert_eq!(counter.next(), Some(2));
    assert_eq!(counter.next(), Some(3));
    assert_eq!(counter.next(), Some(4));
    assert_eq!(counter.next(), Some(5));
    assert_eq!(counter.next(), None);
}
}
```

è¿™ä¸ªæµ‹è¯•åœ¨ counter å˜é‡ä¸­æ–°å»ºäº†ä¸€ä¸ª Counter å®ä¾‹å¹¶æ¥ç€åå¤è°ƒç”¨ next æ–¹æ³•ï¼Œæ¥éªŒè¯å®ç°çš„è¡Œä¸ºç¬¦åˆè¿™ä¸ªè¿­ä»£å™¨è¿”å›ä» 1 åˆ° 5 çš„å€¼çš„é¢„æœŸã€‚

#### ä½¿ç”¨è‡ªå®šä¹‰è¿­ä»£å™¨ä¸­å…¶ä»– Iterator trait æ–¹æ³•

é€šè¿‡å®šä¹‰ next æ–¹æ³•å®ç° Iterator traitï¼Œç°åœ¨å°±å¯ä»¥ä½¿ç”¨ä»»ä½•æ ‡å‡†åº“å®šä¹‰çš„æ‹¥æœ‰é»˜è®¤å®ç°çš„ Iterator trait æ–¹æ³•äº†ï¼Œå› ä¸ºä»–ä»¬éƒ½ä½¿ç”¨äº† next æ–¹æ³•çš„åŠŸèƒ½ã€‚

```rust

#![allow(unused_variables)]
fn main() {
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -> Counter {
        Counter { count: 0 }
    }
}

impl Iterator for Counter {
    // è¿­ä»£å™¨ä¼šäº§ç”Ÿ u32s
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        // count è‡ªå¢ 1ã€‚ä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆä» 0 å¼€å§‹ã€‚
        self.count += 1;

        // æ£€æµ‹æ˜¯å¦ç»“æŸç»“æŸè®¡æ•°ã€‚
        if self.count < 6 {
            Some(self.count)
        } else {
            None
        }
    }
}

#[test]
fn using_other_iterator_trait_methods() {
    let sum: u32 = Counter::new().zip(Counter::new().skip(1))
                                 .map(|(a, b)| a * b)
                                 .filter(|x| x % 3 == 0)
                                 .sum();
    assert_eq!(18, sum);
}
}
```

æ³¨æ„ zip åªäº§ç”Ÿå››å¯¹å€¼ï¼›ç†è®ºä¸Šç¬¬äº”å¯¹å€¼ (5, None) ä»æœªè¢«äº§ç”Ÿï¼Œå› ä¸º zip åœ¨ä»»ä¸€è¾“å…¥è¿­ä»£å™¨è¿”å› None æ—¶ä¹Ÿè¿”å› Noneã€‚

æ‰€æœ‰è¿™äº›æ–¹æ³•è°ƒç”¨éƒ½æ˜¯å¯èƒ½çš„ï¼Œå› ä¸ºæŒ‡å®šäº† next æ–¹æ³•å¦‚ä½•å·¥ä½œï¼Œè€Œæ ‡å‡†åº“åˆ™æä¾›äº†å…¶å®ƒè°ƒç”¨ next çš„æ–¹æ³•çš„é»˜è®¤å®ç°ã€‚

#### æ”¹è¿› I/O é¡¹ç›®

å¢åŠ äº†ä¸€äº›ä»£ç è·å–ä¸€ä¸ª String slice å¹¶åˆ›å»ºä¸€ä¸ª Config ç»“æ„ä½“çš„å®ä¾‹ï¼Œä»–ä»¬ç´¢å¼• slice ä¸­çš„å€¼å¹¶å…‹éš†è¿™äº›å€¼ä»¥ä¾¿ Config ç»“æ„ä½“å¯ä»¥æ‹¥æœ‰è¿™äº›å€¼ã€‚

```rust
impl Config {
    pub fn new(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var("CASE_INSENSITIVE").is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}

```

èµ·åˆè¿™é‡Œéœ€è¦ clone çš„åŸå› æ˜¯å‚æ•° args ä¸­æœ‰ä¸€ä¸ª String å…ƒç´ çš„ sliceï¼Œè€Œ new å‡½æ•°å¹¶ä¸æ‹¥æœ‰ argsã€‚ä¸ºäº†èƒ½å¤Ÿè¿”å› Config å®ä¾‹çš„æ‰€æœ‰æƒï¼Œéœ€è¦å…‹éš† Config ä¸­å­—æ®µ query å’Œ filename çš„å€¼ï¼Œè¿™æ · Config å®ä¾‹å°±èƒ½æ‹¥æœ‰è¿™äº›å€¼ã€‚

åœ¨å­¦ä¹ äº†è¿­ä»£å™¨ä¹‹åï¼Œå¯ä»¥å°† new å‡½æ•°æ”¹ä¸ºè·å–ä¸€ä¸ªæœ‰æ‰€æœ‰æƒçš„è¿­ä»£å™¨ä½œä¸ºå‚æ•°è€Œä¸æ˜¯å€Ÿç”¨ sliceã€‚å°†ä½¿ç”¨è¿­ä»£å™¨åŠŸèƒ½ä¹‹å‰æ£€æŸ¥ slice é•¿åº¦å’Œç´¢å¼•ç‰¹å®šä½ç½®çš„ä»£ç ã€‚è¿™ä¼šæ˜ç¡® Config::new çš„å·¥ä½œå› ä¸ºè¿­ä»£å™¨ä¼šè´Ÿè´£è®¿é—®è¿™äº›å€¼ã€‚

ä¸€æ—¦ Config::new è·å–äº†è¿­ä»£å™¨çš„æ‰€æœ‰æƒå¹¶ä¸å†ä½¿ç”¨å€Ÿç”¨çš„ç´¢å¼•æ“ä½œï¼Œå°±å¯ä»¥å°†è¿­ä»£å™¨ä¸­çš„ String å€¼ç§»åŠ¨åˆ° Config ä¸­ï¼Œè€Œä¸æ˜¯è°ƒç”¨ clone åˆ†é…æ–°çš„ç©ºé—´ã€‚

#### ç›´æ¥ä½¿ç”¨ env::args è¿”å›çš„è¿­ä»£å™¨

```rust
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {}", err);
        process::exit(1);
    });

    // --snip--
}

```

```rust
fn main() {
    let config = Config::new(env::args()).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {}", err);
        process::exit(1);
    });

    // --snip--
}

```

env::args å‡½æ•°è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ä¸åŒäºå°†è¿­ä»£å™¨çš„å€¼æ”¶é›†åˆ°ä¸€ä¸ª vector ä¸­æ¥ç€ä¼ é€’ä¸€ä¸ª slice ç»™ Config::newï¼Œç°åœ¨ç›´æ¥å°† env::args è¿”å›çš„è¿­ä»£å™¨çš„æ‰€æœ‰æƒä¼ é€’ç»™ Config::newã€‚

æ¥ä¸‹æ¥éœ€è¦æ›´æ–° Config::new çš„å®šä¹‰ã€‚åœ¨ I/O é¡¹ç›®çš„ src/lib.rs ä¸­ï¼Œå°† Config::new çš„ç­¾åæ”¹ä¸ºå¦‚ ä¸‹ä¾‹ æ‰€ç¤ºã€‚è¿™ä»ç„¶ä¸èƒ½ç¼–è¯‘å› ä¸ºè¿˜éœ€æ›´æ–°å‡½æ•°ä½“ï¼š

```rust
fn main() {}
use std::env;

struct Config {
    query: String,
    filename: String,
    case_sensitive: bool,
}

impl Config {
    pub fn new(mut args: std::env::Args) -> Result<Config, &'static str> {
        args.next();

        let query = match args.next() {
            Some(arg) => arg,
            None => return Err("Didn't get a query string"),
        };

        let filename = match args.next() {
            Some(arg) => arg,
            None => return Err("Didn't get a file name"),
        };

        let case_sensitive = env::var("CASE_INSENSITIVE").is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}

```

è¯·è®°ä½ env::args è¿”å›å€¼çš„ç¬¬ä¸€ä¸ªå€¼æ˜¯ç¨‹åºçš„åç§°ã€‚å¸Œæœ›å¿½ç•¥å®ƒå¹¶è·å–ä¸‹ä¸€ä¸ªå€¼ï¼Œæ‰€ä»¥é¦–å…ˆè°ƒç”¨ next å¹¶ä¸å¯¹è¿”å›å€¼åšä»»ä½•æ“ä½œã€‚ä¹‹åå¯¹å¸Œæœ›æ”¾å…¥ Config ä¸­å­—æ®µ query è°ƒç”¨ nextã€‚å¦‚æœ next è¿”å› Someï¼Œä½¿ç”¨ match æ¥æå–å…¶å€¼ã€‚å¦‚æœå®ƒè¿”å› Noneï¼Œåˆ™æ„å‘³ç€æ²¡æœ‰æä¾›è¶³å¤Ÿçš„å‚æ•°å¹¶é€šè¿‡ Err å€¼ææ—©è¿”å›ã€‚å¯¹ filename å€¼è¿›è¡ŒåŒæ ·çš„æ“ä½œã€‚

#### ä½¿ç”¨è¿­ä»£å™¨é€‚é…å™¨æ¥ä½¿ä»£ç æ›´ç®€æ˜

```rust
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}

```

å¯ä»¥é€šè¿‡ä½¿ç”¨è¿­ä»£å™¨é€‚é…å™¨æ–¹æ³•æ¥ç¼–å†™æ›´ç®€æ˜çš„ä»£ç ã€‚è¿™ä¹Ÿé¿å…äº†ä¸€ä¸ªå¯å˜çš„ä¸­é—´ results vector çš„ä½¿ç”¨ã€‚å‡½æ•°å¼ç¼–ç¨‹é£æ ¼å€¾å‘äºæœ€å°åŒ–å¯å˜çŠ¶æ€çš„æ•°é‡æ¥ä½¿ä»£ç æ›´ç®€æ´ã€‚å»æ‰å¯å˜çŠ¶æ€å¯èƒ½ä¼šä½¿å¾—å°†æ¥è¿›è¡Œå¹¶è¡Œæœç´¢çš„å¢å¼ºå˜å¾—æ›´å®¹æ˜“ï¼Œå› ä¸ºä¸å¿…ç®¡ç† results vector çš„å¹¶å‘è®¿é—®ã€‚

```rust
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    contents.lines()
        .filter(|line| line.contains(query))
        .collect()
}

```

#### æ€§èƒ½å¯¹æ¯”ï¼šå¾ªç¯ VS è¿­ä»£å™¨

ä¸ºäº†å†³å®šä½¿ç”¨å“ªä¸ªå®ç°ï¼Œéœ€è¦çŸ¥é“å“ªä¸ªç‰ˆæœ¬çš„ search å‡½æ•°æ›´å¿«ä¸€äº›ï¼šæ˜¯ç›´æ¥ä½¿ç”¨ for å¾ªç¯çš„ç‰ˆæœ¬è¿˜æ˜¯ä½¿ç”¨è¿­ä»£å™¨çš„ç‰ˆæœ¬ã€‚

è¿è¡Œäº†ä¸€ä¸ªæ€§èƒ½æµ‹è¯•ï¼Œé€šè¿‡å°†é˜¿ç‘ŸÂ·æŸ¯å—Â·é“å°”çš„â€œç¦å°”æ‘©æ–¯æ¢æ¡ˆé›†â€çš„å…¨éƒ¨å†…å®¹åŠ è½½è¿› String å¹¶å¯»æ‰¾å…¶ä¸­çš„å•è¯ â€œtheâ€ã€‚å¦‚ä¸‹æ˜¯ for å¾ªç¯ç‰ˆæœ¬å’Œè¿­ä»£å™¨ç‰ˆæœ¬çš„ search å‡½æ•°çš„æ€§èƒ½æµ‹è¯•ç»“æœï¼š

ç»“æœè¿­ä»£å™¨ç‰ˆæœ¬è¿˜è¦ç¨å¾®å¿«ä¸€ç‚¹ï¼è¿™é‡Œå°†ä¸ä¼šæŸ¥çœ‹æ€§èƒ½æµ‹è¯•çš„ä»£ç ï¼Œçš„ç›®çš„å¹¶ä¸æ˜¯ä¸ºäº†è¯æ˜ä»–ä»¬æ˜¯å®Œå…¨ç­‰åŒçš„ï¼Œè€Œæ˜¯å¾—å‡ºä¸€ä¸ªæ€æ ·æ¯”è¾ƒè¿™ä¸¤ç§å®ç°æ–¹å¼æ€§èƒ½çš„åŸºæœ¬æ€è·¯ã€‚

å¯¹äºä¸€ä¸ªæ›´å…¨é¢çš„æ€§èƒ½æµ‹è¯•ï¼Œå°†ä¼šæ£€æŸ¥ä¸åŒé•¿åº¦çš„æ–‡æœ¬ã€ä¸åŒçš„æœç´¢å•è¯ã€ä¸åŒé•¿åº¦çš„å•è¯å’Œæ‰€æœ‰å…¶ä»–çš„å¯å˜æƒ…å†µã€‚è¿™é‡Œæ‰€è¦è¡¨è¾¾çš„æ˜¯ï¼šè¿­ä»£å™¨ï¼Œä½œä¸ºä¸€ä¸ªé«˜çº§çš„æŠ½è±¡ï¼Œè¢«ç¼–è¯‘æˆäº†ä¸æ‰‹å†™çš„åº•å±‚ä»£ç å¤§ä½“ä¸€è‡´æ€§èƒ½ä»£ç ã€‚è¿­ä»£å™¨æ˜¯ Rust çš„ é›¶æˆæœ¬æŠ½è±¡ï¼ˆzero-cost abstractionsï¼‰ä¹‹ä¸€ï¼Œå®ƒæ„å‘³ç€æŠ½è±¡å¹¶ä¸ä¼šå¼•å…¥è¿è¡Œæ—¶å¼€é”€ï¼Œå®ƒä¸æœ¬è´¾å°¼Â·æ–¯ç‰¹åŠ³æ–¯ç‰¹å¢æ™®ï¼ˆC++ çš„è®¾è®¡å’Œå®ç°è€…ï¼‰åœ¨ â€œFoundations of C++â€ï¼ˆ2012ï¼‰ ä¸­æ‰€å®šä¹‰çš„ é›¶å¼€é”€ï¼ˆzero-overheadï¼‰å¦‚å‡ºä¸€è¾™ï¼š

ä½œä¸ºå¦ä¸€ä¸ªä¾‹å­ï¼Œè¿™é‡Œæœ‰ä¸€äº›å–è‡ªäºéŸ³é¢‘è§£ç å™¨çš„ä»£ç ã€‚è§£ç ç®—æ³•ä½¿ç”¨çº¿æ€§é¢„æµ‹æ•°å­¦è¿ç®—ï¼ˆlinear prediction mathematical operationï¼‰æ¥æ ¹æ®ä¹‹å‰æ ·æœ¬çš„çº¿æ€§å‡½æ•°é¢„æµ‹å°†æ¥çš„å€¼ã€‚è¿™äº›ä»£ç ä½¿ç”¨è¿­ä»£å™¨é“¾æ¥å¯¹ä½œç”¨åŸŸä¸­çš„ä¸‰ä¸ªå˜é‡è¿›è¡Œäº†æŸç§æ•°å­¦è®¡ç®—ï¼šä¸€ä¸ªå« buffer çš„æ•°æ® sliceã€ä¸€ä¸ªæœ‰ 12 ä¸ªå…ƒç´ çš„æ•°ç»„ coefficientsã€å’Œä¸€ä¸ªä»£è¡¨ä½ç§»ä½æ•°çš„ qlp_shiftã€‚ä¾‹å­ä¸­å£°æ˜äº†è¿™äº›å˜é‡ä½†å¹¶æ²¡æœ‰æä¾›ä»»ä½•å€¼ï¼›è™½ç„¶è¿™äº›ä»£ç åœ¨å…¶ä¸Šä¸‹æ–‡ä¹‹å¤–æ²¡æœ‰ä»€ä¹ˆæ„ä¹‰ï¼Œä¸è¿‡ä»æ˜¯ä¸€ä¸ªç®€æ˜çš„ç°å®ä¸­çš„ä¾‹å­ï¼Œæ¥å±•ç¤º Rust å¦‚ä½•å°†é«˜çº§æ¦‚å¿µè½¬æ¢ä¸ºåº•å±‚ä»£ç ï¼š

```rust
let buffer: &mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&buffer[i - 12..i])
                                 .map(|(&c, &s)| c * s as i64)
                                 .sum::<i64>() >> qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}

```

ä¸ºäº†è®¡ç®— prediction çš„å€¼ï¼Œè¿™äº›ä»£ç éå†äº† coefficients ä¸­çš„ 12 ä¸ªå€¼ï¼Œä½¿ç”¨ zip æ–¹æ³•å°†ç³»æ•°ä¸ buffer çš„å‰ 12 ä¸ªå€¼ç»„åˆåœ¨ä¸€èµ·ã€‚æ¥ç€å°†æ¯ä¸€å¯¹å€¼ç›¸ä¹˜ï¼Œå†å°†æ‰€æœ‰ç»“æœç›¸åŠ ï¼Œç„¶åå°†æ€»å’Œå³ç§» qlp_shift ä½ã€‚

åƒéŸ³é¢‘è§£ç å™¨è¿™æ ·çš„ç¨‹åºé€šå¸¸æœ€çœ‹é‡è®¡ç®—çš„æ€§èƒ½ã€‚è¿™é‡Œï¼Œåˆ›å»ºäº†ä¸€ä¸ªè¿­ä»£å™¨ï¼Œä½¿ç”¨äº†ä¸¤ä¸ªé€‚é…å™¨ï¼Œæ¥ç€æ¶ˆè´¹äº†å…¶å€¼ã€‚Rust ä»£ç å°†ä¼šè¢«ç¼–è¯‘ä¸ºä»€ä¹ˆæ ·çš„æ±‡ç¼–ä»£ç å‘¢ï¼Ÿå¥½å§ï¼Œåœ¨ç¼–å†™æœ¬ä¹¦çš„è¿™ä¸ªæ—¶å€™ï¼Œå®ƒè¢«ç¼–è¯‘æˆä¸æ‰‹å†™çš„ç›¸åŒçš„æ±‡ç¼–ä»£ç ã€‚éå† coefficients çš„å€¼å®Œå…¨ç”¨ä¸åˆ°å¾ªç¯ï¼šRust çŸ¥é“è¿™é‡Œä¼šè¿­ä»£ 12 æ¬¡ï¼Œæ‰€ä»¥å®ƒâ€œå±•å¼€â€ï¼ˆunrollï¼‰äº†å¾ªç¯ã€‚å±•å¼€æ˜¯ä¸€ç§ç§»é™¤å¾ªç¯æ§åˆ¶ä»£ç çš„å¼€é”€å¹¶æ›¿æ¢ä¸ºæ¯ä¸ªè¿­ä»£ä¸­çš„é‡å¤ä»£ç çš„ä¼˜åŒ–ã€‚

æ‰€æœ‰çš„ç³»æ•°éƒ½è¢«å‚¨å­˜åœ¨äº†å¯„å­˜å™¨ä¸­ï¼Œè¿™æ„å‘³ç€è®¿é—®ä»–ä»¬éå¸¸å¿«ã€‚è¿™é‡Œä¹Ÿæ²¡æœ‰è¿è¡Œæ—¶æ•°ç»„è®¿é—®è¾¹ç•Œæ£€æŸ¥ã€‚æ‰€æœ‰è¿™äº› Rust èƒ½å¤Ÿæä¾›çš„ä¼˜åŒ–ä½¿å¾—ç»“æœä»£ç æä¸ºé«˜æ•ˆã€‚ç°åœ¨çŸ¥é“è¿™äº›äº†ï¼Œè¯·æ”¾å¿ƒå¤§èƒ†çš„ä½¿ç”¨è¿­ä»£å™¨å’Œé—­åŒ…å§ï¼ä»–ä»¬ä½¿å¾—ä»£ç çœ‹èµ·æ¥æ›´é«˜çº§ï¼Œä½†å¹¶ä¸ä¸ºæ­¤å¼•å…¥è¿è¡Œæ—¶æ€§èƒ½æŸå¤±ã€‚

### åªèƒ½æŒ‡é’ˆ

æŒ‡é’ˆ ï¼ˆpointerï¼‰æ˜¯ä¸€ä¸ªåŒ…å«å†…å­˜åœ°å€çš„å˜é‡çš„é€šç”¨æ¦‚å¿µã€‚è¿™ä¸ªåœ°å€å¼•ç”¨ï¼Œæˆ– â€œæŒ‡å‘â€ï¼ˆpoints atï¼‰ä¸€äº›å…¶ä»–æ•°æ®ã€‚Rust ä¸­æœ€å¸¸è§çš„æŒ‡é’ˆæ˜¯ç¬¬å››ç« ä»‹ç»çš„ å¼•ç”¨ï¼ˆreferenceï¼‰ã€‚å¼•ç”¨ä»¥ & ç¬¦å·ä¸ºæ ‡å¿—å¹¶å€Ÿç”¨äº†ä»–ä»¬æ‰€æŒ‡å‘çš„å€¼ã€‚é™¤äº†å¼•ç”¨æ•°æ®æ²¡æœ‰ä»»ä½•å…¶ä»–ç‰¹æ®ŠåŠŸèƒ½ã€‚å®ƒä»¬ä¹Ÿæ²¡æœ‰ä»»ä½•é¢å¤–å¼€é”€ï¼Œæ‰€ä»¥åº”ç”¨çš„æœ€å¤šã€‚

å¦ä¸€æ–¹é¢ï¼Œæ™ºèƒ½æŒ‡é’ˆï¼ˆsmart pointersï¼‰æ˜¯ä¸€ç±»æ•°æ®ç»“æ„ï¼Œä»–ä»¬çš„è¡¨ç°ç±»ä¼¼æŒ‡é’ˆï¼Œä½†æ˜¯ä¹Ÿæ‹¥æœ‰é¢å¤–çš„å…ƒæ•°æ®å’ŒåŠŸèƒ½ã€‚æ™ºèƒ½æŒ‡é’ˆçš„æ¦‚å¿µå¹¶ä¸ä¸º Rust æ‰€ç‹¬æœ‰ï¼›å…¶èµ·æºäº C++ å¹¶å­˜åœ¨äºå…¶ä»–è¯­è¨€ä¸­ã€‚Rust æ ‡å‡†åº“ä¸­ä¸åŒçš„æ™ºèƒ½æŒ‡é’ˆæä¾›äº†å¤šäºå¼•ç”¨çš„é¢å¤–åŠŸèƒ½ã€‚æœ¬ç« å°†ä¼šæ¢ç´¢çš„ä¸€ä¸ªä¾‹å­ä¾¿æ˜¯ å¼•ç”¨è®¡æ•° ï¼ˆreference countingï¼‰æ™ºèƒ½æŒ‡é’ˆç±»å‹ï¼Œå…¶å…è®¸æ•°æ®æœ‰å¤šä¸ªæ‰€æœ‰è€…ã€‚å¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆè®°å½•æ€»å…±æœ‰å¤šå°‘ä¸ªæ‰€æœ‰è€…ï¼Œå¹¶å½“æ²¡æœ‰ä»»ä½•æ‰€æœ‰è€…æ—¶è´Ÿè´£æ¸…ç†æ•°æ®ã€‚

åœ¨ Rust ä¸­ï¼Œæ™®é€šå¼•ç”¨å’Œæ™ºèƒ½æŒ‡é’ˆçš„ä¸€ä¸ªé¢å¤–çš„åŒºåˆ«æ˜¯å¼•ç”¨æ˜¯ä¸€ç±»åªå€Ÿç”¨æ•°æ®çš„æŒ‡é’ˆï¼›ç›¸åï¼Œåœ¨å¤§éƒ¨åˆ†æƒ…å†µä¸‹ï¼Œæ™ºèƒ½æŒ‡é’ˆ æ‹¥æœ‰ ä»–ä»¬æŒ‡å‘çš„æ•°æ®ã€‚

å®é™…ä¸Šæœ¬ä¹¦ä¸­å·²ç»å‡ºç°è¿‡ä¸€äº›æ™ºèƒ½æŒ‡é’ˆï¼Œæ¯”å¦‚ç¬¬å…«ç« çš„ String å’Œ Vec<T>ï¼Œè™½ç„¶å½“æ—¶å¹¶ä¸è¿™ä¹ˆç§°å‘¼å®ƒä»¬ã€‚è¿™äº›ç±»å‹éƒ½å±äºæ™ºèƒ½æŒ‡é’ˆå› ä¸ºå®ƒä»¬æ‹¥æœ‰ä¸€äº›æ•°æ®å¹¶å…è®¸ä½ ä¿®æ”¹å®ƒä»¬ã€‚å®ƒä»¬ä¹Ÿå¸¦æœ‰å…ƒæ•°æ®ï¼ˆæ¯”å¦‚ä»–ä»¬çš„å®¹é‡ï¼‰å’Œé¢å¤–çš„åŠŸèƒ½æˆ–ä¿è¯ï¼ˆString çš„æ•°æ®æ€»æ˜¯æœ‰æ•ˆçš„ UTF-8 ç¼–ç ï¼‰ã€‚

æ™ºèƒ½æŒ‡é’ˆé€šå¸¸ä½¿ç”¨ç»“æ„ä½“å®ç°ã€‚æ™ºèƒ½æŒ‡é’ˆåŒºåˆ«äºå¸¸è§„ç»“æ„ä½“çš„æ˜¾è‘—ç‰¹æ€§åœ¨äºå…¶å®ç°äº† Deref å’Œ Drop traitã€‚Deref trait å…è®¸æ™ºèƒ½æŒ‡é’ˆç»“æ„ä½“å®ä¾‹è¡¨ç°çš„åƒå¼•ç”¨ä¸€æ ·ï¼Œè¿™æ ·å°±å¯ä»¥ç¼–å†™æ—¢ç”¨äºå¼•ç”¨ã€åˆç”¨äºæ™ºèƒ½æŒ‡é’ˆçš„ä»£ç ã€‚Drop trait å…è®¸è‡ªå®šä¹‰å½“æ™ºèƒ½æŒ‡é’ˆç¦»å¼€ä½œç”¨åŸŸæ—¶è¿è¡Œçš„ä»£ç ã€‚æœ¬ç« ä¼šè®¨è®ºè¿™äº› trait ä»¥åŠä¸ºä»€ä¹ˆå¯¹äºæ™ºèƒ½æŒ‡é’ˆæ¥è¯´ä»–ä»¬å¾ˆé‡è¦ã€‚

è€ƒè™‘åˆ°æ™ºèƒ½æŒ‡é’ˆæ˜¯ä¸€ä¸ªåœ¨ Rust ç»å¸¸è¢«ä½¿ç”¨çš„é€šç”¨è®¾è®¡æ¨¡å¼ï¼Œæœ¬ç« å¹¶ä¸ä¼šè¦†ç›–æ‰€æœ‰ç°å­˜çš„æ™ºèƒ½æŒ‡é’ˆã€‚å¾ˆå¤šåº“éƒ½æœ‰è‡ªå·±çš„æ™ºèƒ½æŒ‡é’ˆè€Œä½ ä¹Ÿå¯ä»¥ç¼–å†™å±äºä½ è‡ªå·±çš„æ™ºèƒ½æŒ‡é’ˆã€‚è¿™é‡Œå°†ä¼šè®²åˆ°çš„æ˜¯æ¥è‡ªæ ‡å‡†åº“ä¸­æœ€å¸¸ç”¨çš„ä¸€äº›ï¼š

* `Box<T>`ï¼Œç”¨äºåœ¨å †ä¸Šåˆ†é…å€¼
* `Rc<T>`ï¼Œä¸€ä¸ªå¼•ç”¨è®¡æ•°ç±»å‹ï¼Œå…¶æ•°æ®å¯ä»¥æœ‰å¤šä¸ªæ‰€æœ‰è€…
* `Ref<T>` å’Œ `RefMut<T>`ï¼Œé€šè¿‡ `RefCell<T>` è®¿é—®ï¼Œä¸€ä¸ªåœ¨è¿è¡Œæ—¶è€Œä¸æ˜¯åœ¨ç¼–è¯‘æ—¶æ‰§è¡Œå€Ÿç”¨è§„åˆ™çš„ç±»å‹ã€‚

#### ä½¿ç”¨Box <T>æŒ‡å‘å †ä¸Šçš„æ•°æ®

æœ€ç®€å•ç›´æ¥çš„æ™ºèƒ½æŒ‡é’ˆæ˜¯ boxï¼Œå…¶ç±»å‹æ˜¯ `Box<T>`ã€‚ box å…è®¸ä½ å°†ä¸€ä¸ªå€¼æ”¾åœ¨å †ä¸Šè€Œä¸æ˜¯æ ˆä¸Šã€‚ç•™åœ¨æ ˆä¸Šçš„åˆ™æ˜¯æŒ‡å‘å †æ•°æ®çš„æŒ‡é’ˆã€‚å¦‚æœä½ æƒ³å›é¡¾ä¸€ä¸‹æ ˆä¸å †çš„åŒºåˆ«è¯·å‚è€ƒç¬¬å››ç« ã€‚

é™¤äº†æ•°æ®è¢«å‚¨å­˜åœ¨å †ä¸Šè€Œä¸æ˜¯æ ˆä¸Šä¹‹å¤–ï¼Œbox æ²¡æœ‰æ€§èƒ½æŸå¤±ã€‚ä¸è¿‡ä¹Ÿæ²¡æœ‰å¾ˆå¤šé¢å¤–çš„åŠŸèƒ½ã€‚å®ƒä»¬å¤šç”¨äºå¦‚ä¸‹åœºæ™¯ï¼š

* å½“æœ‰ä¸€ä¸ªåœ¨ç¼–è¯‘æ—¶æœªçŸ¥å¤§å°çš„ç±»å‹ï¼Œè€Œåˆæƒ³è¦åœ¨éœ€è¦ç¡®åˆ‡å¤§å°çš„ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨è¿™ä¸ªç±»å‹å€¼çš„æ—¶å€™
* å½“æœ‰å¤§é‡æ•°æ®å¹¶å¸Œæœ›åœ¨ç¡®ä¿æ•°æ®ä¸è¢«æ‹·è´çš„æƒ…å†µä¸‹è½¬ç§»æ‰€æœ‰æƒçš„æ—¶å€™
* å½“å¸Œæœ›æ‹¥æœ‰ä¸€ä¸ªå€¼å¹¶åªå…³å¿ƒå®ƒçš„ç±»å‹æ˜¯å¦å®ç°äº†ç‰¹å®š trait è€Œä¸æ˜¯å…¶å…·ä½“ç±»å‹çš„æ—¶å€™

ä¸‹ä¾‹å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ box åœ¨å †ä¸Šå‚¨å­˜ä¸€ä¸ª i32ï¼š

```rust
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}

```

è¿™é‡Œå®šä¹‰äº†å˜é‡ bï¼Œå…¶å€¼æ˜¯ä¸€ä¸ªæŒ‡å‘è¢«åˆ†é…åœ¨å †ä¸Šçš„å€¼ 5 çš„ Boxã€‚è¿™ä¸ªç¨‹åºä¼šæ‰“å°å‡º b = 5ï¼›åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå¯ä»¥åƒæ•°æ®æ˜¯å‚¨å­˜åœ¨æ ˆä¸Šçš„é‚£æ ·è®¿é—® box ä¸­çš„æ•°æ®ã€‚æ­£å¦‚ä»»ä½•æ‹¥æœ‰æ•°æ®æ‰€æœ‰æƒçš„å€¼é‚£æ ·ï¼Œå½“åƒ b è¿™æ ·çš„ box åœ¨ main çš„æœ«å°¾ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå®ƒå°†è¢«é‡Šæ”¾ã€‚è¿™ä¸ªé‡Šæ”¾è¿‡ç¨‹ä½œç”¨äº box æœ¬èº«ï¼ˆä½äºæ ˆä¸Šï¼‰å’Œå®ƒæ‰€æŒ‡å‘çš„æ•°æ®ï¼ˆä½äºå †ä¸Šï¼‰ã€‚

å°†ä¸€ä¸ªå•ç‹¬çš„å€¼å­˜æ”¾åœ¨å †ä¸Šå¹¶ä¸æ˜¯å¾ˆæœ‰æ„ä¹‰ï¼Œæ‰€ä»¥åƒç¤ºä¾‹ 15-1 è¿™æ ·å•ç‹¬ä½¿ç”¨ box å¹¶ä¸å¸¸è§ã€‚å°†åƒå•ä¸ª i32 è¿™æ ·çš„å€¼å‚¨å­˜åœ¨æ ˆä¸Šï¼Œä¹Ÿå°±æ˜¯å…¶é»˜è®¤å­˜æ”¾çš„åœ°æ–¹åœ¨å¤§éƒ¨åˆ†ä½¿ç”¨åœºæ™¯ä¸­æ›´ä¸ºåˆé€‚ã€‚è®©çœ‹çœ‹ä¸€ä¸ªä¸ä½¿ç”¨ box æ—¶æ— æ³•å®šä¹‰çš„ç±»å‹çš„ä¾‹å­ã€‚

#### Box å…è®¸åˆ›å»ºé€’å½’ç±»å‹

Rust éœ€è¦åœ¨ç¼–è¯‘æ—¶çŸ¥é“ç±»å‹å ç”¨å¤šå°‘ç©ºé—´ã€‚ä¸€ç§æ— æ³•åœ¨ç¼–è¯‘æ—¶çŸ¥é“å¤§å°çš„ç±»å‹æ˜¯ é€’å½’ç±»å‹ï¼ˆrecursive typeï¼‰ï¼Œå…¶å€¼çš„ä¸€éƒ¨åˆ†å¯ä»¥æ˜¯ç›¸åŒç±»å‹çš„å¦ä¸€ä¸ªå€¼ã€‚è¿™ç§å€¼çš„åµŒå¥—ç†è®ºä¸Šå¯ä»¥æ— é™çš„è¿›è¡Œä¸‹å»ï¼Œæ‰€ä»¥ Rust ä¸çŸ¥é“é€’å½’ç±»å‹éœ€è¦å¤šå°‘ç©ºé—´ã€‚ä¸è¿‡ box æœ‰ä¸€ä¸ªå·²çŸ¥çš„å¤§å°ï¼Œæ‰€ä»¥é€šè¿‡åœ¨å¾ªç¯ç±»å‹å®šä¹‰ä¸­æ’å…¥ boxï¼Œå°±å¯ä»¥åˆ›å»ºé€’å½’ç±»å‹äº†ã€‚

##### cons list çš„æ›´å¤šå†…å®¹

cons list æ˜¯ä¸€ä¸ªæ¥æºäº Lisp ç¼–ç¨‹è¯­è¨€åŠå…¶æ–¹è¨€çš„æ•°æ®ç»“æ„ã€‚åœ¨ Lisp ä¸­ï¼Œcons å‡½æ•°ï¼ˆâ€œconstruct function" çš„ç¼©å†™ï¼‰åˆ©ç”¨ä¸¤ä¸ªå‚æ•°æ¥æ„é€ ä¸€ä¸ªæ–°çš„åˆ—è¡¨ï¼Œä»–ä»¬é€šå¸¸æ˜¯ä¸€ä¸ªå•ç‹¬çš„å€¼å’Œå¦ä¸€ä¸ªåˆ—è¡¨ã€‚

cons å‡½æ•°çš„æ¦‚å¿µæ¶‰åŠåˆ°æ›´å¸¸è§çš„å‡½æ•°å¼ç¼–ç¨‹æœ¯è¯­ï¼›â€œå°† x ä¸ y è¿æ¥â€ é€šå¸¸æ„å‘³ç€æ„å»ºä¸€ä¸ªæ–°çš„å®¹å™¨è€Œå°† x çš„å…ƒç´ æ”¾åœ¨æ–°å®¹å™¨çš„å¼€å¤´ï¼Œå…¶ååˆ™æ˜¯å®¹å™¨ y çš„å…ƒç´ ã€‚

cons list çš„æ¯ä¸€é¡¹éƒ½åŒ…å«ä¸¤ä¸ªå…ƒç´ ï¼šå½“å‰é¡¹çš„å€¼å’Œä¸‹ä¸€é¡¹ã€‚å…¶æœ€åä¸€é¡¹å€¼åŒ…å«ä¸€ä¸ªå«åš Nil çš„å€¼ä¸”æ²¡æœ‰ä¸‹ä¸€é¡¹ã€‚cons list é€šè¿‡é€’å½’è°ƒç”¨ cons å‡½æ•°äº§ç”Ÿã€‚ä»£è¡¨é€’å½’çš„ç»ˆæ­¢æ¡ä»¶ï¼ˆbase caseï¼‰çš„è§„èŒƒåç§°æ˜¯ Nilï¼Œå®ƒå®£å¸ƒåˆ—è¡¨çš„ç»ˆæ­¢ã€‚æ³¨æ„è¿™ä¸åŒäºç¬¬å…­ç« ä¸­çš„ â€œnullâ€ æˆ– â€œnilâ€ çš„æ¦‚å¿µï¼Œä»–ä»¬ä»£è¡¨æ— æ•ˆæˆ–ç¼ºå¤±çš„å€¼ã€‚ 

æ³¨æ„è™½ç„¶å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ç»å¸¸ä½¿ç”¨ cons listï¼Œä½†æ˜¯å®ƒå¹¶ä¸æ˜¯ä¸€ä¸ª Rust ä¸­å¸¸è§çš„ç±»å‹ã€‚å¤§éƒ¨åˆ†åœ¨ Rust ä¸­éœ€è¦åˆ—è¡¨çš„æ—¶å€™ï¼Œ`Vec<T>` æ˜¯ä¸€ä¸ªæ›´å¥½çš„é€‰æ‹©ã€‚å…¶ä»–æ›´ä¸ºå¤æ‚çš„é€’å½’æ•°æ®ç±»å‹ ç¡®å® åœ¨ Rust çš„å¾ˆå¤šåœºæ™¯ä¸­å¾ˆæœ‰ç”¨ï¼Œä¸è¿‡é€šè¿‡ä»¥ cons list ä½œä¸ºå¼€å§‹ï¼Œå¯ä»¥æ¢ç´¢å¦‚ä½•ä½¿ç”¨ box æ¯«ä¸è´¹åŠ›çš„å®šä¹‰ä¸€ä¸ªé€’å½’æ•°æ®ç±»å‹ã€‚

ä¸‹ä¾‹ åŒ…å«ä¸€ä¸ª cons list çš„æšä¸¾å®šä¹‰ã€‚æ³¨æ„è¿™è¿˜ä¸èƒ½ç¼–è¯‘å› ä¸ºè¿™ä¸ªç±»å‹æ²¡æœ‰å·²çŸ¥çš„å¤§å°ï¼š

```rust
enum List {
    Cons(i32, List),
    Nil,
}

```

ä½¿ç”¨è¿™ä¸ª cons list æ¥å‚¨å­˜åˆ—è¡¨ 1, 2, 3 å°†çœ‹èµ·æ¥å¦‚ä¸‹ä¾‹æ‰€ç¤ºï¼š

```rust
use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}

```

ç¬¬ä¸€ä¸ª Cons å‚¨å­˜äº† 1 å’Œå¦ä¸€ä¸ª List å€¼ã€‚è¿™ä¸ª List æ˜¯å¦ä¸€ä¸ªåŒ…å« 2 çš„ Cons å€¼å’Œä¸‹ä¸€ä¸ª List å€¼ã€‚æ¥ç€åˆæœ‰å¦ä¸€ä¸ªå­˜æ”¾äº† 3 çš„ Cons å€¼å’Œæœ€åä¸€ä¸ªå€¼ä¸º Nil çš„ Listï¼Œéé€’å½’æˆå‘˜ä»£è¡¨äº†åˆ—è¡¨çš„ç»“å°¾ã€‚

å¦‚æœå°è¯•ç¼–è¯‘ä¸‹ä¾‹çš„ä»£ç ï¼Œä¼šå¾—åˆ°å¦‚ä¸‹æ‰€ç¤ºçš„é”™è¯¯ï¼š

```rust
error[E0072]: recursive type `List` has infinite size
 --> src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ----- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to
  make `List` representable

```

è¿™ä¸ªé”™è¯¯è¡¨æ˜è¿™ä¸ªç±»å‹ â€œæœ‰æ— é™çš„å¤§å°â€ã€‚å…¶åŸå› æ˜¯ List çš„ä¸€ä¸ªæˆå‘˜è¢«å®šä¹‰ä¸ºæ˜¯é€’å½’çš„ï¼šå®ƒç›´æ¥å­˜æ”¾äº†å¦ä¸€ä¸ªç›¸åŒç±»å‹çš„å€¼ã€‚è¿™æ„å‘³ç€ Rust æ— æ³•è®¡ç®—ä¸ºäº†å­˜æ”¾ List å€¼åˆ°åº•éœ€è¦å¤šå°‘ç©ºé—´ã€‚è®©ä¸€ç‚¹ä¸€ç‚¹æ¥çœ‹ï¼šé¦–å…ˆäº†è§£ä¸€ä¸‹ Rust å¦‚ä½•å†³å®šéœ€è¦å¤šå°‘ç©ºé—´æ¥å­˜æ”¾ä¸€ä¸ªéé€’å½’ç±»å‹ã€‚

#### è®¡ç®—éé€’å½’ç±»å‹çš„å¤§å°

```rust

#![allow(unused_variables)]
fn main() {
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
}
```

å½“ Rust éœ€è¦çŸ¥é“è¦ä¸º Message å€¼åˆ†é…å¤šå°‘ç©ºé—´æ—¶ï¼Œå®ƒå¯ä»¥æ£€æŸ¥æ¯ä¸€ä¸ªæˆå‘˜å¹¶å‘ç° Message::Quit å¹¶ä¸éœ€è¦ä»»ä½•ç©ºé—´ï¼ŒMessage::Move éœ€è¦è¶³å¤Ÿå‚¨å­˜ä¸¤ä¸ª i32 å€¼çš„ç©ºé—´ï¼Œä¾æ­¤ç±»æ¨ã€‚å› æ­¤ï¼ŒMessage å€¼æ‰€éœ€çš„ç©ºé—´ç­‰äºå‚¨å­˜å…¶æœ€å¤§æˆå‘˜çš„ç©ºé—´å¤§å°ã€‚

ä¸æ­¤ç›¸å¯¹å½“ Rust ç¼–è¯‘å™¨æ£€æŸ¥åƒç¤ºä¾‹ 15-2 ä¸­çš„ List è¿™æ ·çš„é€’å½’ç±»å‹æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆå‘¢ã€‚ç¼–è¯‘å™¨å°è¯•è®¡ç®—å‡ºå‚¨å­˜ä¸€ä¸ª List æšä¸¾éœ€è¦å¤šå°‘å†…å­˜ï¼Œå¹¶å¼€å§‹æ£€æŸ¥ Cons æˆå‘˜ï¼Œé‚£ä¹ˆ Cons éœ€è¦çš„ç©ºé—´ç­‰äº i32 çš„å¤§å°åŠ ä¸Š List çš„å¤§å°ã€‚ä¸ºäº†è®¡ç®— List éœ€è¦å¤šå°‘å†…å­˜ï¼Œå®ƒæ£€æŸ¥å…¶æˆå‘˜ï¼Œä» Cons æˆå‘˜å¼€å§‹ã€‚Consæˆå‘˜å‚¨å­˜äº†ä¸€ä¸ª i32 å€¼å’Œä¸€ä¸ªListå€¼ï¼Œè¿™æ ·çš„è®¡ç®—å°†æ— é™è¿›è¡Œä¸‹å».

#### ä½¿ç”¨ Box<T> ç»™é€’å½’ç±»å‹ä¸€ä¸ªå·²çŸ¥çš„å¤§å°

Rust æ— æ³•è®¡ç®—å‡ºè¦ä¸ºå®šä¹‰ä¸ºé€’å½’çš„ç±»å‹åˆ†é…å¤šå°‘ç©ºé—´ï¼Œæ‰€ä»¥ç¼–è¯‘å™¨ç»™å‡ºäº†ä¸‹ä¾‹ä¸­çš„é”™è¯¯ã€‚è¿™ä¸ªé”™è¯¯ä¹ŸåŒ…æ‹¬äº†æœ‰ç”¨çš„å»ºè®®ï¼š

```rust
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to
  make `List` representable

```

å› ä¸º `Box<T>` æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œæ€»æ˜¯çŸ¥é“å®ƒéœ€è¦å¤šå°‘ç©ºé—´ï¼šæŒ‡é’ˆçš„å¤§å°å¹¶ä¸ä¼šæ ¹æ®å…¶æŒ‡å‘çš„æ•°æ®é‡è€Œæ”¹å˜ã€‚è¿™æ„å‘³ç€å¯ä»¥å°† Box æ”¾å…¥ Cons æˆå‘˜ä¸­è€Œä¸æ˜¯ç›´æ¥å­˜æ”¾å¦ä¸€ä¸ª List å€¼ã€‚Box ä¼šæŒ‡å‘å¦ä¸€ä¸ªä½äºå †ä¸Šçš„ List å€¼ï¼Œè€Œä¸æ˜¯å­˜æ”¾åœ¨ Cons æˆå‘˜ä¸­ã€‚ä»æ¦‚å¿µä¸Šè®²ï¼Œä»ç„¶æœ‰ä¸€ä¸ªé€šè¿‡åœ¨å…¶ä¸­ â€œå­˜æ”¾â€ å…¶ä»–åˆ—è¡¨åˆ›å»ºçš„åˆ—è¡¨ï¼Œä¸è¿‡ç°åœ¨å®ç°è¿™ä¸ªæ¦‚å¿µçš„æ–¹å¼æ›´åƒæ˜¯ä¸€ä¸ªé¡¹æŒ¨ç€å¦ä¸€é¡¹ï¼Œè€Œä¸æ˜¯ä¸€é¡¹åŒ…å«å¦ä¸€é¡¹ã€‚

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}

```

Cons æˆå‘˜å°†ä¼šéœ€è¦ä¸€ä¸ª i32 çš„å¤§å°åŠ ä¸Šå‚¨å­˜ box æŒ‡é’ˆæ•°æ®çš„ç©ºé—´ã€‚Nil æˆå‘˜ä¸å‚¨å­˜å€¼ï¼Œæ‰€ä»¥å®ƒæ¯” Cons æˆå‘˜éœ€è¦æ›´å°‘çš„ç©ºé—´ã€‚ç°åœ¨çŸ¥é“äº†ä»»ä½• List å€¼æœ€å¤šéœ€è¦ä¸€ä¸ª i32 åŠ ä¸Š box æŒ‡é’ˆæ•°æ®çš„å¤§å°ã€‚é€šè¿‡ä½¿ç”¨ box ï¼Œæ‰“ç ´äº†è¿™æ— é™é€’å½’çš„è¿é”ï¼Œè¿™æ ·ç¼–è¯‘å™¨å°±èƒ½å¤Ÿè®¡ç®—å‡ºå‚¨å­˜ List å€¼éœ€è¦çš„å¤§å°äº†ã€‚

box åªæä¾›äº†é—´æ¥å­˜å‚¨å’Œå †åˆ†é…ï¼›ä»–ä»¬å¹¶æ²¡æœ‰ä»»ä½•å…¶ä»–ç‰¹æ®Šçš„åŠŸèƒ½ï¼Œæ¯”å¦‚å°†ä¼šè§åˆ°çš„å…¶ä»–æ™ºèƒ½æŒ‡é’ˆã€‚å®ƒä»¬ä¹Ÿæ²¡æœ‰è¿™äº›ç‰¹æ®ŠåŠŸèƒ½å¸¦æ¥çš„æ€§èƒ½æŸå¤±ï¼Œæ‰€ä»¥ä»–ä»¬å¯ä»¥ç”¨äºåƒ cons list è¿™æ ·é—´æ¥å­˜å‚¨æ˜¯å”¯ä¸€æ‰€éœ€åŠŸèƒ½çš„åœºæ™¯ã€‚

`Box<T>` ç±»å‹æ˜¯ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆï¼Œå› ä¸ºå®ƒå®ç°äº† Deref traitï¼Œå®ƒå…è®¸ `Box<T>` å€¼è¢«å½“ä½œå¼•ç”¨å¯¹å¾…ã€‚å½“ `Box<T>` å€¼ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œç”±äº `Box<T>` ç±»å‹ Drop trait çš„å®ç°ï¼Œbox æ‰€æŒ‡å‘çš„å †æ•°æ®ä¹Ÿä¼šè¢«æ¸…é™¤ã€‚è®©æ›´è¯¦ç»†çš„æ¢ç´¢ä¸€ä¸‹è¿™ä¸¤ä¸ª traitã€‚è¿™ä¸¤ä¸ª trait å¯¹äºåœ¨æœ¬ç« ä½™ä¸‹è®¨è®ºçš„å…¶ä»–æ™ºèƒ½æŒ‡é’ˆæ‰€æä¾›çš„åŠŸèƒ½ä¸­ï¼Œå°†ä¼šæ›´ä¸ºé‡è¦ã€‚

#### é€šè¿‡ Deref trait å°†æ™ºèƒ½æŒ‡é’ˆå½“ä½œå¸¸è§„å¼•ç”¨å¤„ç†

å®ç° Deref trait å…è®¸é‡è½½ è§£å¼•ç”¨è¿ç®—ç¬¦ï¼ˆdereference operatorï¼‰*ï¼ˆä¸ä¹˜æ³•è¿ç®—ç¬¦æˆ– glob è¿ç®—ç¬¦ç›¸åŒºåˆ«ï¼‰ã€‚é€šè¿‡è¿™ç§æ–¹å¼å®ç° Deref trait çš„æ™ºèƒ½æŒ‡é’ˆå¯ä»¥è¢«å½“ä½œå¸¸è§„å¼•ç”¨æ¥å¯¹å¾…ï¼Œå¯ä»¥ç¼–å†™æ“ä½œå¼•ç”¨çš„ä»£ç å¹¶ç”¨äºæ™ºèƒ½æŒ‡é’ˆã€‚

è®©é¦–å…ˆçœ‹çœ‹è§£å¼•ç”¨è¿ç®—ç¬¦å¦‚ä½•å¤„ç†å¸¸è§„å¼•ç”¨ï¼Œæ¥ç€å°è¯•å®šä¹‰è‡ªå·±çš„ç±»ä¼¼ `Box<T>` çš„ç±»å‹å¹¶çœ‹çœ‹ä¸ºä½•è§£å¼•ç”¨è¿ç®—ç¬¦ä¸èƒ½åƒå¼•ç”¨ä¸€æ ·å·¥ä½œã€‚ä¼šæ¢ç´¢å¦‚ä½•å®ç° Deref trait ä½¿å¾—æ™ºèƒ½æŒ‡é’ˆä»¥ç±»ä¼¼å¼•ç”¨çš„æ–¹å¼å·¥ä½œå˜ä¸ºå¯èƒ½ã€‚æœ€åï¼Œä¼šè®¨è®º Rust çš„ è§£å¼•ç”¨å¼ºåˆ¶å¤šæ€ï¼ˆderef coercionsï¼‰åŠŸèƒ½å’Œå®ƒæ˜¯å¦‚ä½•ä¸€åŒå¤„ç†å¼•ç”¨æˆ–æ™ºèƒ½æŒ‡é’ˆçš„ã€‚

#### é€šè¿‡è§£å¼•ç”¨è¿ç®—ç¬¦è¿½è¸ªæŒ‡é’ˆçš„å€¼

å¸¸è§„å¼•ç”¨æ˜¯ä¸€ä¸ªæŒ‡é’ˆç±»å‹ï¼Œä¸€ç§ç†è§£æŒ‡é’ˆçš„æ–¹å¼æ˜¯å°†å…¶çœ‹æˆæŒ‡å‘å‚¨å­˜åœ¨å…¶ä»–æŸå¤„å€¼çš„ç®­å¤´ã€‚

```rust
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}

```

å˜é‡ x å­˜æ”¾äº†ä¸€ä¸ª i32 å€¼ 5ã€‚y ç­‰äº x çš„ä¸€ä¸ªå¼•ç”¨ã€‚å¯ä»¥æ–­è¨€ x ç­‰äº 5ã€‚ç„¶è€Œï¼Œå¦‚æœå¸Œæœ›å¯¹ y çš„å€¼åšå‡ºæ–­è¨€ï¼Œå¿…é¡»ä½¿ç”¨ *y æ¥è¿½è¸ªå¼•ç”¨æ‰€æŒ‡å‘çš„å€¼ï¼ˆä¹Ÿå°±æ˜¯ è§£å¼•ç”¨ï¼‰ã€‚ä¸€æ—¦è§£å¼•ç”¨äº† yï¼Œå°±å¯ä»¥è®¿é—® y æ‰€æŒ‡å‘çš„æ•´å‹å€¼å¹¶å¯ä»¥ä¸ 5 åšæ¯”è¾ƒã€‚

ç›¸åå¦‚æœå°è¯•ç¼–å†™ assert_eq!(5, y);ï¼Œåˆ™ä¼šå¾—åˆ°å¦‚ä¸‹ç¼–è¯‘é”™è¯¯ï¼š

```rust
error[E0277]: can't compare `{integer}` with `&{integer}`
 --> src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &{integer}`
  |
  = help: the trait `std::cmp::PartialEq<&{integer}>` is not implemented for
  `{integer}`

```

ä¸å…è®¸æ¯”è¾ƒæ•°å­—çš„å¼•ç”¨ä¸æ•°å­—ï¼Œå› ä¸ºå®ƒä»¬æ˜¯ä¸åŒçš„ç±»å‹ã€‚å¿…é¡»ä½¿ç”¨è§£å¼•ç”¨è¿ç®—ç¬¦è¿½è¸ªå¼•ç”¨æ‰€æŒ‡å‘çš„å€¼ã€‚

#### åƒå¼•ç”¨ä¸€æ ·ä½¿ç”¨ Box<T>

å¯ä»¥ä½¿ç”¨ `Box<T>` ä»£æ›¿å¼•ç”¨æ¥é‡å†™ä¸Šä¾‹ä¸­çš„ä»£ç ï¼Œè§£å¼•ç”¨è¿ç®—ç¬¦ä¹Ÿä¸€æ ·èƒ½å·¥ä½œï¼Œå¦‚ä¸‹ä¾‹æ‰€ç¤ºï¼š

```rust
fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}

```

#### è‡ªå®šä¹‰æ™ºèƒ½æŒ‡é’ˆ

ä¸ºäº†ä½“ä¼šé»˜è®¤æ™ºèƒ½æŒ‡é’ˆçš„è¡Œä¸ºä¸åŒäºå¼•ç”¨ï¼Œè®©åˆ›å»ºä¸€ä¸ªç±»ä¼¼äºæ ‡å‡†åº“æä¾›çš„ `Box<T>` ç±»å‹çš„æ™ºèƒ½æŒ‡é’ˆã€‚æ¥ç€ä¼šå­¦ä¹ å¦‚ä½•å¢åŠ ä½¿ç”¨è§£å¼•ç”¨è¿ç®—ç¬¦çš„åŠŸèƒ½ã€‚

ä»æ ¹æœ¬ä¸Šè¯´ï¼Œ`Box<T>` è¢«å®šä¹‰ä¸ºåŒ…å«ä¸€ä¸ªå…ƒç´ çš„å…ƒç»„ç»“æ„ä½“ï¼Œæ‰€ä»¥ä¸‹ä¾‹ä»¥ç›¸åŒçš„æ–¹å¼å®šä¹‰äº† `MyBox<T>` ç±»å‹ã€‚è¿˜å®šä¹‰äº† new å‡½æ•°æ¥å¯¹åº”å®šä¹‰äº `Box<T>` çš„ new å‡½æ•°ï¼š

```rust

#![allow(unused_variables)]
fn main() {
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}
}
```

è¿™é‡Œå®šä¹‰äº†ä¸€ä¸ªç»“æ„ä½“ MyBox å¹¶å£°æ˜äº†ä¸€ä¸ªæ³›å‹å‚æ•° Tï¼Œå› ä¸ºå¸Œæœ›å…¶å¯ä»¥å­˜æ”¾ä»»ä½•ç±»å‹çš„å€¼ã€‚MyBox æ˜¯ä¸€ä¸ªåŒ…å« T ç±»å‹å…ƒç´ çš„å…ƒç»„ç»“æ„ä½“ã€‚MyBox::new å‡½æ•°è·å–ä¸€ä¸ª T ç±»å‹çš„å‚æ•°å¹¶è¿”å›ä¸€ä¸ªå­˜æ”¾ä¼ å…¥å€¼çš„ MyBox å®ä¾‹ã€‚

å°è¯•å°†ä¸‹ä¾‹ä¸­çš„ä»£ç åŠ å…¥ç¤ºä¾‹ 15-8 ä¸­å¹¶ä¿®æ”¹ main ä½¿ç”¨å®šä¹‰çš„ `MyBox<T>` ç±»å‹ä»£æ›¿ `Box<T>`ã€‚ç¤ºä¾‹ 15-9 ä¸­çš„ä»£ç ä¸èƒ½ç¼–è¯‘ï¼Œå› ä¸º Rust ä¸çŸ¥é“å¦‚ä½•è§£å¼•ç”¨ MyBoxï¼š

```rust
fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}

```

å°è¯•ä»¥ä½¿ç”¨å¼•ç”¨å’Œ `Box<T>` ç›¸åŒçš„æ–¹å¼ä½¿ç”¨ `MyBox<T>`

å¾—åˆ°çš„ç¼–è¯‘é”™è¯¯æ˜¯ï¼š

```rust
error[E0614]: type `MyBox<{integer}>` cannot be dereferenced
  --> src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

```

`MyBox<T>` ç±»å‹ä¸èƒ½è§£å¼•ç”¨å¹¶æ²¡æœ‰ä¸ºå…¶å®ç°è¿™ä¸ªåŠŸèƒ½ã€‚ä¸ºäº†å¯ç”¨ * è¿ç®—ç¬¦çš„è§£å¼•ç”¨åŠŸèƒ½ï¼Œéœ€è¦å®ç° Deref traitã€‚

#### é€šè¿‡å®ç° Deref trait å°†æŸç±»å‹åƒå¼•ç”¨ä¸€æ ·å¤„ç†

ä¸ºäº†å®ç° traitï¼Œéœ€è¦æä¾› trait æ‰€éœ€çš„æ–¹æ³•å®ç°ã€‚Deref traitï¼Œç”±æ ‡å‡†åº“æä¾›ï¼Œè¦æ±‚å®ç°åä¸º deref çš„æ–¹æ³•ï¼Œå…¶å€Ÿç”¨ self å¹¶è¿”å›ä¸€ä¸ªå†…éƒ¨æ•°æ®çš„å¼•ç”¨ã€‚ä¸‹ä¾‹åŒ…å«å®šä¹‰äº MyBox ä¹‹ä¸Šçš„ Deref å®ç°ï¼š

```rust

#![allow(unused_variables)]
fn main() {
use std::ops::Deref;

struct MyBox<T>(T);
impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &T {
        &self.0
    }
}
}
```

type Target = T; è¯­æ³•å®šä¹‰äº†ç”¨äºæ­¤ trait çš„å…³è”ç±»å‹ã€‚å…³è”ç±»å‹æ˜¯ä¸€ä¸ªç¨æœ‰ä¸åŒçš„å®šä¹‰æ³›å‹å‚æ•°çš„æ–¹å¼ï¼Œç°åœ¨è¿˜æ— éœ€è¿‡å¤šçš„æ‹…å¿ƒå®ƒï¼›ç¬¬åä¹ç« ä¼šè¯¦ç»†ä»‹ç»ã€‚

deref æ–¹æ³•ä½“ä¸­å†™å…¥äº† &self.0ï¼Œè¿™æ · deref è¿”å›äº†æˆ‘å¸Œæœ›é€šè¿‡ * è¿ç®—ç¬¦è®¿é—®çš„å€¼çš„å¼•ç”¨ã€‚ç¤ºä¾‹ 15-9 ä¸­çš„ main å‡½æ•°ä¸­å¯¹ `MyBox<T>` å€¼çš„ * è°ƒç”¨ç°åœ¨å¯ä»¥ç¼–è¯‘å¹¶èƒ½é€šè¿‡æ–­è¨€äº†ï¼

æ²¡æœ‰ Deref trait çš„è¯ï¼Œç¼–è¯‘å™¨åªä¼šè§£å¼•ç”¨ & å¼•ç”¨ç±»å‹ã€‚deref æ–¹æ³•å‘ç¼–è¯‘å™¨æä¾›äº†è·å–ä»»ä½•å®ç°äº† Deref trait çš„ç±»å‹çš„å€¼å¹¶è°ƒç”¨è¿™ä¸ªç±»å‹çš„ deref æ–¹æ³•æ¥è·å–ä¸€ä¸ªå®ƒçŸ¥é“å¦‚ä½•è§£å¼•ç”¨çš„ & å¼•ç”¨çš„èƒ½åŠ›ã€‚

```rust
*(y.deref())

```

Rust å°† * è¿ç®—ç¬¦æ›¿æ¢ä¸ºå…ˆè°ƒç”¨ deref æ–¹æ³•å†è¿›è¡Œç›´æ¥å¼•ç”¨çš„æ“ä½œï¼Œå¦‚æ­¤ä¾¿ä¸ç”¨æ‹…å¿ƒæ˜¯ä¸æ˜¯è¿˜éœ€è¦æ‰‹åŠ¨è°ƒç”¨ deref æ–¹æ³•äº†ã€‚Rust çš„è¿™ä¸ªç‰¹æ€§å¯ä»¥è®©å†™å‡ºè¡Œä¸ºä¸€è‡´çš„ä»£ç ï¼Œæ— è®ºæ˜¯é¢å¯¹çš„æ˜¯å¸¸è§„å¼•ç”¨è¿˜æ˜¯å®ç°äº† Deref çš„ç±»å‹ã€‚

deref æ–¹æ³•è¿”å›å€¼çš„å¼•ç”¨ï¼Œä»¥åŠ *(y.deref()) æ‹¬å·å¤–è¾¹çš„æ™®é€šè§£å¼•ç”¨ä»ä¸ºå¿…é¡»çš„åŸå› åœ¨äºæ‰€æœ‰æƒã€‚å¦‚æœ deref æ–¹æ³•ç›´æ¥è¿”å›å€¼è€Œä¸æ˜¯å€¼çš„å¼•ç”¨ï¼Œå…¶å€¼ï¼ˆçš„æ‰€æœ‰æƒï¼‰å°†è¢«ç§»å‡º selfã€‚åœ¨è¿™é‡Œä»¥åŠå¤§éƒ¨åˆ†ä½¿ç”¨è§£å¼•ç”¨è¿ç®—ç¬¦çš„æƒ…å†µä¸‹å¹¶ä¸å¸Œæœ›è·å– `MyBox<T>` å†…éƒ¨å€¼çš„æ‰€æœ‰æƒã€‚

æ³¨æ„ï¼Œæ¯æ¬¡å½“åœ¨ä»£ç ä¸­ä½¿ç”¨ * æ—¶ï¼Œ * è¿ç®—ç¬¦éƒ½è¢«æ›¿æ¢æˆäº†å…ˆè°ƒç”¨ deref æ–¹æ³•å†æ¥ç€ä½¿ç”¨ * è§£å¼•ç”¨çš„æ“ä½œï¼Œä¸”åªä¼šå‘ç”Ÿä¸€æ¬¡ï¼Œä¸ä¼šå¯¹ * æ“ä½œç¬¦æ— é™é€’å½’æ›¿æ¢ï¼Œè§£å¼•ç”¨å‡ºä¸Šé¢ i32 ç±»å‹çš„å€¼å°±åœæ­¢äº†ï¼Œè¿™ä¸ªå€¼ä¸ ä¸‹ä¾‹ ä¸­ assert_eq! çš„ 5 ç›¸åŒ¹é…ã€‚

#### å‡½æ•°å’Œæ–¹æ³•çš„éšå¼è§£å¼•ç”¨å¼ºåˆ¶å¤šæ€

è§£å¼•ç”¨å¼ºåˆ¶å¤šæ€ï¼ˆderef coercionsï¼‰æ˜¯ Rust è¡¨ç°åœ¨å‡½æ•°æˆ–æ–¹æ³•ä¼ å‚ä¸Šçš„ä¸€ç§ä¾¿åˆ©ã€‚å…¶å°†å®ç°äº† Deref çš„ç±»å‹çš„å¼•ç”¨è½¬æ¢ä¸ºåŸå§‹ç±»å‹é€šè¿‡ Deref æ‰€èƒ½å¤Ÿè½¬æ¢çš„ç±»å‹çš„å¼•ç”¨ã€‚å½“è¿™ç§ç‰¹å®šç±»å‹çš„å¼•ç”¨ä½œä¸ºå®å‚ä¼ é€’ç»™å’Œå½¢å‚ç±»å‹ä¸åŒçš„å‡½æ•°æˆ–æ–¹æ³•æ—¶ï¼Œè§£å¼•ç”¨å¼ºåˆ¶å¤šæ€å°†è‡ªåŠ¨å‘ç”Ÿã€‚è¿™æ—¶ä¼šæœ‰ä¸€ç³»åˆ—çš„ deref æ–¹æ³•è¢«è°ƒç”¨ï¼ŒæŠŠæä¾›çš„ç±»å‹è½¬æ¢æˆäº†å‚æ•°æ‰€éœ€çš„ç±»å‹ã€‚

è§£å¼•ç”¨å¼ºåˆ¶å¤šæ€çš„åŠ å…¥ä½¿å¾— Rust ç¨‹åºå‘˜ç¼–å†™å‡½æ•°å’Œæ–¹æ³•è°ƒç”¨æ—¶æ— éœ€å¢åŠ è¿‡å¤šæ˜¾å¼ä½¿ç”¨ & å’Œ * çš„å¼•ç”¨å’Œè§£å¼•ç”¨ã€‚è¿™ä¸ªåŠŸèƒ½ä¹Ÿä½¿å¾—å¯ä»¥ç¼–å†™æ›´å¤šåŒæ—¶ä½œç”¨äºå¼•ç”¨æˆ–æ™ºèƒ½æŒ‡é’ˆçš„ä»£ç ã€‚

ä½œä¸ºå±•ç¤ºè§£å¼•ç”¨å¼ºåˆ¶å¤šæ€çš„å®ä¾‹ï¼Œè®©ä½¿ç”¨ä¸Šä¾‹ä¸­å®šä¹‰çš„ `MyBox<T>`ï¼Œä»¥åŠä¸‹ä¾‹ä¸­å¢åŠ çš„ Deref å®ç°ã€‚ä¸‹ä¾‹å±•ç¤ºäº†ä¸€ä¸ªæœ‰ç€å­—ç¬¦ä¸² slice å‚æ•°çš„å‡½æ•°å®šä¹‰ï¼š

```rust

#![allow(unused_variables)]
fn main() {
fn hello(name: &str) {
    println!("Hello, {}!", name);
}
}
```

å¯ä»¥ä½¿ç”¨å­—ç¬¦ä¸² slice ä½œä¸ºå‚æ•°è°ƒç”¨ hello å‡½æ•°ï¼Œæ¯”å¦‚ hello("Rust");ã€‚è§£å¼•ç”¨å¼ºåˆ¶å¤šæ€ä½¿å¾—ç”¨ `MyBox<String>` ç±»å‹å€¼çš„å¼•ç”¨è°ƒç”¨ hello æˆä¸ºå¯èƒ½ï¼Œå¦‚ä¸‹ä¾‹ æ‰€ç¤ºï¼š

```rust
use std::ops::Deref;

struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &T {
        &self.0
    }
}

fn hello(name: &str) {
    println!("Hello, {}!", name);
}

fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&m);
}

```

```rust
use std::ops::Deref;

struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &T {
        &self.0
    }
}

fn hello(name: &str) {
    println!("Hello, {}!", name);
}

fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&(*m)[..]);
}

```

(*m) å°† `MyBox<String>` è§£å¼•ç”¨ä¸º Stringã€‚æ¥ç€ `&` å’Œ `[..]` è·å–äº†æ•´ä¸ª String çš„å­—ç¬¦ä¸² slice æ¥åŒ¹é… hello çš„ç­¾åã€‚æ²¡æœ‰è§£å¼•ç”¨å¼ºåˆ¶å¤šæ€æ‰€æœ‰è¿™äº›ç¬¦å·æ··åœ¨ä¸€èµ·å°†æ›´éš¾ä»¥è¯»å†™å’Œç†è§£ã€‚è§£å¼•ç”¨å¼ºåˆ¶å¤šæ€ä½¿å¾— Rust è‡ªåŠ¨çš„å¸®å¤„ç†è¿™äº›è½¬æ¢ã€‚

å½“æ‰€æ¶‰åŠåˆ°çš„ç±»å‹å®šä¹‰äº† Deref traitï¼ŒRust ä¼šåˆ†æè¿™äº›ç±»å‹å¹¶ä½¿ç”¨ä»»æ„å¤šæ¬¡ Deref::deref è°ƒç”¨ä»¥è·å¾—åŒ¹é…å‚æ•°çš„ç±»å‹ã€‚è¿™äº›è§£æéƒ½å‘ç”Ÿåœ¨ç¼–è¯‘æ—¶ï¼Œæ‰€ä»¥åˆ©ç”¨è§£å¼•ç”¨å¼ºåˆ¶å¤šæ€å¹¶æ²¡æœ‰è¿è¡Œæ—¶æƒ©ç½šï¼

#### è§£å¼•ç”¨å¼ºåˆ¶å¤šæ€å¦‚ä½•ä¸å¯å˜æ€§äº¤äº’

ç±»ä¼¼äºå¦‚ä½•ä½¿ç”¨ Deref trait é‡è½½ä¸å¯å˜å¼•ç”¨çš„ * è¿ç®—ç¬¦ï¼ŒRust æä¾›äº† DerefMut trait ç”¨äºé‡è½½å¯å˜å¼•ç”¨çš„ * è¿ç®—ç¬¦ã€‚

Rust åœ¨å‘ç°ç±»å‹å’Œ trait å®ç°æ»¡è¶³ä¸‰ç§æƒ…å†µæ—¶ä¼šè¿›è¡Œè§£å¼•ç”¨å¼ºåˆ¶å¤šæ€ï¼š

* å½“ `T: Deref<Target=U>` æ—¶ä» &T åˆ° &Uã€‚
* å½“ `T: DerefMut<Target=U>` æ—¶ä» &mut T åˆ° &mut Uã€‚
* å½“ `T: Deref<Target=U>` æ—¶ä» &mut T åˆ° &Uã€‚

å¤´ä¸¤ä¸ªæƒ…å†µé™¤äº†å¯å˜æ€§ä¹‹å¤–æ˜¯ç›¸åŒçš„ï¼šç¬¬ä¸€ç§æƒ…å†µè¡¨æ˜å¦‚æœæœ‰ä¸€ä¸ª &Tï¼Œè€Œ T å®ç°äº†è¿”å› U ç±»å‹çš„ Derefï¼Œåˆ™å¯ä»¥ç›´æ¥å¾—åˆ° &Uã€‚ç¬¬äºŒç§æƒ…å†µè¡¨æ˜å¯¹äºå¯å˜å¼•ç”¨ä¹Ÿæœ‰ç€ç›¸åŒçš„è¡Œä¸ºã€‚

ç¬¬ä¸‰ä¸ªæƒ…å†µæœ‰äº›å¾®å¦™ï¼šRust ä¹Ÿä¼šå°†å¯å˜å¼•ç”¨å¼ºè½¬ä¸ºä¸å¯å˜å¼•ç”¨ã€‚ä½†æ˜¯åä¹‹æ˜¯ ä¸å¯èƒ½ çš„ï¼šä¸å¯å˜å¼•ç”¨æ°¸è¿œä¹Ÿä¸èƒ½å¼ºè½¬ä¸ºå¯å˜å¼•ç”¨ã€‚å› ä¸ºæ ¹æ®å€Ÿç”¨è§„åˆ™ï¼Œå¦‚æœæœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œå…¶å¿…é¡»æ˜¯è¿™äº›æ•°æ®çš„å”¯ä¸€å¼•ç”¨ï¼ˆå¦åˆ™ç¨‹åºå°†æ— æ³•ç¼–è¯‘ï¼‰ã€‚å°†ä¸€ä¸ªå¯å˜å¼•ç”¨è½¬æ¢ä¸ºä¸å¯å˜å¼•ç”¨æ°¸è¿œä¹Ÿä¸ä¼šæ‰“ç ´å€Ÿç”¨è§„åˆ™ã€‚å°†ä¸å¯å˜å¼•ç”¨è½¬æ¢ä¸ºå¯å˜å¼•ç”¨åˆ™éœ€è¦æ•°æ®åªèƒ½æœ‰ä¸€ä¸ªä¸å¯å˜å¼•ç”¨ï¼Œè€Œå€Ÿç”¨è§„åˆ™æ— æ³•ä¿è¯è¿™ä¸€ç‚¹ã€‚å› æ­¤ï¼ŒRust æ— æ³•å‡è®¾å°†ä¸å¯å˜å¼•ç”¨è½¬æ¢ä¸ºå¯å˜å¼•ç”¨æ˜¯å¯èƒ½çš„ã€‚

#### ä½¿ç”¨ Drop Trait è¿è¡Œæ¸…ç†ä»£ç 

å¯¹äºæ™ºèƒ½æŒ‡é’ˆæ¨¡å¼æ¥è¯´ç¬¬äºŒä¸ªé‡è¦çš„ trait æ˜¯ Dropï¼Œå…¶å…è®¸åœ¨å€¼è¦ç¦»å¼€ä½œç”¨åŸŸæ—¶æ‰§è¡Œä¸€äº›ä»£ç ã€‚å¯ä»¥ä¸ºä»»ä½•ç±»å‹æä¾› Drop trait çš„å®ç°ï¼ŒåŒæ—¶æ‰€æŒ‡å®šçš„ä»£ç è¢«ç”¨äºé‡Šæ”¾ç±»ä¼¼äºæ–‡ä»¶æˆ–ç½‘ç»œè¿æ¥çš„èµ„æºã€‚åœ¨æ™ºèƒ½æŒ‡é’ˆä¸Šä¸‹æ–‡ä¸­è®¨è®º Drop æ˜¯å› ä¸ºå…¶åŠŸèƒ½å‡ ä¹æ€»æ˜¯ç”¨äºå®ç°æ™ºèƒ½æŒ‡é’ˆã€‚ä¾‹å¦‚ï¼ŒBox<T> è‡ªå®šä¹‰äº† Drop ç”¨æ¥é‡Šæ”¾ box æ‰€æŒ‡å‘çš„å †ç©ºé—´ã€‚

åœ¨å…¶ä»–ä¸€äº›è¯­è¨€ä¸­ï¼Œä¸å¾—ä¸è®°ä½åœ¨æ¯æ¬¡ä½¿ç”¨å®Œæ™ºèƒ½æŒ‡é’ˆå®ä¾‹åè°ƒç”¨æ¸…ç†å†…å­˜æˆ–èµ„æºçš„ä»£ç ã€‚å¦‚æœå¿˜è®°çš„è¯ï¼Œè¿è¡Œä»£ç çš„ç³»ç»Ÿå¯èƒ½ä¼šå› ä¸ºè´Ÿè·è¿‡é‡è€Œå´©æºƒã€‚åœ¨ Rust ä¸­ï¼Œå¯ä»¥æŒ‡å®šä¸€äº›ä»£ç åº”è¯¥åœ¨å€¼ç¦»å¼€ä½œç”¨åŸŸæ—¶è¢«æ‰§è¡Œï¼Œè€Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨æ’å…¥è¿™äº›ä»£ç ã€‚äºæ˜¯å°±ä¸éœ€è¦åœ¨ç¨‹åºä¸­åˆ°å¤„ç¼–å†™åœ¨å®ä¾‹ç»“æŸæ—¶æ¸…ç†è¿™äº›å˜é‡çš„ä»£ç  â€”â€” è€Œä¸”è¿˜ä¸ä¼šæ³„éœ²èµ„æºã€‚

æŒ‡å®šåœ¨å€¼ç¦»å¼€ä½œç”¨åŸŸæ—¶åº”è¯¥æ‰§è¡Œçš„ä»£ç çš„æ–¹å¼æ˜¯å®ç° Drop traitã€‚Drop trait è¦æ±‚å®ç°ä¸€ä¸ªå«åš drop çš„æ–¹æ³•ï¼Œå®ƒè·å–ä¸€ä¸ª self çš„å¯å˜å¼•ç”¨ã€‚ä¸ºäº†èƒ½å¤Ÿçœ‹å‡º Rust ä½•æ—¶è°ƒç”¨ dropï¼Œè®©æš‚æ—¶ä½¿ç”¨ println! è¯­å¥å®ç° dropã€‚

```rust
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer { data: String::from("my stuff") };
    let d = CustomSmartPointer { data: String::from("other stuff") };
    println!("CustomSmartPointers created.");
}

```

Drop trait åŒ…å«åœ¨ prelude ä¸­ï¼Œæ‰€ä»¥æ— éœ€å¯¼å…¥å®ƒã€‚åœ¨ CustomSmartPointer ä¸Šå®ç°äº† Drop traitï¼Œå¹¶æä¾›äº†ä¸€ä¸ªè°ƒç”¨ println! çš„ drop æ–¹æ³•å®ç°ã€‚drop å‡½æ•°ä½“æ˜¯æ”¾ç½®ä»»ä½•å½“ç±»å‹å®ä¾‹ç¦»å¼€ä½œç”¨åŸŸæ—¶æœŸæœ›è¿è¡Œçš„é€»è¾‘çš„åœ°æ–¹ã€‚è¿™é‡Œé€‰æ‹©æ‰“å°ä¸€äº›æ–‡æœ¬ä»¥å±•ç¤º Rust ä½•æ—¶è°ƒç”¨ dropã€‚

åœ¨ main ä¸­ï¼Œæ–°å»ºäº†ä¸¤ä¸ª CustomSmartPointer å®ä¾‹å¹¶æ‰“å°å‡ºäº† CustomSmartPointer created.ã€‚åœ¨ main çš„ç»“å°¾ï¼ŒCustomSmartPointer çš„å®ä¾‹ä¼šç¦»å¼€ä½œç”¨åŸŸï¼Œè€Œ Rust ä¼šè°ƒç”¨æ”¾ç½®äº drop æ–¹æ³•ä¸­çš„ä»£ç ï¼Œæ‰“å°å‡ºæœ€åçš„ä¿¡æ¯ã€‚æ³¨æ„æ— éœ€æ˜¾ç¤ºè°ƒç”¨ drop æ–¹æ³•ï¼š

#### é€šè¿‡ std::mem::drop ææ—©ä¸¢å¼ƒå€¼

ä¸å¹¸çš„æ˜¯ï¼Œå¹¶ä¸èƒ½ç›´æˆªäº†å½“çš„ç¦ç”¨ drop è¿™ä¸ªåŠŸèƒ½ã€‚é€šå¸¸ä¹Ÿä¸éœ€è¦ç¦ç”¨ drop ï¼›æ•´ä¸ª Drop trait å­˜åœ¨çš„æ„ä¹‰åœ¨äºå…¶æ˜¯è‡ªåŠ¨å¤„ç†çš„ã€‚ç„¶è€Œï¼Œæœ‰æ—¶ä½ å¯èƒ½éœ€è¦ææ—©æ¸…ç†æŸä¸ªå€¼ã€‚ä¸€ä¸ªä¾‹å­æ˜¯å½“ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆç®¡ç†é”æ—¶ï¼›ä½ å¯èƒ½å¸Œæœ›å¼ºåˆ¶è¿è¡Œ drop æ–¹æ³•æ¥é‡Šæ”¾é”ä»¥ä¾¿ä½œç”¨åŸŸä¸­çš„å…¶ä»–ä»£ç å¯ä»¥è·å–é”ã€‚Rust å¹¶ä¸å…è®¸ä¸»åŠ¨è°ƒç”¨ Drop trait çš„ drop æ–¹æ³•ï¼›å½“å¸Œæœ›åœ¨ä½œç”¨åŸŸç»“æŸä¹‹å‰å°±å¼ºåˆ¶é‡Šæ”¾å˜é‡çš„è¯ï¼Œåº”è¯¥ä½¿ç”¨çš„æ˜¯ç”±æ ‡å‡†åº“æä¾›çš„ std::mem::dropã€‚

Rust ä¸å…è®¸æ˜¾å¼è°ƒç”¨ drop å› ä¸º Rust ä»ç„¶ä¼šåœ¨ main çš„ç»“å°¾å¯¹å€¼è‡ªåŠ¨è°ƒç”¨ dropï¼Œè¿™ä¼šå¯¼è‡´ä¸€ä¸ª double free é”™è¯¯ï¼Œå› ä¸º Rust ä¼šå°è¯•æ¸…ç†ç›¸åŒçš„å€¼ä¸¤æ¬¡ã€‚

å› ä¸ºä¸èƒ½ç¦ç”¨å½“å€¼ç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨æ’å…¥çš„ dropï¼Œå¹¶ä¸”ä¸èƒ½æ˜¾ç¤ºè°ƒç”¨ dropï¼Œå¦‚æœéœ€è¦å¼ºåˆ¶ææ—©æ¸…ç†å€¼ï¼Œå¯ä»¥ä½¿ç”¨ std::mem::drop å‡½æ•°ã€‚

std::mem::drop å‡½æ•°ä¸åŒäº Drop trait ä¸­çš„ drop æ–¹æ³•ã€‚å¯ä»¥é€šè¿‡ä¼ é€’å¸Œæœ›ææ—©å¼ºåˆ¶ä¸¢å¼ƒçš„å€¼ä½œä¸ºå‚æ•°ã€‚std::mem::drop ä½äº preludeï¼Œ

```rust
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer { data: String::from("some data") };
    println!("CustomSmartPointer created.");
    drop(c);
    println!("CustomSmartPointer dropped before the end of main.");
}

```

#### Rc<T> å¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆ

å¤§éƒ¨åˆ†æƒ…å†µä¸‹æ‰€æœ‰æƒæ˜¯éå¸¸æ˜ç¡®çš„ï¼šå¯ä»¥å‡†ç¡®åœ°çŸ¥é“å“ªä¸ªå˜é‡æ‹¥æœ‰æŸä¸ªå€¼ã€‚ç„¶è€Œï¼Œæœ‰äº›æƒ…å†µå•ä¸ªå€¼å¯èƒ½ä¼šæœ‰å¤šä¸ªæ‰€æœ‰è€…ã€‚ä¾‹å¦‚ï¼Œåœ¨å›¾æ•°æ®ç»“æ„ä¸­ï¼Œå¤šä¸ªè¾¹å¯èƒ½æŒ‡å‘ç›¸åŒçš„ç»“ç‚¹ï¼Œè€Œè¿™ä¸ªç»“ç‚¹ä»æ¦‚å¿µä¸Šè®²ä¸ºæ‰€æœ‰æŒ‡å‘å®ƒçš„è¾¹æ‰€æ‹¥æœ‰ã€‚ç»“ç‚¹ç›´åˆ°æ²¡æœ‰ä»»ä½•è¾¹æŒ‡å‘å®ƒä¹‹å‰éƒ½ä¸åº”è¯¥è¢«æ¸…ç†ã€‚

ä¸ºäº†å¯ç”¨å¤šæ‰€æœ‰æƒï¼ŒRust æœ‰ä¸€ä¸ªå«åš `Rc<T>` çš„ç±»å‹ã€‚å…¶åç§°ä¸º å¼•ç”¨è®¡æ•°ï¼ˆreference countingï¼‰çš„ç¼©å†™ã€‚å¼•ç”¨è®¡æ•°æ„å‘³ç€è®°å½•ä¸€ä¸ªå€¼å¼•ç”¨çš„æ•°é‡æ¥çŸ¥æ™“è¿™ä¸ªå€¼æ˜¯å¦ä»åœ¨è¢«ä½¿ç”¨ã€‚å¦‚æœæŸä¸ªå€¼æœ‰é›¶ä¸ªå¼•ç”¨ï¼Œå°±ä»£è¡¨æ²¡æœ‰ä»»ä½•æœ‰æ•ˆå¼•ç”¨å¹¶å¯ä»¥è¢«æ¸…ç†ã€‚

å¯ä»¥å°†å…¶æƒ³è±¡ä¸ºå®¢å…ä¸­çš„ç”µè§†ã€‚å½“ä¸€ä¸ªäººè¿›æ¥çœ‹ç”µè§†æ—¶ï¼Œä»–æ‰“å¼€ç”µè§†ã€‚å…¶ä»–äººä¹Ÿå¯ä»¥è¿›æ¥çœ‹ç”µè§†ã€‚å½“æœ€åä¸€ä¸ªäººç¦»å¼€æˆ¿é—´æ—¶ï¼Œä»–å…³æ‰ç”µè§†å› ä¸ºå®ƒä¸å†è¢«ä½¿ç”¨äº†ã€‚å¦‚æœæŸäººåœ¨å…¶ä»–äººè¿˜åœ¨çœ‹çš„æ—¶å€™å°±å…³æ‰äº†ç”µè§†ï¼Œæ­£åœ¨çœ‹ç”µè§†çš„äººè‚¯å®šä¼šæŠ“ç‹‚çš„ï¼

`Rc<T>` ç”¨äºå½“å¸Œæœ›åœ¨å †ä¸Šåˆ†é…ä¸€äº›å†…å­˜ä¾›ç¨‹åºçš„å¤šä¸ªéƒ¨åˆ†è¯»å–ï¼Œè€Œä¸”æ— æ³•åœ¨ç¼–è¯‘æ—¶ç¡®å®šç¨‹åºçš„å“ªä¸€éƒ¨åˆ†ä¼šæœ€åç»“æŸä½¿ç”¨å®ƒçš„æ—¶å€™ã€‚å¦‚æœç¡®å®çŸ¥é“å“ªéƒ¨åˆ†æ˜¯æœ€åä¸€ä¸ªç»“æŸä½¿ç”¨çš„è¯ï¼Œå°±å¯ä»¥ä»¤å…¶æˆä¸ºæ•°æ®çš„æ‰€æœ‰è€…åŒæ—¶ï¼Œæ­£å¸¸çš„æ‰€æœ‰æƒè§„åˆ™å°±å¯ä»¥åœ¨ç¼–è¯‘æ—¶ç”Ÿæ•ˆã€‚

*æ³¨æ„ `Rc<T>` åªèƒ½ç”¨äºå•çº¿ç¨‹åœºæ™¯ï¼›*

##### ä½¿ç”¨ Rc<T> å…±äº«æ•°æ®

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5,
        Box::new(Cons(10,
            Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}

```

ç¼–è¯‘ä¼šå¾—å‡ºå¦‚ä¸‹é”™è¯¯ï¼š

```rust
error[E0382]: use of moved value: `a`
  --> src/main.rs:13:30
   |
12 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
13 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move
   |
   = note: move occurs because `a` has type `List`, which does not implement
   the `Copy` trait

```

Cons æˆå‘˜æ‹¥æœ‰å…¶å‚¨å­˜çš„æ•°æ®ï¼Œæ‰€ä»¥å½“åˆ›å»º b åˆ—è¡¨æ—¶ï¼Œa è¢«ç§»åŠ¨è¿›äº† b è¿™æ · b å°±æ‹¥æœ‰äº† aã€‚æ¥ç€å½“å†æ¬¡å°ä½¿ç”¨ a åˆ›å»º c æ—¶ï¼Œè¿™ä¸è¢«å…è®¸å› ä¸º a çš„æ‰€æœ‰æƒå·²ç»è¢«ç§»åŠ¨ã€‚

å¯ä»¥æ”¹å˜ Cons çš„å®šä¹‰æ¥å­˜æ”¾ä¸€ä¸ªå¼•ç”¨ï¼Œä¸è¿‡æ¥ç€å¿…é¡»æŒ‡å®šç”Ÿå‘½å‘¨æœŸå‚æ•°ã€‚é€šè¿‡æŒ‡å®šç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œè¡¨æ˜åˆ—è¡¨ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ éƒ½è‡³å°‘ä¸åˆ—è¡¨æœ¬èº«å­˜åœ¨çš„ä¸€æ ·ä¹…ã€‚ä¾‹å¦‚ï¼Œå€Ÿç”¨æ£€æŸ¥å™¨ä¸ä¼šå…è®¸ let a = Cons(10, &Nil); ç¼–è¯‘ï¼Œå› ä¸ºä¸´æ—¶å€¼ Nil ä¼šåœ¨ a è·å–å…¶å¼•ç”¨ä¹‹å‰å°±è¢«ä¸¢å¼ƒäº†ã€‚

ç›¸åï¼Œä¿®æ”¹ List çš„å®šä¹‰ä¸ºä½¿ç”¨ Rc<T> ä»£æ›¿ Box<T>ï¼Œå¦‚åˆ—è¡¨ 15-18 æ‰€ç¤ºã€‚ç°åœ¨æ¯ä¸€ä¸ª Cons å˜é‡éƒ½åŒ…å«ä¸€ä¸ªå€¼å’Œä¸€ä¸ªæŒ‡å‘ List çš„ Rcã€‚å½“åˆ›å»º b æ—¶ï¼Œä¸åŒäºè·å– a çš„æ‰€æœ‰æƒï¼Œè¿™é‡Œä¼šå…‹éš† a æ‰€åŒ…å«çš„ Rcï¼Œè¿™ä¼šå°†å¼•ç”¨è®¡æ•°ä» 1 å¢åŠ åˆ° 2 å¹¶å…è®¸ a å’Œ b å…±äº« Rc ä¸­æ•°æ®çš„æ‰€æœ‰æƒã€‚åˆ›å»º c æ—¶ä¹Ÿä¼šå…‹éš† aï¼Œè¿™ä¼šå°†å¼•ç”¨è®¡æ•°ä» 2 å¢åŠ ä¸º 3ã€‚æ¯æ¬¡è°ƒç”¨ Rc::cloneï¼ŒRc ä¸­æ•°æ®çš„å¼•ç”¨è®¡æ•°éƒ½ä¼šå¢åŠ ï¼Œç›´åˆ°æœ‰é›¶ä¸ªå¼•ç”¨ä¹‹å‰å…¶æ•°æ®éƒ½ä¸ä¼šè¢«æ¸…ç†ã€‚

```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&a));
    let c = Cons(4, Rc::clone(&a));
}

```

éœ€è¦ä½¿ç”¨ use è¯­å¥å°† `Rc<T>` å¼•å…¥ä½œç”¨åŸŸï¼Œå› ä¸ºå®ƒä¸åœ¨ prelude ä¸­ã€‚åœ¨ main ä¸­åˆ›å»ºäº†å­˜æ”¾ 5 å’Œ 10 çš„åˆ—è¡¨å¹¶å°†å…¶å­˜æ”¾åœ¨ a çš„æ–°çš„ `Rc<List>`ä¸­ã€‚æ¥ç€å½“åˆ›å»º b å’Œ c æ—¶ï¼Œè°ƒç”¨ Rc::clone å‡½æ•°å¹¶ä¼ é€’ a ä¸­ `Rc<List>` çš„å¼•ç”¨ä½œä¸ºå‚æ•°ã€‚

ä¹Ÿå¯ä»¥è°ƒç”¨ a.clone() è€Œä¸æ˜¯ Rc::clone(&a)ï¼Œä¸è¿‡åœ¨è¿™é‡Œ Rust çš„ä¹ æƒ¯æ˜¯ä½¿ç”¨ Rc::cloneã€‚Rc::clone çš„å®ç°å¹¶ä¸åƒå¤§éƒ¨åˆ†ç±»å‹çš„ clone å®ç°é‚£æ ·å¯¹æ‰€æœ‰æ•°æ®è¿›è¡Œæ·±æ‹·è´ã€‚Rc::clone åªä¼šå¢åŠ å¼•ç”¨è®¡æ•°ï¼Œè¿™å¹¶ä¸ä¼šèŠ±è´¹å¤šå°‘æ—¶é—´ã€‚æ·±æ‹·è´å¯èƒ½ä¼šèŠ±è´¹å¾ˆé•¿æ—¶é—´ã€‚é€šè¿‡ä½¿ç”¨ Rc::clone è¿›è¡Œå¼•ç”¨è®¡æ•°ï¼Œå¯ä»¥æ˜æ˜¾çš„åŒºåˆ«æ·±æ‹·è´ç±»çš„å…‹éš†å’Œå¢åŠ å¼•ç”¨è®¡æ•°ç±»çš„å…‹éš†ã€‚å½“æŸ¥æ‰¾ä»£ç ä¸­çš„æ€§èƒ½é—®é¢˜æ—¶ï¼Œåªéœ€è€ƒè™‘æ·±æ‹·è´ç±»çš„å…‹éš†è€Œæ— éœ€è€ƒè™‘ Rc::clone è°ƒç”¨ã€‚

##### å…‹éš† Rc<T> ä¼šå¢åŠ å¼•ç”¨è®¡æ•°

```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&a));
    let b = Cons(3, Rc::clone(&a));
    println!("count after creating b = {}", Rc::strong_count(&a));
    {
        let c = Cons(4, Rc::clone(&a));
        println!("count after creating c = {}", Rc::strong_count(&a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&a));
}

```

åœ¨ç¨‹åºä¸­æ¯ä¸ªå¼•ç”¨è®¡æ•°å˜åŒ–çš„ç‚¹ï¼Œä¼šæ‰“å°å‡ºå¼•ç”¨è®¡æ•°ï¼Œå…¶å€¼å¯ä»¥é€šè¿‡è°ƒç”¨ Rc::strong_count å‡½æ•°è·å¾—ã€‚è¿™ä¸ªå‡½æ•°å«åš strong_count è€Œä¸æ˜¯ count æ˜¯å› ä¸º `Rc<T>` ä¹Ÿæœ‰ weak_countï¼›åœ¨ â€œé¿å…å¼•ç”¨å¾ªç¯ï¼šå°† `Rc<T>` å˜ä¸º `Weak<T>`â€ éƒ¨åˆ†ä¼šè®²è§£ weak_count çš„ç”¨é€”ã€‚

```
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
```

èƒ½å¤Ÿçœ‹åˆ° a ä¸­ `Rc<List>` çš„åˆå§‹å¼•ç”¨è®¡æ•°ä¸ºä¸€ï¼Œæ¥ç€æ¯æ¬¡è°ƒç”¨ cloneï¼Œè®¡æ•°ä¼šå¢åŠ ä¸€ã€‚å½“ c ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œè®¡æ•°å‡ä¸€ã€‚ä¸å¿…åƒè°ƒç”¨ Rc::clone å¢åŠ å¼•ç”¨è®¡æ•°é‚£æ ·è°ƒç”¨ä¸€ä¸ªå‡½æ•°æ¥å‡å°‘è®¡æ•°ï¼›Drop trait çš„å®ç°å½“ `Rc<T>` å€¼ç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨å‡å°‘å¼•ç”¨è®¡æ•°ã€‚

ä»è¿™ä¸ªä¾‹å­æ‰€ä¸èƒ½çœ‹åˆ°çš„æ˜¯åœ¨ main çš„ç»“å°¾å½“ b ç„¶åæ˜¯ a ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œæ­¤å¤„è®¡æ•°ä¼šæ˜¯ 0ï¼ŒåŒæ—¶ Rc è¢«å®Œå…¨æ¸…ç†ã€‚ä½¿ç”¨ Rc å…è®¸ä¸€ä¸ªå€¼æœ‰å¤šä¸ªæ‰€æœ‰è€…ï¼Œå¼•ç”¨è®¡æ•°åˆ™ç¡®ä¿åªè¦ä»»ä½•æ‰€æœ‰è€…ä¾ç„¶å­˜åœ¨å…¶å€¼ä¹Ÿä¿æŒæœ‰æ•ˆã€‚

é€šè¿‡ä¸å¯å˜å¼•ç”¨ï¼Œ `Rc<T>` å…è®¸åœ¨ç¨‹åºçš„å¤šä¸ªéƒ¨åˆ†ä¹‹é—´åªè¯»åœ°å…±äº«æ•°æ®ã€‚å¦‚æœ `Rc<T>` ä¹Ÿå…è®¸å¤šä¸ªå¯å˜å¼•ç”¨ï¼Œåˆ™ä¼šè¿åç¬¬å››ç« è®¨è®ºçš„å€Ÿç”¨è§„åˆ™ä¹‹ä¸€ï¼šç›¸åŒä½ç½®çš„å¤šä¸ªå¯å˜å€Ÿç”¨å¯èƒ½é€ æˆæ•°æ®ç«äº‰å’Œä¸ä¸€è‡´ã€‚ä¸è¿‡å¯ä»¥ä¿®æ”¹æ•°æ®æ˜¯éå¸¸æœ‰ç”¨çš„ï¼åœ¨ä¸‹ä¸€éƒ¨åˆ†ï¼Œå°†è®¨è®ºå†…éƒ¨å¯å˜æ€§æ¨¡å¼å’Œ `RefCell<T>` ç±»å‹ï¼Œå®ƒå¯ä»¥ä¸ `Rc<T>` ç»“åˆä½¿ç”¨æ¥å¤„ç†ä¸å¯å˜æ€§çš„é™åˆ¶ã€‚

#### RefCell<T> å’Œå†…éƒ¨å¯å˜æ€§æ¨¡å¼

**å†…éƒ¨å¯å˜æ€§ï¼ˆInterior mutabilityï¼‰**æ˜¯ Rust ä¸­çš„ä¸€ä¸ªè®¾è®¡æ¨¡å¼ï¼Œå®ƒå…è®¸ä½ å³ä½¿åœ¨æœ‰ä¸å¯å˜å¼•ç”¨æ—¶æ”¹å˜æ•°æ®ï¼Œè¿™é€šå¸¸æ˜¯å€Ÿç”¨è§„åˆ™æ‰€ä¸å…è®¸çš„ã€‚ä¸ºäº†æ”¹å˜æ•°æ®ï¼Œè¯¥æ¨¡å¼åœ¨æ•°æ®ç»“æ„ä¸­ä½¿ç”¨ unsafe ä»£ç æ¥æ¨¡ç³Š Rust é€šå¸¸çš„å¯å˜æ€§å’Œå€Ÿç”¨è§„åˆ™ã€‚è¿˜æœªè®²åˆ°ä¸å®‰å…¨ä»£ç ï¼›ç¬¬åä¹ç« ä¼šå­¦ä¹ å®ƒä»¬ã€‚å½“å¯ä»¥ç¡®ä¿ä»£ç åœ¨è¿è¡Œæ—¶ä¼šéµå®ˆå€Ÿç”¨è§„åˆ™ï¼Œå³ä½¿ç¼–è¯‘å™¨ä¸èƒ½ä¿è¯çš„æƒ…å†µï¼Œå¯ä»¥é€‰æ‹©ä½¿ç”¨é‚£äº›è¿ç”¨å†…éƒ¨å¯å˜æ€§æ¨¡å¼çš„ç±»å‹ã€‚æ‰€æ¶‰åŠçš„ unsafe ä»£ç å°†è¢«å°è£…è¿›å®‰å…¨çš„ API ä¸­ï¼Œè€Œå¤–éƒ¨ç±»å‹ä»ç„¶æ˜¯ä¸å¯å˜çš„ã€‚

##### é€šè¿‡ RefCell<T> åœ¨è¿è¡Œæ—¶æ£€æŸ¥å€Ÿç”¨è§„åˆ™

ä¸åŒäº `Rc<T>`ï¼Œ`RefCell<T>` ä»£è¡¨å…¶æ•°æ®çš„å”¯ä¸€çš„æ‰€æœ‰æƒã€‚

* åœ¨ä»»æ„ç»™å®šæ—¶é—´ï¼Œåªèƒ½æ‹¥æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨æˆ–ä»»æ„æ•°é‡çš„ä¸å¯å˜å¼•ç”¨ ä¹‹ä¸€ï¼ˆè€Œä¸æ˜¯å…¨éƒ¨ï¼‰ã€‚
* å¼•ç”¨å¿…é¡»æ€»æ˜¯æœ‰æ•ˆçš„ã€‚

å¯¹äºå¼•ç”¨å’Œ `Box<T>`ï¼Œå€Ÿç”¨è§„åˆ™çš„ä¸å¯å˜æ€§ä½œç”¨äºç¼–è¯‘æ—¶ã€‚å¯¹äº `RefCell<T>`ï¼Œè¿™äº›ä¸å¯å˜æ€§ä½œç”¨äº è¿è¡Œæ—¶ã€‚å¯¹äºå¼•ç”¨ï¼Œå¦‚æœè¿åè¿™äº›è§„åˆ™ï¼Œä¼šå¾—åˆ°ä¸€ä¸ªç¼–è¯‘é”™è¯¯ã€‚è€Œå¯¹äº `RefCell<T>`ï¼Œå¦‚æœè¿åè¿™äº›è§„åˆ™ç¨‹åºä¼š panic å¹¶é€€å‡ºã€‚

åœ¨ç¼–è¯‘æ—¶æ£€æŸ¥å€Ÿç”¨è§„åˆ™çš„ä¼˜åŠ¿æ˜¯è¿™äº›é”™è¯¯å°†åœ¨å¼€å‘è¿‡ç¨‹çš„æ—©æœŸè¢«æ•è·åŒæ—¶å¯¹æ²¡æœ‰è¿è¡Œæ—¶æ€§èƒ½å½±å“ï¼Œå› ä¸ºæ‰€æœ‰çš„åˆ†æéƒ½æå‰å®Œæˆäº†ã€‚ä¸ºæ­¤ï¼Œåœ¨ç¼–è¯‘æ—¶æ£€æŸ¥å€Ÿç”¨è§„åˆ™æ˜¯å¤§éƒ¨åˆ†æƒ…å†µçš„æœ€ä½³é€‰æ‹©ï¼Œè¿™ä¹Ÿæ­£æ˜¯å…¶ä¸ºä½•æ˜¯ Rust çš„é»˜è®¤è¡Œä¸ºã€‚

ç›¸ååœ¨è¿è¡Œæ—¶æ£€æŸ¥å€Ÿç”¨è§„åˆ™çš„å¥½å¤„åˆ™æ˜¯å…è®¸å‡ºç°ç‰¹å®šå†…å­˜å®‰å…¨çš„åœºæ™¯ï¼Œè€Œå®ƒä»¬åœ¨ç¼–è¯‘æ—¶æ£€æŸ¥ä¸­æ˜¯ä¸å…è®¸çš„ã€‚é™æ€åˆ†æï¼Œæ­£å¦‚ Rust ç¼–è¯‘å™¨ï¼Œæ˜¯å¤©ç”Ÿä¿å®ˆçš„ã€‚ä½†ä»£ç çš„ä¸€äº›å±æ€§ä¸å¯èƒ½é€šè¿‡åˆ†æä»£ç å‘ç°ï¼šå…¶ä¸­æœ€è‘—åçš„å°±æ˜¯ åœæœºé—®é¢˜ï¼ˆHalting Problemï¼‰ï¼Œè¿™è¶…å‡ºäº†æœ¬ä¹¦çš„èŒƒç•´ï¼Œä¸è¿‡å¦‚æœä½ æ„Ÿå…´è¶£çš„è¯è¿™æ˜¯ä¸€ä¸ªå€¼å¾—ç ”ç©¶çš„æœ‰è¶£ä¸»é¢˜ã€‚

å› ä¸ºä¸€äº›åˆ†ææ˜¯ä¸å¯èƒ½çš„ï¼Œå¦‚æœ Rust ç¼–è¯‘å™¨ä¸èƒ½é€šè¿‡æ‰€æœ‰æƒè§„åˆ™ç¼–è¯‘ï¼Œå®ƒå¯èƒ½ä¼šæ‹’ç»ä¸€ä¸ªæ­£ç¡®çš„ç¨‹åºï¼›ä»è¿™ç§è§’åº¦è€ƒè™‘å®ƒæ˜¯ä¿å®ˆçš„ã€‚å¦‚æœ Rust æ¥å—ä¸æ­£ç¡®çš„ç¨‹åºï¼Œé‚£ä¹ˆç”¨æˆ·ä¹Ÿå°±ä¸ä¼šç›¸ä¿¡ Rust æ‰€åšçš„ä¿è¯äº†ã€‚ç„¶è€Œï¼Œå¦‚æœ Rust æ‹’ç»æ­£ç¡®çš„ç¨‹åºï¼Œè™½ç„¶ä¼šç»™ç¨‹åºå‘˜å¸¦æ¥ä¸ä¾¿ï¼Œä½†ä¸ä¼šå¸¦æ¥ç¾éš¾ã€‚`RefCell<T>` æ­£æ˜¯ç”¨äºå½“ä½ ç¡®ä¿¡ä»£ç éµå®ˆå€Ÿç”¨è§„åˆ™ï¼Œè€Œç¼–è¯‘å™¨ä¸èƒ½ç†è§£å’Œç¡®å®šçš„æ—¶å€™ã€‚

ç±»ä¼¼äº `Rc<T>`ï¼Œ`RefCell<T>` åªèƒ½ç”¨äºå•çº¿ç¨‹åœºæ™¯ã€‚å¦‚æœå°è¯•åœ¨å¤šçº¿ç¨‹ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨ `RefCell<T>`ï¼Œä¼šå¾—åˆ°ä¸€ä¸ªç¼–è¯‘é”™è¯¯ã€‚

å¦‚ä¸‹ä¸ºé€‰æ‹© `Box<T>`ï¼Œ`Rc<T>` æˆ– `RefCell<T>` çš„ç†ç”±ï¼š

* `Rc<T>` å…è®¸ç›¸åŒæ•°æ®æœ‰å¤šä¸ªæ‰€æœ‰è€…ï¼›`Box<T>` å’Œ `RefCell<T>` æœ‰å•ä¸€æ‰€æœ‰è€…ã€‚
* `Box<T>` å…è®¸åœ¨ç¼–è¯‘æ—¶æ‰§è¡Œä¸å¯å˜æˆ–å¯å˜å€Ÿç”¨æ£€æŸ¥ï¼›`Rc<T>`ä»…å…è®¸åœ¨ç¼–è¯‘æ—¶æ‰§è¡Œä¸å¯å˜å€Ÿç”¨æ£€æŸ¥ï¼›`RefCell<T>` å…è®¸åœ¨è¿è¡Œæ—¶æ‰§è¡Œä¸å¯å˜æˆ–å¯å˜å€Ÿç”¨æ£€æŸ¥ã€‚
* å› ä¸º `RefCell<T>` å…è®¸åœ¨è¿è¡Œæ—¶æ‰§è¡Œå¯å˜å€Ÿç”¨æ£€æŸ¥ï¼Œæ‰€ä»¥å¯ä»¥åœ¨å³ä¾¿ `RefCell<T>` è‡ªèº«æ˜¯ä¸å¯å˜çš„æƒ…å†µä¸‹ä¿®æ”¹å…¶å†…éƒ¨çš„å€¼ã€‚
* 
åœ¨ä¸å¯å˜å€¼å†…éƒ¨æ”¹å˜å€¼å°±æ˜¯ å†…éƒ¨å¯å˜æ€§ æ¨¡å¼ã€‚è®©çœ‹çœ‹ä½•æ—¶å†…éƒ¨å¯å˜æ€§æ˜¯æœ‰ç”¨çš„ï¼Œå¹¶è®¨è®ºè¿™æ˜¯å¦‚ä½•æˆä¸ºå¯èƒ½çš„ã€‚

##### å†…éƒ¨å¯å˜æ€§ï¼šä¸å¯å˜å€¼çš„å¯å˜å€Ÿç”¨

å†…éƒ¨å¯å˜æ€§çš„ç”¨ä¾‹ï¼šmock å¯¹è±¡
æµ‹è¯•æ›¿èº«ï¼ˆtest doubleï¼‰æ˜¯ä¸€ä¸ªé€šç”¨ç¼–ç¨‹æ¦‚å¿µï¼Œå®ƒä»£è¡¨ä¸€ä¸ªåœ¨æµ‹è¯•ä¸­æ›¿ä»£æŸä¸ªç±»å‹çš„ç±»å‹ã€‚mock å¯¹è±¡ æ˜¯ç‰¹å®šç±»å‹çš„æµ‹è¯•æ›¿èº«ï¼Œå®ƒä»¬è®°å½•æµ‹è¯•è¿‡ç¨‹ä¸­å‘ç”Ÿäº†ä»€ä¹ˆä»¥ä¾¿å¯ä»¥æ–­è¨€æ“ä½œæ˜¯æ­£ç¡®çš„ã€‚

è™½ç„¶ Rust æ²¡æœ‰ä¸å…¶ä»–è¯­è¨€ä¸­çš„å¯¹è±¡å®Œå…¨ç›¸åŒçš„å¯¹è±¡ï¼ŒRust ä¹Ÿæ²¡æœ‰åƒå…¶ä»–è¯­è¨€é‚£æ ·åœ¨æ ‡å‡†åº“ä¸­å†…å»º mock å¯¹è±¡åŠŸèƒ½ï¼Œä¸è¿‡ç¡®å®å¯ä»¥åˆ›å»ºä¸€ä¸ªä¸ mock å¯¹è±¡æœ‰ç€ç›¸åŒåŠŸèƒ½çš„ç»“æ„ä½“ã€‚

å¦‚ä¸‹æ˜¯ä¸€ä¸ªæƒ³è¦æµ‹è¯•çš„åœºæ™¯ï¼šåœ¨ç¼–å†™ä¸€ä¸ªè®°å½•æŸä¸ªå€¼ä¸æœ€å¤§å€¼çš„å·®è·çš„åº“ï¼Œå¹¶æ ¹æ®å½“å‰å€¼ä¸æœ€å¤§å€¼çš„å·®è·æ¥å‘é€æ¶ˆæ¯ã€‚ä¾‹å¦‚ï¼Œè¿™ä¸ªåº“å¯ä»¥ç”¨äºè®°å½•ç”¨æˆ·æ‰€å…è®¸çš„ API è°ƒç”¨æ•°é‡é™é¢ã€‚

è¯¥åº“åªæä¾›è®°å½•ä¸æœ€å¤§å€¼çš„å·®è·ï¼Œä»¥åŠä½•ç§æƒ…å†µå‘é€ä»€ä¹ˆæ¶ˆæ¯çš„åŠŸèƒ½ã€‚ä½¿ç”¨æ­¤åº“çš„ç¨‹åºåˆ™æœŸæœ›æä¾›å®é™…å‘é€æ¶ˆæ¯çš„æœºåˆ¶ï¼šç¨‹åºå¯ä»¥é€‰æ‹©è®°å½•ä¸€æ¡æ¶ˆæ¯ã€å‘é€ emailã€å‘é€çŸ­ä¿¡ç­‰ç­‰ã€‚åº“æœ¬èº«æ— éœ€çŸ¥é“è¿™äº›ç»†èŠ‚ï¼›åªéœ€å®ç°å…¶æä¾›çš„ Messenger trait å³å¯ã€‚

```rust

#![allow(unused_variables)]
fn main() {
pub trait Messenger {
    fn send(&self, msg: &str);
}

pub struct LimitTracker<'a, T: Messenger> {
    messenger: &'a T,
    value: usize,
    max: usize,
}

impl<'a, T> LimitTracker<'a, T>
    where T: Messenger {
    pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max >= 1.0 {
            self.messenger.send("Error: You are over your quota!");
        } else if percentage_of_max >= 0.9 {
             self.messenger.send("Urgent warning: You've used up over 90% of your quota!");
        } else if percentage_of_max >= 0.75 {
            self.messenger.send("Warning: You've used up over 75% of your quota!");
        }
    }
}
}
```

è¿™äº›ä»£ç ä¸­ä¸€ä¸ªé‡è¦éƒ¨åˆ†æ˜¯æ‹¥æœ‰ä¸€ä¸ªæ–¹æ³• send çš„ Messenger traitï¼Œå…¶è·å–ä¸€ä¸ª self çš„ä¸å¯å˜å¼•ç”¨å’Œæ–‡æœ¬ä¿¡æ¯ã€‚è¿™æ˜¯çš„ mock å¯¹è±¡æ‰€éœ€è¦æ‹¥æœ‰çš„æ¥å£ã€‚å¦ä¸€ä¸ªé‡è¦çš„éƒ¨åˆ†æ˜¯éœ€è¦æµ‹è¯• LimitTracker çš„ set_value æ–¹æ³•çš„è¡Œä¸ºã€‚å¯ä»¥æ”¹å˜ä¼ é€’çš„ value å‚æ•°çš„å€¼ï¼Œä¸è¿‡ set_value å¹¶æ²¡æœ‰è¿”å›ä»»ä½•å¯ä¾›æ–­è¨€çš„å€¼ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœä½¿ç”¨æŸä¸ªå®ç°äº† Messenger trait çš„å€¼å’Œç‰¹å®šçš„ max åˆ›å»º LimitTrackerï¼Œå½“ä¼ é€’ä¸åŒ value å€¼æ—¶ï¼Œæ¶ˆæ¯å‘é€è€…åº”è¢«å‘ŠçŸ¥å‘é€åˆé€‚çš„æ¶ˆæ¯ã€‚

æ‰€éœ€çš„ mock å¯¹è±¡æ˜¯ï¼Œè°ƒç”¨ send ä¸åŒäºå®é™…å‘é€ email æˆ–çŸ­æ¯ï¼Œå…¶åªè®°å½•ä¿¡æ¯è¢«é€šçŸ¥è¦å‘é€äº†ã€‚å¯ä»¥æ–°å»ºä¸€ä¸ª mock å¯¹è±¡ç¤ºä¾‹ï¼Œç”¨å…¶åˆ›å»º LimitTrackerï¼Œè°ƒç”¨ LimitTracker çš„ set_value æ–¹æ³•ï¼Œç„¶åæ£€æŸ¥ mock å¯¹è±¡æ˜¯å¦æœ‰æœŸæœ›çš„æ¶ˆæ¯ã€‚ä¸‹ä¾‹å±•ç¤ºäº†ä¸€ä¸ªå¦‚æ­¤å°è¯•çš„ mock å¯¹è±¡å®ç°ï¼Œä¸è¿‡å€Ÿç”¨æ£€æŸ¥å™¨å¹¶ä¸å…è®¸ï¼š

```rust
#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec<String>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger { sent_messages: vec![] }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}

```

æµ‹è¯•ä»£ç å®šä¹‰äº†ä¸€ä¸ª MockMessenger ç»“æ„ä½“ï¼Œå…¶ sent_messages å­—æ®µä¸ºä¸€ä¸ª String å€¼çš„ Vec ç”¨æ¥è®°å½•è¢«å‘ŠçŸ¥å‘é€çš„æ¶ˆæ¯ã€‚è¿˜å®šä¹‰äº†ä¸€ä¸ªå…³è”å‡½æ•° new ä»¥ä¾¿äºæ–°å»ºä»ç©ºæ¶ˆæ¯åˆ—è¡¨å¼€å§‹çš„ MockMessenger å€¼ã€‚æ¥ç€ä¸º MockMessenger å®ç° Messenger trait è¿™æ ·å°±å¯ä»¥ä¸º LimitTracker æä¾›ä¸€ä¸ª MockMessengerã€‚åœ¨ send æ–¹æ³•çš„å®šä¹‰ä¸­ï¼Œè·å–ä¼ å…¥çš„æ¶ˆæ¯ä½œä¸ºå‚æ•°å¹¶å‚¨å­˜åœ¨ MockMessenger çš„ sent_messages åˆ—è¡¨ä¸­ã€‚

åœ¨æµ‹è¯•ä¸­ï¼Œæµ‹è¯•äº†å½“ LimitTracker è¢«å‘ŠçŸ¥å°† value è®¾ç½®ä¸ºè¶…è¿‡ max å€¼ 75% çš„æŸä¸ªå€¼ã€‚é¦–å…ˆæ–°å»ºä¸€ä¸ª MockMessengerï¼Œå…¶ä»ç©ºæ¶ˆæ¯åˆ—è¡¨å¼€å§‹ã€‚æ¥ç€æ–°å»ºä¸€ä¸ª LimitTracker å¹¶ä¼ é€’æ–°å»º MockMessenger çš„å¼•ç”¨å’Œ max å€¼ 100ã€‚ä½¿ç”¨å€¼ 80 è°ƒç”¨ LimitTracker çš„ set_value æ–¹æ³•ï¼Œè¿™è¶…è¿‡äº† 100 çš„ 75%ã€‚æ¥ç€æ–­è¨€ MockMessenger ä¸­è®°å½•çš„æ¶ˆæ¯åˆ—è¡¨åº”è¯¥æœ‰ä¸€æ¡æ¶ˆæ¯ã€‚

ç„¶è€Œï¼Œè¿™ä¸ªæµ‹è¯•æ˜¯æœ‰é—®é¢˜çš„ï¼š

```rust
error[E0596]: cannot borrow immutable field `self.sent_messages` as mutable
  --> src/lib.rs:52:13
   |
51 |         fn send(&self, message: &str) {
   |                 ----- use `&mut self` here to make mutable
52 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ cannot mutably borrow immutable field

```

ä¸èƒ½ä¿®æ”¹ MockMessenger æ¥è®°å½•æ¶ˆæ¯ï¼Œå› ä¸º send æ–¹æ³•è·å–äº† self çš„ä¸å¯å˜å¼•ç”¨ã€‚ä¹Ÿä¸èƒ½å‚è€ƒé”™è¯¯æ–‡æœ¬çš„å»ºè®®ä½¿ç”¨ &mut self æ›¿ä»£ï¼Œå› ä¸ºè¿™æ · send çš„ç­¾åå°±ä¸ç¬¦åˆ Messenger trait å®šä¹‰ä¸­çš„ç­¾åäº†ï¼ˆå¯ä»¥è¯•ç€è¿™ä¹ˆæ”¹ï¼Œçœ‹çœ‹ä¼šå‡ºç°ä»€ä¹ˆé”™è¯¯ä¿¡æ¯ï¼‰ã€‚

è¿™æ­£æ˜¯å†…éƒ¨å¯å˜æ€§çš„ç”¨æ­¦ä¹‹åœ°ï¼å°†é€šè¿‡ RefCell æ¥å‚¨å­˜ sent_messagesï¼Œç„¶å send å°†èƒ½å¤Ÿä¿®æ”¹ sent_messages å¹¶å‚¨å­˜æ¶ˆæ¯ã€‚

```rust
pub trait Messenger {
    fn send(&self, msg: &str);
}

pub struct LimitTracker<'a, T: Messenger> {
    messenger: &'a T,
    value: usize,
    max: usize,
}

impl<'a, T> LimitTracker<'a, T>
    where T: Messenger {
    pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max >= 1.0 {
            self.messenger.send("Error: You are over your quota!");
        } else if percentage_of_max >= 0.9 {
             self.messenger.send("Urgent warning: You've used up over 90% of your quota!");
        } else if percentage_of_max >= 0.75 {
            self.messenger.send("Warning: You've used up over 75% of your quota!");
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell<Vec<String>>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger { sent_messages: RefCell::new(vec![]) }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);
        limit_tracker.set_value(75);

        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}
fn main() {}

```

ç°åœ¨ sent_messages å­—æ®µçš„ç±»å‹æ˜¯ `RefCell<Vec<String>>` è€Œä¸æ˜¯ `Vec<String>`ã€‚åœ¨ new å‡½æ•°ä¸­æ–°å»ºäº†ä¸€ä¸ª RefCell ç¤ºä¾‹æ›¿ä»£ç©º vectorã€‚

å¯¹äº send æ–¹æ³•çš„å®ç°ï¼Œç¬¬ä¸€ä¸ªå‚æ•°ä»ä¸º self çš„ä¸å¯å˜å€Ÿç”¨ï¼Œè¿™æ˜¯ç¬¦åˆæ–¹æ³•å®šä¹‰çš„ã€‚è°ƒç”¨ self.sent_messages ä¸­ RefCell çš„ borrow_mut æ–¹æ³•æ¥è·å– RefCell ä¸­å€¼çš„å¯å˜å¼•ç”¨ï¼Œè¿™æ˜¯ä¸€ä¸ª vectorã€‚æ¥ç€å¯ä»¥å¯¹ vector çš„å¯å˜å¼•ç”¨è°ƒç”¨ push ä»¥ä¾¿è®°å½•æµ‹è¯•è¿‡ç¨‹ä¸­çœ‹åˆ°çš„æ¶ˆæ¯ã€‚

æœ€åå¿…é¡»åšå‡ºçš„ä¿®æ”¹ä½äºæ–­è¨€ä¸­ï¼šä¸ºäº†çœ‹åˆ°å…¶å†…éƒ¨ vector ä¸­æœ‰å¤šå°‘ä¸ªé¡¹ï¼Œéœ€è¦è°ƒç”¨ RefCell çš„ borrow ä»¥è·å– vector çš„ä¸å¯å˜å¼•ç”¨ã€‚

##### `RefCell<T>` åœ¨è¿è¡Œæ—¶è®°å½•å€Ÿç”¨

å½“åˆ›å»ºä¸å¯å˜å’Œå¯å˜å¼•ç”¨æ—¶ï¼Œåˆ†åˆ«ä½¿ç”¨ & å’Œ &mut è¯­æ³•ã€‚å¯¹äº `RefCell<T>` æ¥è¯´ï¼Œåˆ™æ˜¯ borrow å’Œ borrow_mut æ–¹æ³•ï¼Œè¿™å±äº `RefCell<T>` å®‰å…¨ API çš„ä¸€éƒ¨åˆ†ã€‚borrow æ–¹æ³•è¿”å› Ref ç±»å‹çš„æ™ºèƒ½æŒ‡é’ˆï¼Œborrow_mut æ–¹æ³•è¿”å› RefMut ç±»å‹çš„æ™ºèƒ½æŒ‡é’ˆã€‚è¿™ä¸¤ä¸ªç±»å‹éƒ½å®ç°äº† Derefï¼Œæ‰€ä»¥å¯ä»¥å½“ä½œå¸¸è§„å¼•ç”¨å¯¹å¾…ã€‚

`RefCell<T>` è®°å½•å½“å‰æœ‰å¤šå°‘ä¸ªæ´»åŠ¨çš„ `Ref<T>` å’Œ `RefMut<T>` æ™ºèƒ½æŒ‡é’ˆã€‚æ¯æ¬¡è°ƒç”¨ borrowï¼Œ`RefCell<T>` å°†æ´»åŠ¨çš„ä¸å¯å˜å€Ÿç”¨è®¡æ•°åŠ ä¸€ã€‚å½“ Ref å€¼ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œä¸å¯å˜å€Ÿç”¨è®¡æ•°å‡ä¸€ã€‚å°±åƒç¼–è¯‘æ—¶å€Ÿç”¨è§„åˆ™ä¸€æ ·ï¼Œ`RefCell<T>` åœ¨ä»»ä½•æ—¶å€™åªå…è®¸æœ‰å¤šä¸ªä¸å¯å˜å€Ÿç”¨æˆ–ä¸€ä¸ªå¯å˜å€Ÿç”¨ã€‚

å¦‚æœå°è¯•è¿åè¿™äº›è§„åˆ™ï¼Œç›¸æ¯”å¼•ç”¨æ—¶çš„ç¼–è¯‘æ—¶é”™è¯¯ï¼Œ`RefCell<T>` çš„å®ç°ä¼šåœ¨è¿è¡Œæ—¶ panic!ã€‚ä¸‹ä¾‹å±•ç¤ºäº†å¯¹ä¸Šä¾‹ä¸­ send å®ç°çš„ä¿®æ”¹ï¼Œè¿™é‡Œæ•…æ„å°è¯•åœ¨ç›¸åŒä½œç”¨åŸŸåˆ›å»ºä¸¤ä¸ªå¯å˜å€Ÿç”¨ä»¥ä¾¿æ¼”ç¤º `RefCell<T>` ä¸å…è®¸åœ¨è¿è¡Œæ—¶è¿™ä¹ˆåšï¼š

```rust
impl Messenger for MockMessenger {
    fn send(&self, message: &str) {
        let mut one_borrow = self.sent_messages.borrow_mut();
        let mut two_borrow = self.sent_messages.borrow_mut();

        one_borrow.push(String::from(message));
        two_borrow.push(String::from(message));
    }
}

```

è¿™é‡Œä¸º borrow_mut è¿”å›çš„ RefMut æ™ºèƒ½æŒ‡é’ˆåˆ›å»ºäº† one_borrow å˜é‡ã€‚æ¥ç€ç”¨ç›¸åŒçš„æ–¹å¼åœ¨å˜é‡ two_borrow åˆ›å»ºäº†å¦ä¸€ä¸ªå¯å˜å€Ÿç”¨ã€‚è¿™ä¼šåœ¨ç›¸åŒä½œç”¨åŸŸä¸­åˆ›å»ºä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œè¿™æ˜¯ä¸å…è®¸çš„ã€‚å½“è¿è¡Œåº“çš„æµ‹è¯•æ—¶ï¼Œç¤ºä¾‹ 15-23 ç¼–è¯‘æ—¶ä¸ä¼šæœ‰ä»»ä½•é”™è¯¯ï¼Œä¸è¿‡æµ‹è¯•ä¼šå¤±è´¥ï¼š

```rust
---- tests::it_sends_an_over_75_percent_warning_message stdout ----
	thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at
'already borrowed: BorrowMutError', src/libcore/result.rs:906:4
note: Run with `RUST_BACKTRACE=1` for a backtrace.

```

##### ç»“åˆ `Rc<T>` å’Œ `RefCell<T>` æ¥æ‹¥æœ‰å¤šä¸ªå¯å˜æ•°æ®æ‰€æœ‰è€…

`RefCell<T>` çš„ä¸€ä¸ªå¸¸è§ç”¨æ³•æ˜¯ä¸ `Rc<T>` ç»“åˆã€‚å›å¿†ä¸€ä¸‹ `Rc<T>` å…è®¸å¯¹ç›¸åŒæ•°æ®æœ‰å¤šä¸ªæ‰€æœ‰è€…ï¼Œä¸è¿‡åªèƒ½æä¾›æ•°æ®çš„ä¸å¯å˜è®¿é—®ã€‚å¦‚æœæœ‰ä¸€ä¸ªå‚¨å­˜äº† `RefCell<T>` çš„ `Rc<T>` çš„è¯ï¼Œå°±å¯ä»¥å¾—åˆ°æœ‰å¤šä¸ªæ‰€æœ‰è€… å¹¶ä¸” å¯ä»¥ä¿®æ”¹çš„å€¼äº†ï¼

```rust
#[derive(Debug)]
enum List {
    Cons(Rc<RefCell<i32>>, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&a));
    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&a));

    *value.borrow_mut() += 10;

    println!("a after = {:?}", a);
    println!("b after = {:?}", b);
    println!("c after = {:?}", c);
}

```

#### å¼•ç”¨å¾ªç¯ä¸å†…å­˜æ³„æ¼

Rust çš„å†…å­˜å®‰å…¨ä¿è¯ä½¿å…¶éš¾ä»¥æ„å¤–åœ°åˆ¶é€ æ°¸è¿œä¹Ÿä¸ä¼šè¢«æ¸…ç†çš„å†…å­˜ï¼ˆè¢«ç§°ä¸º å†…å­˜æ³„éœ²ï¼ˆmemory leakï¼‰ï¼‰ï¼Œä½†å¹¶ä¸æ˜¯ä¸å¯èƒ½ã€‚ä¸åœ¨ç¼–è¯‘æ—¶æ‹’ç»æ•°æ®ç«äº‰ä¸åŒï¼Œ Rust å¹¶ä¸ä¿è¯å®Œå…¨åœ°é¿å…å†…å­˜æ³„éœ²ï¼Œè¿™æ„å‘³ç€å†…å­˜æ³„éœ²åœ¨ Rust è¢«è®¤ä¸ºæ˜¯å†…å­˜å®‰å…¨çš„ã€‚è¿™ä¸€ç‚¹å¯ä»¥é€šè¿‡ `Rc<T>` å’Œ `RefCell<T>` çœ‹å‡ºï¼šåˆ›å»ºå¼•ç”¨å¾ªç¯çš„å¯èƒ½æ€§æ˜¯å­˜åœ¨çš„ã€‚è¿™ä¼šé€ æˆå†…å­˜æ³„éœ²ï¼Œå› ä¸ºæ¯ä¸€é¡¹çš„å¼•ç”¨è®¡æ•°æ°¸è¿œä¹Ÿåˆ°ä¸äº† 0ï¼Œå…¶å€¼ä¹Ÿæ°¸è¿œä¹Ÿä¸ä¼šè¢«ä¸¢å¼ƒã€‚

##### åˆ¶é€ å¼•ç”¨å¾ªç¯

```rust
fn main() {}
use std::rc::Rc;
use std::cell::RefCell;
use crate::List::{Cons, Nil};

#[derive(Debug)]
enum List {
    Cons(i32, RefCell<Rc<List>>),
    Nil,
}

impl List {
    fn tail(&self) -> Option<&RefCell<Rc<List>>> {
        match self {
            Cons(_, item) => Some(item),
            Nil => None,
        }
    }
}

```

è¿™é‡Œé‡‡ç”¨äº†ä¸‹ä¾‹ä¸­ List å®šä¹‰çš„å¦ä¸€ç§å˜ä½“ã€‚ç°åœ¨ Cons æˆå‘˜çš„ç¬¬äºŒä¸ªå…ƒç´ æ˜¯ `RefCell<Rc<List>>`ï¼Œè¿™æ„å‘³ç€ä¸åŒäºåƒä¸Šä¾‹é‚£æ ·èƒ½å¤Ÿä¿®æ”¹ i32 çš„å€¼ï¼Œå¸Œæœ›èƒ½å¤Ÿä¿®æ”¹ Cons æˆå‘˜æ‰€æŒ‡å‘çš„ Listã€‚è¿™é‡Œè¿˜å¢åŠ äº†ä¸€ä¸ª tail æ–¹æ³•æ¥æ–¹ä¾¿åœ¨æœ‰ Cons æˆå‘˜çš„æ—¶å€™è®¿é—®å…¶ç¬¬äºŒé¡¹ã€‚

åœ¨ä¸‹ä¾‹ä¸­å¢åŠ äº†ä¸€ä¸ª main å‡½æ•°ï¼Œå…¶ä½¿ç”¨äº†ä¸Šä¾‹ä¸­çš„å®šä¹‰ã€‚è¿™äº›ä»£ç åœ¨ a ä¸­åˆ›å»ºäº†ä¸€ä¸ªåˆ—è¡¨ï¼Œä¸€ä¸ªæŒ‡å‘ a ä¸­åˆ—è¡¨çš„ b åˆ—è¡¨ï¼Œæ¥ç€ä¿®æ”¹ b ä¸­çš„åˆ—è¡¨æŒ‡å‘ a ä¸­çš„åˆ—è¡¨ï¼Œè¿™ä¼šåˆ›å»ºä¸€ä¸ªå¼•ç”¨å¾ªç¯ã€‚åœ¨è¿™ä¸ªè¿‡ç¨‹çš„å¤šä¸ªä½ç½®æœ‰ println! è¯­å¥å±•ç¤ºå¼•ç”¨è®¡æ•°ã€‚

```rust
use crate::List::{Cons, Nil};
use std::rc::Rc;
use std::cell::RefCell;
#[derive(Debug)]
enum List {
    Cons(i32, RefCell<Rc<List>>),
    Nil,
}

impl List {
    fn tail(&self) -> Option<&RefCell<Rc<List>>> {
        match self {
            Cons(_, item) => Some(item),
            Nil => None,
        }
    }
}

fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("a initial rc count = {}", Rc::strong_count(&a));
    println!("a next item = {:?}", a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));

    println!("a rc count after b creation = {}", Rc::strong_count(&a));
    println!("b initial rc count = {}", Rc::strong_count(&b));
    println!("b next item = {:?}", b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&b);
    }

    println!("b rc count after changing a = {}", Rc::strong_count(&b));
    println!("a rc count after changing a = {}", Rc::strong_count(&a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack
    // println!("a next item = {:?}", a.tail());
}

```

è¿™é‡Œåœ¨å˜é‡ a ä¸­åˆ›å»ºäº†ä¸€ä¸ª `Rc<List>` å®ä¾‹æ¥å­˜æ”¾åˆå€¼ä¸º 5, Nil çš„ List å€¼ã€‚æ¥ç€åœ¨å˜é‡ b ä¸­åˆ›å»ºäº†å­˜æ”¾åŒ…å«å€¼ 10 å’ŒæŒ‡å‘åˆ—è¡¨ a çš„ List çš„å¦ä¸€ä¸ª `Rc<List>` å®ä¾‹ã€‚

æœ€åï¼Œä¿®æ”¹ a ä½¿å…¶æŒ‡å‘ b è€Œä¸æ˜¯ Nilï¼Œè¿™å°±åˆ›å»ºäº†ä¸€ä¸ªå¾ªç¯ã€‚ä¸ºæ­¤éœ€è¦ä½¿ç”¨ tail æ–¹æ³•è·å– a ä¸­ `RefCell<Rc<List>>` çš„å¼•ç”¨ï¼Œå¹¶æ”¾å…¥å˜é‡ link ä¸­ã€‚æ¥ç€ä½¿ç”¨ `RefCell<Rc<List>>` çš„ borrow_mut æ–¹æ³•å°†å…¶å€¼ä»å­˜æ”¾ Nil çš„ Rc ä¿®æ”¹ä¸º b ä¸­çš„ `Rc<List>`ã€‚

##### é¿å…å¼•ç”¨å¾ªç¯ï¼šå°† Rc<T> å˜ä¸º Weak<T>

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œå·²ç»å±•ç¤ºäº†è°ƒç”¨ Rc::clone ä¼šå¢åŠ  `Rc<T>` å®ä¾‹çš„ strong_countï¼Œå’Œåªåœ¨å…¶ strong_count ä¸º 0 æ—¶æ‰ä¼šè¢«æ¸…ç†çš„ `Rc<T>` å®ä¾‹ã€‚ä½ ä¹Ÿå¯ä»¥é€šè¿‡è°ƒç”¨ Rc::downgrade å¹¶ä¼ é€’ Rc å®ä¾‹çš„å¼•ç”¨æ¥åˆ›å»ºå…¶å€¼çš„ å¼±å¼•ç”¨ï¼ˆweak referenceï¼‰ã€‚è°ƒç”¨ Rc::downgrade æ—¶ä¼šå¾—åˆ° `Weak<T>` ç±»å‹çš„æ™ºèƒ½æŒ‡é’ˆã€‚ä¸åŒäºå°† `Rc<T>` å®ä¾‹çš„ strong_count åŠ ä¸€ï¼Œè°ƒç”¨ Rc::downgrade ä¼šå°† weak_count åŠ ä¸€ã€‚`Rc<T>` ç±»å‹ä½¿ç”¨ weak_count æ¥è®°å½•å…¶å­˜åœ¨å¤šå°‘ä¸ª `Weak<T>` å¼•ç”¨ï¼Œç±»ä¼¼äº strong_countã€‚å…¶åŒºåˆ«åœ¨äº weak_count æ— éœ€è®¡æ•°ä¸º 0 å°±èƒ½ä½¿ Rc å®ä¾‹è¢«æ¸…ç†ã€‚

å¼ºå¼•ç”¨ä»£è¡¨å¦‚ä½•å…±äº« `Rc<T>` å®ä¾‹çš„æ‰€æœ‰æƒï¼Œä½†å¼±å¼•ç”¨å¹¶ä¸å±äºæ‰€æœ‰æƒå…³ç³»ã€‚ä»–ä»¬ä¸ä¼šé€ æˆå¼•ç”¨å¾ªç¯ï¼Œå› ä¸ºä»»ä½•å¼±å¼•ç”¨çš„å¾ªç¯ä¼šåœ¨å…¶ç›¸å…³çš„å¼ºå¼•ç”¨è®¡æ•°ä¸º 0 æ—¶è¢«æ‰“æ–­ã€‚

å› ä¸º `Weak<T>` å¼•ç”¨çš„å€¼å¯èƒ½å·²ç»è¢«ä¸¢å¼ƒäº†ï¼Œä¸ºäº†ä½¿ç”¨ `Weak<T>` æ‰€æŒ‡å‘çš„å€¼ï¼Œå¿…é¡»ç¡®ä¿å…¶å€¼ä»ç„¶æœ‰æ•ˆã€‚ä¸ºæ­¤å¯ä»¥è°ƒç”¨ `Weak<T>` å®ä¾‹çš„ upgrade æ–¹æ³•ï¼Œè¿™ä¼šè¿”å› `Option<Rc<T>>`ã€‚å¦‚æœ `Rc<T>` å€¼è¿˜æœªè¢«ä¸¢å¼ƒï¼Œåˆ™ç»“æœæ˜¯ Someï¼›å¦‚æœ `Rc<T>` å·²è¢«ä¸¢å¼ƒï¼Œåˆ™ç»“æœæ˜¯ Noneã€‚å› ä¸º upgrade è¿”å›ä¸€ä¸ª `Option<T>`ï¼Œç¡®ä¿¡ Rust ä¼šå¤„ç† Some å’Œ None çš„æƒ…å†µï¼Œæ‰€ä»¥å®ƒä¸ä¼šè¿”å›éæ³•æŒ‡é’ˆã€‚

ä¼šåˆ›å»ºä¸€ä¸ªæŸé¡¹çŸ¥é“å…¶å­é¡¹å’Œçˆ¶é¡¹çš„æ ‘å½¢ç»“æ„çš„ä¾‹å­ï¼Œè€Œä¸æ˜¯åªçŸ¥é“å…¶ä¸‹ä¸€é¡¹çš„åˆ—è¡¨ã€‚

###### åˆ›å»ºæ ‘å½¢æ•°æ®ç»“æ„ï¼šå¸¦æœ‰å­ç»“ç‚¹çš„ Node

```rust

#![allow(unused_variables)]
fn main() {
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell<Vec<Rc<Node>>>,
}
}
```

å¸Œæœ›èƒ½å¤Ÿ Node æ‹¥æœ‰å…¶å­ç»“ç‚¹ï¼ŒåŒæ—¶ä¹Ÿå¸Œæœ›é€šè¿‡å˜é‡æ¥å…±äº«æ‰€æœ‰æƒï¼Œä»¥ä¾¿å¯ä»¥ç›´æ¥è®¿é—®æ ‘ä¸­çš„æ¯ä¸€ä¸ª Nodeï¼Œä¸ºæ­¤ `Vec<T>` çš„é¡¹çš„ç±»å‹è¢«å®šä¹‰ä¸º `Rc<Node>`ã€‚æˆ‘ä»¬è¿˜å¸Œæœ›èƒ½ä¿®æ”¹å…¶ä»–ç»“ç‚¹çš„å­ç»“ç‚¹ï¼Œæ‰€ä»¥ children ä¸­ `Vec<Rc<Node>>` è¢«æ”¾è¿›äº† `RefCell<T>`ã€‚

æ¥ä¸‹æ¥ï¼Œä½¿ç”¨æ­¤ç»“æ„ä½“å®šä¹‰æ¥åˆ›å»ºä¸€ä¸ªå«åš leaf çš„å¸¦æœ‰å€¼ 3 ä¸”æ²¡æœ‰å­ç»“ç‚¹çš„ Node å®ä¾‹ï¼Œå’Œå¦ä¸€ä¸ªå¸¦æœ‰å€¼ 5 å¹¶ä»¥ leaf ä½œä¸ºå­ç»“ç‚¹çš„å®ä¾‹ branchï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```rust
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
   children: RefCell<Vec<Rc<Node>>>,
}

fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });
}

```

```rust
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
   children: RefCell<Vec<Rc<Node>>>,
}

fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });
}

```

è¿™é‡Œå…‹éš†äº† leaf ä¸­çš„ `Rc<Node>` å¹¶å‚¨å­˜åœ¨äº† branch ä¸­ï¼Œè¿™æ„å‘³ç€ leaf ä¸­çš„ Node ç°åœ¨æœ‰ä¸¤ä¸ªæ‰€æœ‰è€…ï¼šleafå’Œbranchã€‚å¯ä»¥é€šè¿‡ branch.children ä» branch ä¸­è·å¾— leafï¼Œä¸è¿‡æ— æ³•ä» leaf åˆ° branchã€‚leaf æ²¡æœ‰åˆ° branch çš„å¼•ç”¨ä¸”å¹¶ä¸çŸ¥é“ä»–ä»¬ç›¸äº’å…³è”ã€‚æˆ‘ä»¬å¸Œæœ› leaf çŸ¥é“ branch æ˜¯å…¶çˆ¶ç»“ç‚¹ã€‚ç¨åæˆ‘ä»¬ä¼šè¿™ä¹ˆåšã€‚

###### å¢åŠ ä»å­åˆ°çˆ¶çš„å¼•ç”¨

ä¸ºäº†ä½¿å­ç»“ç‚¹çŸ¥é“å…¶çˆ¶ç»“ç‚¹ï¼Œéœ€è¦åœ¨ Node ç»“æ„ä½“å®šä¹‰ä¸­å¢åŠ ä¸€ä¸ª parent å­—æ®µã€‚é—®é¢˜æ˜¯ parent çš„ç±»å‹åº”è¯¥æ˜¯ä»€ä¹ˆã€‚æˆ‘ä»¬çŸ¥é“å…¶ä¸èƒ½åŒ…å« `Rc<T>`ï¼Œå› ä¸ºè¿™æ · leaf.parent å°†ä¼šæŒ‡å‘ branch è€Œ branch.children ä¼šåŒ…å« leaf çš„æŒ‡é’ˆï¼Œè¿™ä¼šå½¢æˆå¼•ç”¨å¾ªç¯ï¼Œä¼šé€ æˆå…¶ strong_count æ°¸è¿œä¹Ÿä¸ä¼šä¸º 0.

ç°åœ¨æ¢ä¸€ç§æ–¹å¼æ€è€ƒè¿™ä¸ªå…³ç³»ï¼Œçˆ¶ç»“ç‚¹åº”è¯¥æ‹¥æœ‰å…¶å­ç»“ç‚¹ï¼šå¦‚æœçˆ¶ç»“ç‚¹è¢«ä¸¢å¼ƒäº†ï¼Œå…¶å­ç»“ç‚¹ä¹Ÿåº”è¯¥è¢«ä¸¢å¼ƒã€‚ç„¶è€Œå­ç»“ç‚¹ä¸åº”è¯¥æ‹¥æœ‰å…¶çˆ¶ç»“ç‚¹ï¼šå¦‚æœä¸¢å¼ƒå­ç»“ç‚¹ï¼Œå…¶çˆ¶ç»“ç‚¹åº”è¯¥ä¾ç„¶å­˜åœ¨ã€‚è¿™æ­£æ˜¯å¼±å¼•ç”¨çš„ä¾‹å­ï¼

æ‰€ä»¥ parent ä½¿ç”¨ `Weak<T>` ç±»å‹è€Œä¸æ˜¯ `Rc<T>`ï¼Œå…·ä½“æ¥è¯´æ˜¯ `RefCell<Weak<Node>>`ã€‚ç°åœ¨ Node ç»“æ„ä½“å®šä¹‰çœ‹èµ·æ¥åƒè¿™æ ·ï¼š

```rust

#![allow(unused_variables)]
fn main() {
use std::rc::{Rc, Weak};
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}
}
```

```rust
use std::rc::{Rc, Weak};
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}

fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
}

```

åˆ›å»º leaf ç»“ç‚¹ç±»ä¼¼äºç¤ºä¾‹ 15-27 ä¸­å¦‚ä½•åˆ›å»º leaf ç»“ç‚¹çš„ï¼Œé™¤äº† parent å­—æ®µæœ‰æ‰€ä¸åŒï¼šleaf å¼€å§‹æ—¶æ²¡æœ‰çˆ¶ç»“ç‚¹ï¼Œæ‰€ä»¥æˆ‘ä»¬æ–°å»ºäº†ä¸€ä¸ªç©ºçš„ Weak å¼•ç”¨å®ä¾‹ã€‚

æ­¤æ—¶ï¼Œå½“å°è¯•ä½¿ç”¨ upgrade æ–¹æ³•è·å– leaf çš„çˆ¶ç»“ç‚¹å¼•ç”¨æ—¶ï¼Œä¼šå¾—åˆ°ä¸€ä¸ª None å€¼ã€‚å¦‚ç¬¬ä¸€ä¸ª println! è¾“å‡ºæ‰€ç¤ºï¼š

```rust
leaf parent = None
```

å½“åˆ›å»º branch ç»“ç‚¹æ—¶ï¼Œå…¶ä¹Ÿä¼šæ–°å»ºä¸€ä¸ª `Weak<Node>` å¼•ç”¨ï¼Œå› ä¸º branch å¹¶æ²¡æœ‰çˆ¶ç»“ç‚¹ã€‚leaf ä»ç„¶ä½œä¸º branch çš„ä¸€ä¸ªå­ç»“ç‚¹ã€‚ä¸€æ—¦åœ¨ branch ä¸­æœ‰äº† Node å®ä¾‹ï¼Œå°±å¯ä»¥ä¿®æ”¹ leaf ä½¿å…¶æ‹¥æœ‰æŒ‡å‘çˆ¶ç»“ç‚¹çš„ `Weak<Node>` å¼•ç”¨ã€‚è¿™é‡Œä½¿ç”¨äº† leaf ä¸­ parent å­—æ®µé‡Œçš„ `RefCell<Weak<Node>>` çš„ borrow_mut æ–¹æ³•ï¼Œæ¥ç€ä½¿ç”¨äº† Rc::downgrade å‡½æ•°æ¥ä» branch ä¸­çš„ Rc å€¼åˆ›å»ºäº†ä¸€ä¸ªæŒ‡å‘ branch çš„ `Weak<Node>` å¼•ç”¨ã€‚

å½“å†æ¬¡æ‰“å°å‡º leaf çš„çˆ¶ç»“ç‚¹æ—¶ï¼Œè¿™ä¸€æ¬¡å°†ä¼šå¾—åˆ°å­˜æ”¾äº† branch çš„ Some å€¼ï¼šç°åœ¨ leaf å¯ä»¥è®¿é—®å…¶çˆ¶ç»“ç‚¹äº†ï¼å½“æ‰“å°å‡º leaf æ—¶ï¼Œ

###### å¯è§†åŒ– strong_count å’Œ weak_count çš„æ”¹å˜

é€šè¿‡åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„å†…éƒ¨ä½œç”¨åŸŸå¹¶å°† branch çš„åˆ›å»ºæ”¾å…¥å…¶ä¸­ï¼Œæ¥è§‚å¯Ÿ `Rc<Node>` å®ä¾‹çš„ strong_count å’Œ weak_count å€¼çš„å˜åŒ–ã€‚è¿™ä¼šå±•ç¤ºå½“ branch åˆ›å»ºå’Œç¦»å¼€ä½œç”¨åŸŸè¢«ä¸¢å¼ƒæ—¶ä¼šå‘ç”Ÿä»€ä¹ˆã€‚

```rust
use std::rc::{Rc, Weak};
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}

fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

        println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&branch),
            Rc::weak_count(&branch),
        );

        println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&leaf),
            Rc::weak_count(&leaf),
        );
    }

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );
}

```

ä¸€æ—¦åˆ›å»ºäº† leafï¼Œå…¶ `Rc<Node>` çš„å¼ºå¼•ç”¨è®¡æ•°ä¸º 1ï¼Œå¼±å¼•ç”¨è®¡æ•°ä¸º 0ã€‚åœ¨å†…éƒ¨ä½œç”¨åŸŸä¸­åˆ›å»ºäº† branch å¹¶ä¸ leaf ç›¸å…³è”ï¼Œæ­¤æ—¶ branch ä¸­ `Rc<Node>` çš„å¼ºå¼•ç”¨è®¡æ•°ä¸º 1ï¼Œå¼±å¼•ç”¨è®¡æ•°ä¸º 1ï¼ˆå› ä¸º leaf.parent é€šè¿‡ `Weak<Node>` æŒ‡å‘ branchï¼‰ã€‚è¿™é‡Œ leaf çš„å¼ºå¼•ç”¨è®¡æ•°ä¸º 2ï¼Œå› ä¸ºç°åœ¨ branch çš„ branch.children ä¸­å‚¨å­˜äº† leaf çš„ `Rc<Node>` çš„æ‹·è´ï¼Œä¸è¿‡å¼±å¼•ç”¨è®¡æ•°ä»ç„¶ä¸º 0ã€‚

å½“å†…éƒ¨ä½œç”¨åŸŸç»“æŸæ—¶ï¼Œbranch ç¦»å¼€ä½œç”¨åŸŸï¼Œ`Rc<Node>` çš„å¼ºå¼•ç”¨è®¡æ•°å‡å°‘ä¸º 0ï¼Œæ‰€ä»¥å…¶ Node è¢«ä¸¢å¼ƒã€‚æ¥è‡ª leaf.parent çš„å¼±å¼•ç”¨è®¡æ•° 1 ä¸ Node æ˜¯å¦è¢«ä¸¢å¼ƒæ— å…³ï¼Œæ‰€ä»¥å¹¶æ²¡æœ‰äº§ç”Ÿä»»ä½•å†…å­˜æ³„éœ²ï¼

å¦‚æœåœ¨å†…éƒ¨ä½œç”¨åŸŸç»“æŸåå°è¯•è®¿é—® leaf çš„çˆ¶ç»“ç‚¹ï¼Œä¼šå†æ¬¡å¾—åˆ° Noneã€‚åœ¨ç¨‹åºçš„ç»“å°¾ï¼Œleaf ä¸­ `Rc<Node>` çš„å¼ºå¼•ç”¨è®¡æ•°ä¸º 1ï¼Œå¼±å¼•ç”¨è®¡æ•°ä¸º 0ï¼Œå› ä¸ºç°åœ¨ leaf åˆæ˜¯ `Rc<Node>` å”¯ä¸€çš„å¼•ç”¨äº†ã€‚

æ‰€æœ‰è¿™äº›ç®¡ç†è®¡æ•°å’Œå€¼çš„é€»è¾‘éƒ½å†…å»ºäº `Rc<T>` å’Œ `Weak<T>` ä»¥åŠå®ƒä»¬çš„ Drop trait å®ç°ä¸­ã€‚é€šè¿‡åœ¨ Node å®šä¹‰ä¸­æŒ‡å®šä»å­ç»“ç‚¹åˆ°çˆ¶ç»“ç‚¹çš„å…³ç³»ä¸ºä¸€ä¸ª`Weak<T>`å¼•ç”¨ï¼Œå°±èƒ½å¤Ÿæ‹¥æœ‰çˆ¶ç»“ç‚¹å’Œå­ç»“ç‚¹ä¹‹é—´çš„åŒå‘å¼•ç”¨è€Œä¸ä¼šé€ æˆå¼•ç”¨å¾ªç¯å’Œå†…å­˜æ³„éœ²ã€‚

### æ— ç•å¹¶å‘
