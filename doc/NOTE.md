
# Rustç¬”è®°

[å®˜æ–¹ä¸­æ–‡æ•™ç¨‹](http://120.78.128.153/rustbook/title-page.html)

## Rustå®‰è£…

å¯¹äºLinuxæˆ–è€…macOSï¼Œä½¿ç”¨ç»ˆç«¯å¹¶è¿è¡Œå¦‚ä¸‹å‘½ä»¤ï¼š

```
$ curl https://sh.rustup.rs -sSf | sh
```

å¯¹äºWindowsï¼Œ[å®‰è£…é“¾æ¥](https://www.rust-lang.org/tools/install)ï¼Œä»¥åŠVS2013æˆ–æ›´é«˜ç‰ˆæœ¬çš„C++ç”Ÿæˆå·¥å…·ï¼Œæˆ–è€…ä½¿ç”¨VS2019ç›´æ¥å®‰è£…ã€‚

## ç¬¬ä¸€ä¸ªRustç¨‹åº

```rust
fn main() {
    println!("Hello, world!");
}
```

æ³¨æ„ï¼Œ`println!`è°ƒç”¨Rustå®ã€‚å¦‚æœæ”¹ä¸ºè°ƒç”¨å‡½æ•°ï¼Œåˆ™å°†å…¶è¾“å…¥ä¸º`printlnï¼ˆä¸å¸¦!ï¼‰`

## RuståŒ…ç®¡ç†å™¨Cargo

Cargoæ˜¯Rustçš„æ„å»ºç³»ç»Ÿå’ŒåŒ…ç®¡ç†å™¨ã€‚å¤§å¤šæ•°Rustaceansä½¿ç”¨æ­¤å·¥å…·æ¥ç®¡ç†ä»–ä»¬çš„Rusté¡¹ç›®ï¼Œå› ä¸ºCargoä¼šä¸ºå¤„ç†å¾ˆå¤šä»»åŠ¡ï¼Œä¾‹å¦‚æ„å»ºä»£ç ï¼Œä¸‹è½½ä»£ç æ‰€ä¾èµ–çš„åº“ä»¥åŠæ„å»ºè¿™äº›åº“ã€‚

Cargo.toml

```
[package]
name = "hello_cargo"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]
edition = "2018"

[dependencies]
```

ç¬¬ä¸€è¡Œ`[package]`æ˜¯èŠ‚æ ‡é¢˜ï¼ŒæŒ‡ç¤ºä»¥ä¸‹è¯­å¥æ­£åœ¨é…ç½®ç¨‹åºåŒ…ã€‚å½“å‘è¯¥æ–‡ä»¶æ·»åŠ æ›´å¤šä¿¡æ¯æ—¶ï¼Œå°†æ·»åŠ å…¶ä»–éƒ¨åˆ†ã€‚

æ¥ä¸‹æ¥çš„å››è¡Œè®¾ç½®äº†Cargoç¼–è¯‘ç¨‹åºæ‰€éœ€çš„é…ç½®ä¿¡æ¯ï¼šåç§°ï¼Œç‰ˆæœ¬ï¼Œç¼–å†™è€…ä»¥åŠè¦ä½¿ç”¨çš„Rustç‰ˆæœ¬ã€‚Cargoä»çš„ç¯å¢ƒä¸­è·å–çš„å§“åå’Œç”µå­é‚®ä»¶ä¿¡æ¯ï¼Œå› æ­¤ï¼Œå¦‚æœè¯¥ä¿¡æ¯ä¸æ­£ç¡®ï¼Œè¯·ç«‹å³ä¿®å¤æ­¤ä¿¡æ¯ï¼Œç„¶åä¿å­˜æ–‡ä»¶ã€‚å°†editionåœ¨é™„å½•Eä¸­è®¨è®ºå¯†é’¥ã€‚

æœ€åä¸€è¡Œ`[dependencies]`æ˜¯è¯¥éƒ¨åˆ†çš„å¼€å¤´ï¼Œå¯ä»¥åˆ—å‡ºé¡¹ç›®çš„ä»»ä½•ä¾èµ–é¡¹ã€‚

## Rustç¨‹åºè¿›é˜¶

```rust
use std::io; // æ ‡å‡†åº“

/* ä¸»å‡½æ•°å£°æ˜ */
fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    /* å¯å˜å˜é‡ */
    let mut guess = String::new();

    /* ä¼ å˜é‡çš„å¼•ç”¨ */
    io::stdin().read_line(&mut guess)
        .expect("Failed to read line");  /* std::result::Result */

    /* ä½¿ç”¨println!å ä½ç¬¦æ‰“å°å€¼ */
    println!("You guessed: {}", guess);

    /* å®šä¹‰ä¸å¯å˜å˜é‡ */
    let x = 5;
    let y = 10;

    println!("x = {} and y = {}", x, y);

}
```

æœ€åä½¿ç”¨`cargo run`æŒ‡ä»¤è¿è¡Œç¨‹åºï¼Œä½¿ç”¨`cargo build`æ„å»ºé¡¹ç›®ï¼Œ

**ä½¿ç”¨Cargo.lockæ–‡ä»¶ç¡®ä¿å¯å¤åˆ¶çš„å†…éƒ¨ç‰ˆæœ¬**

Cargoå…·æœ‰ä¸€ç§æœºåˆ¶ï¼Œå¯ç¡®ä¿æˆ–å…¶ä»–ä»»ä½•äººæ¯æ¬¡æ„å»ºä»£ç æ—¶éƒ½å¯ä»¥é‡å»ºç›¸åŒçš„å·¥ä»¶ï¼šCargoå°†ä»…ä½¿ç”¨æŒ‡å®šçš„ä¾èµ–é¡¹ç‰ˆæœ¬ï¼Œé™¤éå¦æœ‰è¯´æ˜ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä¸‹å‘¨å‘å¸ƒçš„ç‰ˆæœ¬ä¸º0.5.6çš„randåŒ…

**äº§ç”Ÿä¸€ä¸ªéšæœºæ•°**

```rust
use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
```

**æ¯”è¾ƒçŒœæµ‹äºç§˜å¯†å·ç **

```rust
use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!("Please input your guess.");

        let mut guess = String::new();

        io::stdin().read_line(&mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}

```

## RuståŸºæœ¬æ¦‚å¿µ

### Rustå˜é‡å’Œå¯å˜æ€§

é»˜è®¤æƒ…å†µä¸‹å˜é‡æ˜¯ä¸å¯å˜çš„ã€‚è¿™æ˜¯Rustæ¨åŠ¨ç¼–å†™ä»£ç çš„ä¸€ç§æ–¹å¼ï¼Œå®ƒå¯ä»¥åˆ©ç”¨Rustæä¾›çš„å®‰å…¨æ€§å’Œæ˜“å¹¶å‘æ€§ã€‚ä½†æ˜¯ï¼Œä»ç„¶å¯ä»¥é€‰æ‹©ä½¿å˜é‡å¯å˜ã€‚è®©æ¢è®¨ä¸€ä¸‹Rustå¦‚ä½•ä»¥åŠä¸ºä»€ä¹ˆé¼“åŠ±æ”¯æŒä¸å˜æ€§ï¼Œä»¥åŠä¸ºä»€ä¹ˆæœ‰æ—¶å¯èƒ½æƒ³è¦é€€å‡ºã€‚

å½“å˜é‡æ˜¯ä¸å¯å˜çš„æ—¶ï¼Œå°†å€¼ç»‘å®šåˆ°åç§°åï¼Œå°±æ— æ³•æ›´æ”¹è¯¥å€¼ã€‚ä¸ºäº†è¯´æ˜è¿™ä¸€ç‚¹ï¼Œä½¿ç”¨æ¥ åœ¨é¡¹ç›®ç›®å½•ä¸­ç”Ÿæˆä¸€ä¸ªåä¸ºå˜é‡çš„æ–°é¡¹ç›®ã€‚

```rust
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    // x = 6;   //error!
    println!("The value of x is: {}", x);
}
```

#### å˜é‡å’Œå¸¸é‡ä¹‹é—´çš„å·®å¼‚

æ— æ³•æ›´æ”¹å˜é‡çš„å€¼å¯èƒ½ä½¿æƒ³èµ·äº†å¤§å¤šæ•°å…¶ä»–è¯­è¨€éƒ½å…·æœ‰çš„å¦ä¸€ä¸ªç¼–ç¨‹æ¦‚å¿µï¼šå¸¸é‡ã€‚åƒä¸å¯å˜å˜é‡ä¸€æ ·ï¼Œå¸¸é‡æ˜¯ç»‘å®šåˆ°åç§°ä¸”ä¸å…è®¸æ›´æ”¹çš„å€¼ï¼Œä½†æ˜¯å¸¸é‡å’Œå˜é‡ä¹‹é—´å­˜åœ¨ä¸€äº›å·®å¼‚ã€‚

é¦–å…ˆï¼Œä¸å…è®¸ä½¿ç”¨`mut`å¸¸é‡ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå¸¸é‡ä¸ä»…æ˜¯ä¸å¯å˜çš„ï¼Œå®ƒä»¬å§‹ç»ˆæ˜¯ä¸å¯å˜çš„ã€‚

å¯ä»¥ä½¿ç”¨`const`å…³é”®å­—è€Œä¸æ˜¯å…³é”®å­—å£°æ˜å¸¸é‡letï¼Œå¹¶ä¸”å€¼çš„ç±»å‹å¿…é¡»å¸¦æœ‰æ³¨é‡Šã€‚

å¯ä»¥åœ¨ä»»ä½•èŒƒå›´ï¼ˆåŒ…æ‹¬å…¨å±€èŒƒå›´ï¼‰ä¸­å£°æ˜å¸¸é‡ï¼Œè¿™ä½¿å®ƒä»¬å¯¹äºè®¸å¤šä»£ç éƒ¨åˆ†éœ€è¦äº†è§£çš„å€¼å¾ˆæœ‰ç”¨ã€‚

æœ€åä¸€ä¸ªåŒºåˆ«æ˜¯ï¼Œåªèƒ½å°†å¸¸é‡è®¾ç½®ä¸ºå¸¸é‡è¡¨è¾¾å¼ï¼Œè€Œä¸æ˜¯å‡½æ•°è°ƒç”¨çš„ç»“æœæˆ–åªèƒ½åœ¨è¿è¡Œæ—¶è®¡ç®—çš„ä»»ä½•å…¶ä»–å€¼ã€‚

è¿™æ˜¯ä¸€ä¸ªå¸¸é‡å£°æ˜çš„ç¤ºä¾‹ï¼Œå…¶ä¸­å¸¸é‡çš„åç§°ä¸º `MAX_POINTS`ï¼Œå…¶å€¼è®¾ç½®ä¸º100,000ã€‚ï¼ˆRustå¸¸é‡çš„å‘½åçº¦å®šæ˜¯ä½¿ç”¨æ‰€æœ‰å¤§å†™å­—æ¯åœ¨å•è¯ä¹‹é—´ä½¿ç”¨ä¸‹åˆ’çº¿ï¼Œå¹¶ä¸”å¯ä»¥åœ¨æ•°å­—æ–‡å­—ä¸­æ’å…¥ä¸‹åˆ’çº¿ä»¥æé«˜å¯è¯»æ€§ï¼‰

```rust
fn main() {
const MAX_POINTS: u32 = 100_000;
}
```

### Rustæ•°æ®ç±»å‹

Rustä¸­çš„æ¯ä¸ªå€¼éƒ½å…·æœ‰ç‰¹å®šçš„æ•°æ®ç±»å‹ï¼Œå®ƒå‘Šè¯‰RustæŒ‡å®šäº†å“ªç§æ•°æ®ï¼Œå› æ­¤çŸ¥é“å¦‚ä½•ä½¿ç”¨è¯¥æ•°æ®ã€‚å°†ç ”ç©¶ä¸¤ä¸ªæ•°æ®ç±»å‹å­é›†ï¼šæ ‡é‡å’Œå¤åˆã€‚

è¯·è®°ä½ï¼ŒRustæ˜¯ä¸€ç§é™æ€ç±»å‹çš„è¯­è¨€ï¼Œè¿™æ„å‘³ç€å®ƒå¿…é¡»åœ¨ç¼–è¯‘æ—¶çŸ¥é“æ‰€æœ‰å˜é‡çš„ç±»å‹ã€‚ç¼–è¯‘å™¨é€šå¸¸å¯ä»¥æ ¹æ®å€¼ä»¥åŠå¦‚ä½•ä½¿ç”¨å®ƒæ¥æ¨æ–­è¦ä½¿ç”¨çš„ç±»å‹ã€‚åœ¨å½“è®¸å¤šç±»å‹æ˜¯å¯èƒ½çš„ï¼Œ

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

#### æ ‡é‡ç±»å‹

æ ‡é‡ç±»å‹è¡¨ç¤ºä¸€ä¸ªå•ä¸€çš„å€¼ã€‚Rustå…·æœ‰å››ç§ä¸»è¦çš„æ ‡é‡ç±»å‹ï¼šæ•´æ•°ï¼Œæµ®ç‚¹æ•°ï¼Œå¸ƒå°”å€¼å’Œå­—ç¬¦ã€‚å¯èƒ½ä¼šä»å…¶ä»–ç¼–ç¨‹è¯­è¨€ä¸­è¯†åˆ«è¿™äº›ã€‚è®©è·³åˆ°ä»–ä»¬åœ¨Rustä¸­çš„å·¥ä½œæ–¹å¼ã€‚

##### æ•´æ•°ç±»å‹

ä¸€ä¸ªæ•´æ•°æ˜¯æ²¡æœ‰å°æ•°éƒ¨åˆ†çš„æ•°ã€‚åœ¨ç¬¬2ç« ä¸­ï¼Œä½¿ç”¨äº†ä¸€ç§æ•´æ•°`u32`ç±»å‹ã€‚æ­¤ç±»å‹å£°æ˜è¡¨ç¤ºä¸ä¹‹å…³è”çš„å€¼åº”ä¸ºå ç”¨32ä½ç©ºé—´çš„æ— ç¬¦å·æ•´æ•°ï¼ˆæœ‰ç¬¦å·æ•´æ•°ç±»å‹ä»¥å¼€å¤´`i`ï¼Œè€Œä¸æ˜¯`u`ï¼‰ã€‚è¡¨3-1æ˜¾ç¤ºäº†Rustä¸­çš„å†…ç½®æ•´æ•°ç±»å‹ã€‚`Signed`å’Œ`Unsigned`åˆ—ä¸­çš„æ¯ä¸ªå˜ä½“ï¼ˆä¾‹å¦‚`i16`ï¼‰éƒ½å¯ä»¥ç”¨æ¥å£°æ˜æ•´æ•°å€¼çš„ç±»å‹ã€‚

é•¿åº¦|	ç¬¦å·|	æ— ç¬¦å·
-|-|-
8ä½|	i8|	u8
16ä½|	i16|	u16
32ä½|	i32|	u32
64ä½|	i64|	u64
128ä½|	i128|	u128

æ¯ä¸ªå˜ä½“å¯ä»¥æ˜¯æœ‰ç¬¦å·çš„ä¹Ÿå¯ä»¥æ˜¯æ— ç¬¦å·çš„ï¼Œå¹¶ä¸”å…·æœ‰æ˜ç¡®çš„å¤§å°ã€‚ å¸¦ç¬¦å·å’Œæ— ç¬¦å·è¡¨ç¤ºæ•°å­—æ˜¯è´Ÿæ•°è¿˜æ˜¯æ­£æ•°ï¼Œæ¢å¥è¯è¯´ï¼Œæ•°å­—æ˜¯å¦éœ€è¦å¸¦æœ‰æ­£è´Ÿå·ï¼ˆå¸¦æ­£è´Ÿå·ï¼‰ï¼Œæˆ–è€…æ•°å­—å°†æ°¸è¿œæ˜¯æ­£æ•°ï¼Œå› æ­¤å¯ä»¥ä¸å¸¦æ­£è´Ÿå·è¡¨ç¤ºï¼ˆæœªç­¾åï¼‰ã€‚è¿™å°±åƒåœ¨çº¸ä¸Šå†™æ•°å­—ä¸€æ ·ï¼šå½“ç¬¦å·å¾ˆé‡è¦æ—¶ï¼Œæ•°å­—ä¸Šä¼šæ˜¾ç¤ºåŠ å·æˆ–å‡å·ã€‚ä½†æ˜¯ï¼Œå¯ä»¥æ”¾å¿ƒåœ°å‡è®¾æ•°å­—ä¸ºæ­£æ•°æ—¶ï¼Œå®ƒä¸ä¼šæ˜¾ç¤ºä»»ä½•ç¬¦å·ã€‚å¸¦ç¬¦å·çš„æ•°å­—ä½¿ç”¨äºŒè¿›åˆ¶è¡¥ç è¡¨ç¤ºå­˜å‚¨ã€‚

æ¯ä¸ªå¸¦ç¬¦å·çš„å˜é‡å¯ä»¥å­˜å‚¨\[-2^{n - 1}\]åˆ°\[ 2^{n-1}-1 \]ä¹‹é—´çš„æ•°å­—ï¼Œå…¶ä¸­næ˜¯å˜é‡ä½¿ç”¨çš„ä½æ•°ã€‚å› æ­¤ï¼Œä¸€ä¸ª `i8`å¯ä»å­˜å‚¨-128è‡³127ï¼Œå…¶ç­‰äº-128åˆ°127æ— ç¬¦å·çš„å˜ä½“å¯ä»¥å­˜å‚¨ä»0ç¼–å·.

æ­¤å¤–ï¼Œ`isize`å’Œ`usize`ç±»å‹å–å†³äºçš„ç¨‹åºæ‰€è¿è¡Œçš„è®¡ç®—æœºç±»å‹ï¼šå¦‚æœä½¿ç”¨çš„æ˜¯64ä½ä½“ç³»ç»“æ„ï¼Œåˆ™ä¸º64ä½ï¼›å¦‚æœä½¿ç”¨çš„æ˜¯32ä½ä½“ç³»ç»“æ„ï¼Œåˆ™ä¸º32ä½ã€‚

æ•°å­—æ–‡å­—|	ä¾‹
-|-
å°æ•°|	`98_222`
åå…­è¿›åˆ¶|	`0xff`
å…«è¿›åˆ¶|	`0o77`
äºŒå…ƒ|	`0b1111_0000`
å­—èŠ‚ï¼ˆ`u8`ï¼‰|	`b'A'`

##### æµ®ç‚¹ç±»å‹

Rustå¯¹äºæµ®ç‚¹æ•°ä¹Ÿæœ‰ä¸¤ç§åŸå§‹ç±»å‹ï¼Œå³å¸¦å°æ•°ç‚¹çš„æ•°å­—ã€‚Rustçš„æµ®ç‚¹ç±»å‹ä¸ºf32å’Œf64ï¼Œå¤§å°åˆ†åˆ«ä¸º32ä½å’Œ64ä½ã€‚é»˜è®¤ç±»å‹æ˜¯f64 å› ä¸ºåœ¨ç°ä»£CPUä¸Šï¼Œå®ƒçš„é€Ÿåº¦ä¸ä¹‹å¤§è‡´ç›¸åŒï¼Œf32ä½†ç²¾åº¦æ›´é«˜ã€‚

##### æ•°å€¼è¿ç®—

Rustæ”¯æŒæœŸæœ›æ‰€æœ‰æ•°å­—ç±»å‹çš„åŸºæœ¬æ•°å­¦è¿ç®—ï¼šåŠ ï¼Œå‡ï¼Œä¹˜ï¼Œé™¤å’Œä½™æ•°ã€‚ä»¥ä¸‹ä»£ç æ˜¾ç¤ºäº†å¦‚ä½•åœ¨letè¯­å¥ä¸­ä½¿ç”¨æ¯ä¸ªä»£ç 

```rust
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;

    // remainder
    let remainder = 43 % 5;
}
```

##### å¸ƒå°”ç±»å‹

ä¸å¤§å¤šæ•°å…¶ä»–ç¼–ç¨‹è¯­è¨€ä¸€æ ·ï¼ŒRustä¸­çš„å¸ƒå°”ç±»å‹å…·æœ‰ä¸¤ä¸ªå¯èƒ½çš„å€¼ï¼štrueå’Œfalseã€‚å¸ƒå°”å€¼çš„å¤§å°ä¸º1ä¸ªå­—èŠ‚ã€‚Rustä¸­çš„å¸ƒå°”ç±»å‹ä½¿ç”¨æŒ‡å®šboolã€‚ä¾‹å¦‚ï¼š

```rust
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
```

##### å­—ç¬¦ç±»å‹

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œä»…å¤„ç†æ•°å­—ï¼Œä½†æ˜¯Rustä¹Ÿæ”¯æŒå­—æ¯ã€‚Rustçš„ charç±»å‹æ˜¯è¯¥è¯­è¨€æœ€åŸå§‹çš„å­—æ¯ç±»å‹ï¼Œä¸‹é¢çš„ä»£ç æ˜¾ç¤ºäº†ä¸€ç§ä½¿ç”¨å®ƒçš„æ–¹å¼ã€‚ï¼ˆè¯·æ³¨æ„ï¼Œcharæ–‡å­—æ˜¯ç”¨å•å¼•å·æŒ‡å®šçš„ï¼Œè€Œå­—ç¬¦ä¸²æ–‡å­—æ˜¯ä½¿ç”¨åŒå¼•å·çš„ã€‚ï¼‰

```rust
fn main() {
    let c = 'z';
    let z = 'â„¤';
    let heart_eyed_cat = 'ğŸ˜»';
}
```

Rustçš„`char`ç±»å‹ä¸º4ä¸ªå­—èŠ‚ï¼Œä»£è¡¨Unicodeæ ‡é‡å€¼ï¼Œè¿™æ„å‘³ç€å®ƒå¯ä»¥ä»£è¡¨çš„ä¸ä»…ä»…æ˜¯ASCIIã€‚é‡éŸ³å­—æ¯ï¼›ä¸­æ–‡ï¼Œæ—¥æ–‡å’ŒéŸ©æ–‡å­—ç¬¦ï¼›è¡¨æƒ…ç¬¦å· å’Œé›¶å®½åº¦ç©ºæ ¼charåœ¨Rust ä¸­éƒ½æ˜¯æœ‰æ•ˆå€¼ã€‚Unicodeæ ‡å€¼çš„èŒƒå›´ä»`U+0000`åˆ° `U+D7FF`å’Œ`U+E000`åˆ°`U+10FFFF`åŒ…å®¹æ€§ã€‚ä½†æ˜¯ï¼Œâ€œå­—ç¬¦â€åœ¨Unicodeä¸­å¹¶ä¸æ˜¯çœŸæ­£çš„æ¦‚å¿µï¼Œå› æ­¤å¯¹â€œå­—ç¬¦â€æ˜¯ä»€ä¹ˆçš„ç›´è§‰å¯èƒ½ä¸`char`Rustä¸­çš„a ä¸ä¸€è‡´ã€‚

##### å¤åˆç±»å‹

å¤åˆç±»å‹å¯ä»¥å°†å¤šä¸ªå€¼ç»„åˆä¸ºä¸€ç§ç±»å‹ã€‚Rustæœ‰ä¸¤ç§åŸå§‹çš„å¤åˆç±»å‹ï¼šå…ƒç»„å’Œæ•°ç»„ã€‚

###### å…ƒç»„ç±»å‹

å…ƒç»„æ˜¯ä¸€ç§å°†å¤šç§ç±»å‹çš„å€¼ç»„åˆä¸ºä¸€ä¸ªå¤åˆç±»å‹çš„ä¸€èˆ¬æ–¹æ³•ã€‚å…ƒç»„çš„é•¿åº¦æ˜¯å›ºå®šçš„ï¼šå£°æ˜åï¼Œå®ƒä»¬çš„å¤§å°å°±æ— æ³•å¢é•¿æˆ–ç¼©å°ã€‚

é€šè¿‡åœ¨æ‹¬å·å†…ç¼–å†™é€—å·åˆ†éš”çš„å€¼åˆ—è¡¨æ¥åˆ›å»ºå…ƒç»„ã€‚å…ƒç»„ä¸­çš„æ¯ä¸ªä½ç½®éƒ½æœ‰ä¸€ä¸ªç±»å‹ï¼Œå¹¶ä¸”å…ƒç»„ä¸­ä¸åŒå€¼çš„ç±»å‹ä¸å¿…ç›¸åŒã€‚åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œæ·»åŠ äº†å¯é€‰çš„ç±»å‹æ³¨é‡Šï¼š

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
    let (x, y, z) = tup;
    println!("The value of y is: {}", y);
}
```

ç¨‹åºé¦–å…ˆåˆ›å»ºä¸€ä¸ªå…ƒç»„å¹¶å°†å…¶ç»‘å®šåˆ°å˜é‡`tup`ã€‚ç„¶åï¼Œå®ƒä½¿ç”¨å¸¦æœ‰`let`é‡‡å–`tup`å¹¶æŠŠå®ƒå˜æˆä¸‰ä¸ªç‹¬ç«‹çš„å˜é‡`x`ï¼Œ`y`å’Œ`z`ã€‚è¿™ç§°ä¸ºè§£æ„ï¼Œå› ä¸ºå®ƒå°†å•ä¸ªå…ƒç»„åˆ†ä¸ºä¸‰éƒ¨åˆ†ã€‚æœ€åï¼Œç¨‹åºå°†è¾“å‡ºçš„å€¼ `y`ï¼Œå³`6.4`ã€‚

é™¤äº†é€šè¿‡æ¨¡å¼åŒ¹é…è¿›è¡Œç»“æ„åˆ†è§£ä¹‹å¤–ï¼Œè¿˜å¯ä»¥é€šè¿‡ä½¿ç”¨å¥ç‚¹ï¼ˆ.ï¼‰å’Œè¦è®¿é—®çš„å€¼çš„ç´¢å¼•ç›´æ¥è®¿é—®å…ƒç»„å…ƒç´ ã€‚ä¾‹å¦‚ï¼š

```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```

###### æ•°ç»„ç±»å‹

æ”¶é›†å¤šä¸ªå€¼çš„å¦ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨æ•°ç»„ã€‚ä¸å…ƒç»„ä¸åŒï¼Œæ•°ç»„çš„æ¯ä¸ªå…ƒç´ éƒ½å¿…é¡»å…·æœ‰ç›¸åŒçš„ç±»å‹ã€‚Rustä¸­çš„æ•°ç»„ä¸æŸäº›å…¶ä»–è¯­è¨€ä¸­çš„æ•°ç»„ä¸åŒï¼Œå› ä¸ºRustä¸­çš„æ•°ç»„å…·æœ‰å›ºå®šé•¿åº¦ï¼Œä¾‹å¦‚å…ƒç»„ã€‚

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

å½“å¸Œæœ›å°†æ•°æ®åˆ†é…åœ¨å †æ ˆè€Œä¸æ˜¯å †ä¸Šæ—¶ï¼ˆå½“åœ¨ç¬¬4ç« ä¸­è®¨è®ºå †æ ˆå’Œå †æ—¶ï¼‰ï¼Œæˆ–è€…è¦ç¡®ä¿å§‹ç»ˆæ‹¥æœ‰å›ºå®šæ•°é‡çš„å…ƒç´ æ—¶ï¼Œæ•°ç»„å¾ˆæœ‰ç”¨ã€‚ä½†æ˜¯ï¼Œæ•°ç»„ä¸åƒçŸ¢é‡ç±»å‹é‚£æ ·çµæ´»ã€‚è½½ä½“æ˜¯ç”±æ ‡å‡†åº“æä¾›ä¸€ä¸ªç±»ä¼¼é›†åˆç±»å‹æ˜¯å…è®¸ç”Ÿé•¿æˆ–å°ºå¯¸çš„ç¼©å°ã€‚å¦‚æœä¸ç¡®å®šä½¿ç”¨æ•°ç»„è¿˜æ˜¯å®¹å™¨ï¼Œåˆ™å¯èƒ½åº”è¯¥ä½¿ç”¨å®¹å™¨ã€‚

ä¸€ä¸ªç¨‹åºå¯èƒ½éœ€è¦ä½¿ç”¨æ•°ç»„è€Œä¸æ˜¯å®¹å™¨ï¼Œä¾‹å¦‚ï¼Œè¯¥ç¨‹åºéœ€è¦çŸ¥é“ä¸€å¹´ä¸­å„ä¸ªæœˆä»½çš„åç§°ã€‚è¿™æ ·çš„ç¨‹åºä¸å¤ªå¯èƒ½éœ€è¦æ·»åŠ æˆ–åˆ é™¤æœˆä»½ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨æ•°ç»„ï¼Œå› ä¸ºçŸ¥é“å®ƒå°†å§‹ç»ˆåŒ…å«12ä¸ªå…ƒç´ ï¼š

```rust

#![allow(unused_variables)]
fn main() {
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
}
```

å°†ä½¿ç”¨æ–¹æ‹¬å·ç¼–å†™æ•°ç»„çš„ç±»å‹ï¼Œå¹¶ä¸”åœ¨æ–¹æ‹¬å·å†…åŒ…æ‹¬æ¯ä¸ªå…ƒç´ çš„ç±»å‹ï¼Œåˆ†å·ï¼Œç„¶åæ˜¯æ•°ç»„ä¸­å…ƒç´ çš„æ•°é‡ï¼Œå¦‚ä¸‹æ‰€ç¤º

```rust

#![allow(unused_variables)]
fn main() {
let a: [i32; 5] = [1, 2, 3, 4, 5];
}
```

åœ¨è¿™é‡Œï¼Œ`i32`æ˜¯æ¯ä¸ªå…ƒç´ çš„ç±»å‹ã€‚åˆ†å·åçš„æ•°å­—`5` è¡¨ç¤ºæ•°ç»„åŒ…å«äº”ä¸ªå…ƒç´ ã€‚

ä»¥è¿™ç§æ–¹å¼ç¼–å†™æ•°ç»„çš„ç±»å‹çœ‹èµ·æ¥ç±»ä¼¼äºåˆå§‹åŒ–æ•°ç»„çš„å¦ä¸€ç§è¯­æ³•ï¼šå¦‚æœè¦åˆ›å»ºä¸€ä¸ªæ•°ç»„ï¼Œè¯¥æ•°ç»„çš„æ¯ä¸ªå…ƒç´ éƒ½åŒ…å«ç›¸åŒçš„å€¼ï¼Œåˆ™å¯ä»¥æŒ‡å®šåˆå§‹å€¼ï¼Œåè·Ÿä¸€ä¸ªåˆ†å·ï¼Œç„¶åæŒ‡å®šé•¿åº¦æ•°ç»„æ”¾åœ¨æ–¹æ‹¬å·ä¸­ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```rust

#![allow(unused_variables)]
fn main() {
let a = [3; 5];
}
```

åä¸ºçš„æ•°ç»„`a`å°†åŒ…å«`5`å°†å…¨éƒ¨è®¾ç½®ä¸º`3`åˆå§‹å€¼çš„å…ƒç´  ã€‚è¿™ä¸å†™ä½œç›¸åŒï¼Œ`let a = [3, 3, 3, 3, 3]`;ä½†æ›´ä¸ºç®€æ´ã€‚

###### è®¿é—®æ•°ç»„å…ƒç´ 

æ•°ç»„æ˜¯åœ¨å †æ ˆä¸Šåˆ†é…çš„å•ä¸ªå†…å­˜å—ã€‚å¯ä»¥ä½¿ç”¨ç´¢å¼•è®¿é—®æ•°ç»„çš„å…ƒç´ ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}

```

åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œåä¸ºçš„å˜é‡`first`å°†è·å¾—å€¼`1`ï¼Œå› ä¸ºè¿™æ˜¯`[0]`æ•°ç»„ä¸­indexå¤„çš„å€¼ã€‚åä¸ºçš„å˜é‡`second`å°†ä»æ•°ç»„ä¸­çš„`2`ç´¢å¼•è·å–å€¼`[1]`ã€‚

### Rustå‡½æ•°

Rustä»£ç ä¸­æ™®éå­˜åœ¨å‡½æ•°ã€‚å·²ç»çœ‹åˆ°äº†è¯¥è¯­è¨€ä¸­æœ€é‡è¦çš„åŠŸèƒ½ä¹‹ä¸€ï¼šmainå‡½æ•°ï¼Œå®ƒæ˜¯è®¸å¤šç¨‹åºçš„å…¥å£ç‚¹ã€‚è¿˜çœ‹åˆ°äº†fnå…³é”®å­—ï¼Œè¯¥å…³é”®å­—ä½¿å¯ä»¥å£°æ˜æ–°åŠŸèƒ½ã€‚

Rustä»£ç ä½¿ç”¨è›‡å½¢å¤§å°å†™ä½œä¸ºå‡½æ•°å’Œå˜é‡åçš„å¸¸è§„æ ·å¼ã€‚åœ¨è›‡å½¢çš„æƒ…å†µä¸‹ï¼Œæ‰€æœ‰å­—æ¯å‡ä¸ºå°å†™ï¼Œå¹¶åœ¨ä¸‹åˆ’çº¿åˆ†å¼€å•è¯ã€‚è¿™æ˜¯ä¸€ä¸ªåŒ…å«ç¤ºä¾‹å‡½æ•°å®šä¹‰çš„ç¨‹åºï¼š

```rust
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}

```

Rustä¸­çš„å‡½æ•°å®šä¹‰ä»¥`fn`å‡½æ•°åç§°å¼€å¤´ï¼Œå¹¶åœ¨å‡½æ•°åç§°åå¸¦æœ‰ä¸€ç»„æ‹¬å·ã€‚å¤§æ‹¬å·å‘Šè¯‰ç¼–è¯‘å™¨å‡½æ•°ä½“çš„å¼€å§‹å’Œç»“æŸä½ç½®ã€‚

å¯ä»¥è°ƒç”¨å®šä¹‰çš„ä»»ä½•å‡½æ•°ï¼Œæ–¹æ³•æ˜¯è¾“å…¥å…¶åç§°ï¼Œç„¶åè¾“å…¥ä¸€ç»„æ‹¬å·ã€‚å› ä¸º`another_function`æ˜¯åœ¨ç¨‹åºä¸­å®šä¹‰çš„ï¼Œæ‰€ä»¥å¯ä»¥ä»`main`å‡½æ•°å†…éƒ¨è°ƒç”¨å®ƒã€‚æ³¨æ„ï¼Œåœ¨æºä»£ç ä¸­çš„å‡½æ•°`another_function` ä¹‹åå®šä¹‰`main`ï¼›æœ¬æ¥ä¹Ÿå¯ä»¥å®šä¹‰å®ƒã€‚Rustä¸åœ¨ä¹åœ¨ä½•å¤„å®šä¹‰å‡½æ•°ï¼Œåªéœ€åœ¨æŸä¸ªåœ°æ–¹å®šä¹‰å®ƒä»¬å³å¯ã€‚

è®©å¼€å§‹ä¸€ä¸ªæ–°çš„åä¸ºå‡½æ•°çš„äºŒè¿›åˆ¶é¡¹ç›®ï¼Œä»¥è¿›ä¸€æ­¥æ¢ç´¢å‡½æ•°ã€‚å°†another_functionç¤ºä¾‹æ”¾åœ¨src / main.rsä¸­å¹¶è¿è¡Œå®ƒã€‚åº”è¯¥çœ‹åˆ°ä»¥ä¸‹è¾“å‡ºï¼š

#### å‡½æ•°å‚æ•°

ä¹Ÿå¯ä»¥å°†å‡½æ•°å®šä¹‰ä¸ºå…·æœ‰parametersï¼Œparametersæ˜¯ä½œä¸ºå‡½æ•°ç­¾åä¸€éƒ¨åˆ†çš„ç‰¹æ®Šå˜é‡ã€‚å½“å‡½æ•°å…·æœ‰å‚æ•°æ—¶ï¼Œå¯ä»¥ä¸ºå…¶æä¾›è¿™äº›å‚æ•°çš„å…·ä½“å€¼ã€‚ä»æŠ€æœ¯ä¸Šè®²ï¼Œå…·ä½“å€¼ç§°ä¸ºè‡ªå˜é‡ï¼Œä½†æ˜¯åœ¨éšæ„çš„äº¤è°ˆä¸­ï¼Œäººä»¬å€¾å‘äºå°†å‚æ•°å’Œè‡ªå˜é‡ä¸€è¯äº¤æ›¿ç”¨äºå‡½æ•°å®šä¹‰ä¸­çš„å˜é‡æˆ–è°ƒç”¨å‡½æ•°æ—¶ä¼ é€’çš„å…·ä½“å€¼ã€‚

ä»¥ä¸‹é‡å†™çš„ç‰ˆæœ¬`another_function`æ˜¾ç¤ºäº†Rustä¸­çš„å‚æ•°ï¼š

```rust
fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("The value of x is: {}", x);
}

```

å½“å¸Œæœ›ä¸€ä¸ªå‡½æ•°å…·æœ‰å¤šä¸ªå‚æ•°æ—¶ï¼Œè¯·ç”¨é€—å·åˆ†éš”å‚æ•°å£°æ˜ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```rust
fn main() {
    another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
    println!("The value of x is: {}", x);
    println!("The value of y is: {}", y);
}
```

#### å‡½æ•°å®ä½“åŒ…å«è¯­å¥å’Œè¡¨è¾¾å¼

å‡½æ•°ä½“ç”±ä¸€ç³»åˆ—å¯é€‰åœ°ä»¥è¡¨è¾¾å¼ç»“å°¾çš„è¯­å¥ç»„æˆã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼Œä»…ä»‹ç»äº†æ²¡æœ‰ç»“å°¾è¡¨è¾¾å¼çš„å‡½æ•°ï¼Œä½†æ˜¯å·²ç»å°†è¡¨è¾¾å¼è§†ä¸ºè¯­å¥çš„ä¸€éƒ¨åˆ†ã€‚ç”±äºRustæ˜¯ä¸€ç§åŸºäºè¡¨è¾¾å¼çš„è¯­è¨€ï¼Œå› æ­¤è¿™æ˜¯éœ€è¦ç†è§£çš„é‡è¦åŒºåˆ«ã€‚å…¶ä»–è¯­è¨€æ²¡æœ‰ç›¸åŒçš„åŒºåˆ«ï¼Œå› æ­¤è®©çœ‹çœ‹ä»€ä¹ˆæ˜¯è¯­å¥å’Œè¡¨è¾¾å¼ä»¥åŠå®ƒä»¬çš„å·®å¼‚å¦‚ä½•å½±å“å‡½æ•°ä½“ã€‚

å®é™…ä¸Šå·²ç»ä½¿ç”¨è¿‡è¯­å¥å’Œè¡¨è¾¾å¼ã€‚è¯­å¥æ˜¯æ‰§è¡ŒæŸäº›æ“ä½œä¸”ä¸è¿”å›å€¼çš„æŒ‡ä»¤ã€‚è¡¨è¾¾å¼çš„ è®¡ç®—ç»“æœä¸ºç»“æœå€¼ã€‚è®©çœ‹ä¸€äº›ä¾‹å­ã€‚

åˆ›å»ºå˜é‡å¹¶ä½¿ç”¨`let`å…³é”®å­—ä¸ºå…¶åˆ†é…å€¼æ˜¯ä¸€æ¡è¯­å¥ã€‚

```rust
fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
```

æ˜¯åœ¨è¿™ç§æƒ…å†µä¸‹æ±‚å€¼ä¸ºçš„å—`4`ã€‚è¯¥å€¼ç»‘å®š`y` ä¸º`let`è¯­å¥çš„ä¸€éƒ¨åˆ†ã€‚è¯·æ³¨æ„ï¼Œè¯¥`x + 1`è¡Œçš„æœ«å°¾æ²¡æœ‰åˆ†å·ï¼Œè¿™ä¸åˆ°ç›®å‰ä¸ºæ­¢æ‰€çœ‹åˆ°çš„å¤§å¤šæ•°è¡Œä¸åŒã€‚è¡¨è¾¾å¼ä¸åŒ…æ‹¬ç»“å°¾åˆ†å·ã€‚å¦‚æœåœ¨è¡¨è¾¾å¼çš„æœ«å°¾æ·»åŠ åˆ†å·ï¼Œåˆ™å°†å…¶å˜æˆä¸€æ¡è¯­å¥ï¼Œç„¶åè¯¥è¯­å¥å°†ä¸è¿”å›å€¼ã€‚åœ¨æ¥ä¸‹æ¥æ¢ç´¢å‡½æ•°è¿”å›å€¼å’Œè¡¨è¾¾å¼æ—¶ï¼Œè¯·è®°ä½è¿™ä¸€ç‚¹ã€‚

#### å…·æœ‰è¿”å›å€¼çš„å‡½æ•°

å‡½æ•°å¯ä»¥å°†å€¼è¿”å›åˆ°è°ƒç”¨å®ƒä»¬çš„ä»£ç ä¸­ã€‚æ²¡æœ‰å‘½åè¿”å›å€¼ï¼Œä½†ç¡®å®åœ¨ç®­å¤´ï¼ˆ`->`ï¼‰åå£°æ˜äº†å®ƒä»¬çš„ç±»å‹ã€‚åœ¨Rustä¸­ï¼Œå‡½æ•°çš„è¿”å›å€¼ä¸å‡½æ•°ä¸»ä½“å—ä¸­æœ€ç»ˆè¡¨è¾¾å¼çš„å€¼åŒä¹‰ã€‚å¯ä»¥é€šè¿‡ä½¿ç”¨`return`å…³é”®å­—å¹¶æŒ‡å®šå€¼ä»å‡½æ•°ä¸­æå‰è¿”å›ï¼Œä½†æ˜¯å¤§å¤šæ•°å‡½æ•°éƒ½éšå¼è¿”å›æœ€åä¸€ä¸ªè¡¨è¾¾å¼ã€‚è¿™æ˜¯ä¸€ä¸ªè¿”å›å€¼çš„å‡½æ•°çš„ç¤ºä¾‹ï¼š

```rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}

```

å‡½æ•°ä¸­æ²¡æœ‰å‡½æ•°è°ƒç”¨ï¼Œå®ç”šè‡³`let`è¯­å¥ï¼Œ`five` ä»…æ˜¯æ•°å­—`5`æœ¬èº«ã€‚åœ¨Rustä¸­ï¼Œè¿™æ˜¯ä¸€ä¸ªéå¸¸æœ‰æ•ˆçš„å‡½æ•°ã€‚è¯·æ³¨æ„ï¼Œå‡½æ•°çš„è¿”å›ç±»å‹ä¹ŸæŒ‡å®šä¸º`-> i32`.

### Rustæ³¨é‡Š

æ‰€æœ‰ç¨‹åºå‘˜éƒ½åŠªåŠ›ä½¿ä»–ä»¬çš„ä»£ç æ˜“äºç†è§£ï¼Œä½†æ˜¯æœ‰æ—¶éœ€è¦é¢å¤–çš„è¯´æ˜ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç¨‹åºå‘˜åœ¨å…¶æºä»£ç ä¸­ç•™ä¸‹æ³¨é‡Šæˆ– æ³¨é‡Šï¼Œç¼–è¯‘å™¨å°†å¿½ç•¥å®ƒä»¬ï¼Œä½†é˜…è¯»æºä»£ç çš„äººå¯èƒ½ä¼šå‘ç°æœ‰ç”¨ã€‚

è¿™æ˜¯ä¸€ä¸ªç®€å•çš„æ³¨é‡Šï¼š

```rust

#![allow(unused_variables)]
fn main() {
// hello, world
}
```

### Rustæ§åˆ¶æµ

ä¸€ç§`if`è¡¨è¾¾å¼å…è®¸åˆ†æ”¯æ ¹æ®æ¡ä»¶çš„ä»£ç ã€‚æä¾›ä¸€ä¸ªæ¡ä»¶ï¼Œç„¶åè¯´ï¼šâ€œå¦‚æœæ»¡è¶³æ­¤æ¡ä»¶ï¼Œè¯·è¿è¡Œæ­¤ä»£ç å—ã€‚å¦‚æœä¸æ»¡è¶³æ¡ä»¶ï¼Œè¯·ä¸è¦è¿è¡Œæ­¤ä»£ç å—ã€‚â€

```rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
```

å¯é€‰åœ°ï¼Œè¿˜å¯ä»¥åŒ…æ‹¬ä¸€ä¸ª`else`è¡¨è¾¾å¼ï¼Œåœ¨æ­¤å¤„é€‰æ‹©äº†è¯¥è¡¨è¾¾å¼ï¼Œä»¥åœ¨æ¡ä»¶è¯„ä¼°ä¸ºfalseæ—¶ä¸ºç¨‹åºæä¾›æ›¿ä»£çš„ä»£ç å—æ¥æ‰§è¡Œã€‚å¦‚æœä¸æä¾›`else`è¡¨è¾¾å¼ä¸”æ¡ä»¶ä¸ºå‡ï¼Œåˆ™ç¨‹åºå°†è·³è¿‡è¯¥ifå—å¹¶ç»§ç»­æ‰§è¡Œä¸‹ä¸€éƒ¨åˆ†ä»£ç ã€‚

```rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```

#### ä½¿ç”¨ifçš„letè¯­å¥

å› ä¸ºifæ˜¯è¡¨è¾¾å¼ï¼Œæ‰€ä»¥å¯ä»¥åœ¨let è¯­å¥çš„å³ä¾§ä½¿ç”¨å®ƒï¼Œ

```rust
fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    println!("The value of number is: {}", number);
}
```

#### å¾ªç¯é‡å¤

`loop`,`while`,`for`

```rust
fn main() {
    loop {
        println!("again!");
    }
}
```

##### ä»å¾ªç¯è¿”å›å€¼

açš„ç”¨é€”ä¹‹ä¸€loopæ˜¯é‡è¯•çŸ¥é“å¯èƒ½ä¼šå¤±è´¥çš„æ“ä½œï¼Œä¾‹å¦‚æ£€æŸ¥çº¿ç¨‹æ˜¯å¦å·²å®Œæˆå…¶å·¥ä½œã€‚ä½†æ˜¯ï¼Œå¯èƒ½éœ€è¦å°†è¯¥æ“ä½œçš„ç»“æœä¼ é€’ç»™å…¶ä½™ä»£ç ã€‚ä¸ºæ­¤ï¼Œå¯ä»¥åœ¨breakåœæ­¢å¾ªç¯çš„è¡¨è¾¾å¼åæ·»åŠ è¦è¿”å›çš„å€¼ã€‚è¯¥å€¼å°†ä»å¾ªç¯ä¸­è¿”å›ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨å®ƒï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}
```

##### æœ‰æ¡ä»¶å¾ªç¯ while

å¯¹äºç¨‹åºè€Œè¨€ï¼Œåœ¨å¾ªç¯ä¸­è¯„ä¼°æ¡ä»¶é€šå¸¸å¾ˆæœ‰ç”¨ã€‚å½“æ¡ä»¶ä¸ºçœŸæ—¶ï¼Œå¾ªç¯è¿è¡Œã€‚å½“æ¡ä»¶ä¸å†ä¸ºçœŸæ—¶ï¼Œç¨‹åºå°†è°ƒç”¨breakï¼Œä»è€Œåœæ­¢å¾ªç¯ã€‚è¿™ä¸ªç¯å‹å¯ä½¿ç”¨çš„ç»„åˆæ¥å®ç°loopï¼Œifï¼Œelseï¼Œå’Œbreak; å¯ä»¥æ ¹æ®éœ€è¦åœ¨ç¨‹åºä¸­ç«‹å³å°è¯•ã€‚

```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
```

##### éå†ä¸€ä¸ªé›†åˆ for

å¯ä»¥ä½¿ç”¨è¯¥whileæ„é€ éå†é›†åˆçš„å…ƒç´ ï¼Œä¾‹å¦‚æ•°ç»„ã€‚

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
```

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!("the value is: {}", element);
    }
}
```

forå¾ªç¯çš„å®‰å…¨æ€§å’Œç®€æ´æ€§ä½¿å…¶æˆä¸ºRustä¸­æœ€å¸¸ç”¨çš„å¾ªç¯æ„é€ ã€‚å³ä½¿åœ¨æƒ³è¦å¤šæ¬¡è¿è¡ŒæŸäº›ä»£ç çš„æƒ…å†µä¸‹ï¼ˆä¾‹å¦‚whileæ¸…å•3-3 ä¸­ä½¿ç”¨å¾ªç¯çš„å€’è®¡æ—¶ç¤ºä¾‹ï¼‰ï¼Œå¤§å¤šæ•°Rustaceansä¹Ÿä¼šä½¿ç”¨forå¾ªç¯ã€‚è¿™æ ·åšçš„æ–¹æ³•æ˜¯ä½¿ç”¨Rangeï¼Œè¿™æ˜¯æ ‡å‡†åº“æä¾›çš„ä¸€ç§ç±»å‹ï¼Œå®ƒæŒ‰é¡ºåºç”Ÿæˆæ‰€æœ‰æ•°å­—ï¼Œä»ä¸€ä¸ªæ•°å­—å¼€å§‹åˆ°å¦ä¸€ä¸ªæ•°å­—ä¹‹å‰ç»“æŸã€‚

```rust
fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}
```

### Rustæ‰€æœ‰æƒ

Rustçš„ä¸»è¦ç‰¹å¾æ˜¯æ‰€æœ‰æƒã€‚å°½ç®¡è¯¥åŠŸèƒ½æ˜“äºè§£é‡Šï¼Œä½†å¯¹å…¶ä½™è¯­è¨€æœ‰æ·±è¿œçš„å½±å“ã€‚

æ‰€æœ‰ç¨‹åºå¿…é¡»åœ¨è¿è¡Œæ—¶ç®¡ç†å®ƒä»¬ä½¿ç”¨è®¡ç®—æœºå†…å­˜çš„æ–¹å¼ã€‚æŸäº›è¯­è¨€å…·æœ‰åƒåœ¾å›æ”¶åŠŸèƒ½ï¼Œè¯¥åƒåœ¾å›æ”¶åŠŸèƒ½ä¼šåœ¨ç¨‹åºè¿è¡Œæ—¶ä¸æ–­å¯»æ‰¾ä¸å†ä½¿ç”¨çš„å†…å­˜ã€‚åœ¨å…¶ä»–è¯­è¨€ä¸­ï¼Œç¨‹åºå‘˜å¿…é¡»æ˜¾å¼åˆ†é…å’Œé‡Šæ”¾å†…å­˜ã€‚Rustä½¿ç”¨ç¬¬ä¸‰ç§æ–¹æ³•ï¼šé€šè¿‡æ‰€æœ‰æƒç³»ç»Ÿç®¡ç†å†…å­˜ï¼Œè¯¥ç³»ç»Ÿå…·æœ‰ä¸€ç»„åœ¨ç¼–è¯‘æ—¶æ£€æŸ¥çš„è§„åˆ™ã€‚ç¨‹åºè¿è¡Œæ—¶ï¼Œæ‰€æœ‰æ‰€æœ‰æƒåŠŸèƒ½éƒ½ä¸ä¼šå‡æ…¢å…¶è¿è¡Œé€Ÿåº¦ã€‚

å› ä¸ºæ‰€æœ‰æƒæ˜¯è®¸å¤šç¨‹åºå‘˜çš„æ–°æ¦‚å¿µï¼Œæ‰€ä»¥å®ƒç¡®å®éœ€è¦ä¸€äº›æ—¶é—´æ¥ä¹ æƒ¯ã€‚å¥½æ¶ˆæ¯æ˜¯ï¼Œå¯¹Rustå’Œæ‰€æœ‰æƒç³»ç»Ÿçš„è§„åˆ™è¶Šæœ‰ç»éªŒï¼Œå°±è¶Šèƒ½è‡ªç„¶å¼€å‘å®‰å…¨æœ‰æ•ˆçš„ä»£ç ã€‚ç»§ç»­å§ï¼

äº†è§£æ‰€æœ‰æƒåï¼Œå°†æ‹¥æœ‰åšå®çš„åŸºç¡€ï¼Œå¯ä»¥ç†è§£ä½¿Rustç‹¬æ ‘ä¸€å¸œçš„åŠŸèƒ½ã€‚åœ¨æœ¬ç« ä¸­ï¼Œå°†é€šè¿‡ä¸€äº›é’ˆå¯¹éå¸¸å¸¸è§çš„æ•°æ®ç»“æ„çš„ç¤ºä¾‹æ¥å­¦ä¹ æ‰€æœ‰æƒï¼šå­—ç¬¦ä¸²ã€‚

åœ¨è®¸å¤šç¼–ç¨‹è¯­è¨€ä¸­ï¼Œä¸å¿…ç»å¸¸è€ƒè™‘å †æ ˆå’Œå †ã€‚ä½†æ˜¯åœ¨åƒRustè¿™æ ·çš„ç³»ç»Ÿç¼–ç¨‹è¯­è¨€ä¸­ï¼Œå€¼æ˜¯åœ¨å †æ ˆä¸Šè¿˜æ˜¯åœ¨å †ä¸Šå¯¹è¯­è¨€çš„è¡Œä¸ºä»¥åŠä¸ºä»€ä¹ˆå¿…é¡»åšå‡ºæŸäº›å†³å®šçš„å½±å“æ›´å¤§ã€‚æ‰€æœ‰æƒçš„å„ä¸ªéƒ¨åˆ†å°†åœ¨æœ¬ç« åé¢çš„å †æ ˆå’Œå †ä¸­è¿›è¡Œä»‹ç»ï¼Œå› æ­¤è¿™é‡Œæ˜¯å‡†å¤‡å·¥ä½œçš„ç®€è¦è¯´æ˜ã€‚

å †æ ˆå’Œå †éƒ½æ˜¯å†…å­˜çš„ä¸€éƒ¨åˆ†ï¼Œçš„ä»£ç å¯åœ¨è¿è¡Œæ—¶ä½¿ç”¨ï¼Œä½†æ˜¯å®ƒä»¬çš„ç»“æ„ä¸åŒã€‚å †æ ˆæŒ‰è·å–å€¼çš„é¡ºåºå­˜å‚¨å€¼ï¼Œå¹¶ä»¥ç›¸åçš„é¡ºåºåˆ é™¤å€¼ã€‚è¿™ç§°ä¸ºåè¿›å…ˆå‡ºã€‚æƒ³æƒ³ä¸€å †ç›˜å­ï¼šæ·»åŠ æ›´å¤šç›˜å­æ—¶ï¼Œå°†å®ƒä»¬æ”¾åœ¨å †çš„é¡¶éƒ¨ï¼Œè€Œå½“éœ€è¦ç›˜å­æ—¶ï¼Œä»é¡¶éƒ¨å–ä¸‹ä¸€ä¸ªç›˜å­ã€‚ä»ä¸­é—´æˆ–åº•éƒ¨æ·»åŠ æˆ–åˆ é™¤æ¿éƒ½æ— æ³•æ­£å¸¸å·¥ä½œï¼æ·»åŠ æ•°æ®ç§°ä¸ºå‹å…¥å †æ ˆï¼Œè€Œåˆ é™¤æ•°æ®ç§°ä¸ºå¼¹å‡ºå †æ ˆã€‚

å †æ ˆä¸­å­˜å‚¨çš„æ‰€æœ‰æ•°æ®å¿…é¡»å…·æœ‰å·²çŸ¥çš„å›ºå®šå¤§å°ã€‚ç¼–è¯‘æ—¶å¤§å°æœªçŸ¥æˆ–å¤§å°å¯èƒ½æ›´æ”¹çš„æ•°æ®å¿…é¡»å­˜å‚¨åœ¨å †ä¸­ã€‚å †çš„ç»„ç»‡æ€§è¾ƒå·®ï¼šå°†æ•°æ®æ”¾åœ¨å †ä¸Šæ—¶ï¼Œéœ€è¦ä¸€å®šæ•°é‡çš„ç©ºé—´ã€‚æ“ä½œç³»ç»Ÿåœ¨å †ä¸­æ‰¾åˆ°ä¸€ä¸ªè¶³å¤Ÿå¤§çš„ç©ºç™½ç‚¹ï¼Œå°†å…¶æ ‡è®°ä¸ºæ­£åœ¨ä½¿ç”¨ä¸­ï¼Œç„¶åè¿”å›ä¸€ä¸ª æŒ‡é’ˆï¼Œè¯¥æŒ‡é’ˆæ˜¯è¯¥ä½ç½®çš„åœ°å€ã€‚æ­¤è¿‡ç¨‹ç§°ä¸º åœ¨å †ä¸Šåˆ†é…ï¼Œæœ‰æ—¶ä¹Ÿç®€ç§°ä¸ºallocatingã€‚å°†å€¼å‹å…¥å †æ ˆä¸è¢«è§†ä¸ºåˆ†é…ã€‚ç”±äºæŒ‡é’ˆæ˜¯å·²çŸ¥çš„å›ºå®šå¤§å°ï¼Œå› æ­¤å¯ä»¥å°†æŒ‡é’ˆå­˜å‚¨åœ¨å †æ ˆä¸Šï¼Œä½†æ˜¯å½“éœ€è¦å®é™…æ•°æ®æ—¶ï¼Œå¿…é¡»éµå¾ªæŒ‡é’ˆã€‚

#### Rustæ‰€æœ‰æƒè§„åˆ™

* Rustä¸­çš„æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªå˜é‡ï¼Œç§°ä¸ºå…¶æ‰€æœ‰è€…ã€‚
* ä¸€æ¬¡åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…ã€‚
* å½“æ‰€æœ‰è€…è¶…å‡ºèŒƒå›´æ—¶ï¼Œè¯¥å€¼å°†è¢«åˆ é™¤

å¯ä»¥æ”¹å˜çš„å­—ç¬¦ä¸²

```rust

#![allow(unused_variables)]
fn main() {
let mut s = String::from("hello");

s.push_str(", world!"); // push_str() appends a literal to a String

println!("{}", s); // This will print `hello, world!`
}

```

#### å†…å­˜å’Œåˆ†é…

å¯¹äºå­—ç¬¦ä¸²æ–‡å­—ï¼Œåœ¨ç¼–è¯‘æ—¶å°±çŸ¥é“äº†å†…å®¹ï¼Œå› æ­¤æ–‡æœ¬ç›´æ¥ç¡¬ç¼–ç åˆ°æœ€ç»ˆçš„å¯æ‰§è¡Œæ–‡ä»¶ä¸­ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆå­—ç¬¦ä¸²æ–‡å­—å¿«é€Ÿé«˜æ•ˆçš„åŸå› ã€‚ä½†æ˜¯è¿™äº›å±æ€§ä»…æ¥è‡ªå­—ç¬¦ä¸²æ–‡å­—çš„ä¸å˜æ€§ã€‚ä¸å¹¸çš„æ˜¯ï¼Œå¯¹äºåœ¨ç¼–è¯‘æ—¶æœªçŸ¥å¤§å°ä¸”åœ¨è¿è¡Œç¨‹åºæ—¶å¤§å°å¯èƒ½ä¼šæ”¹å˜çš„æ¯æ®µæ–‡æœ¬ï¼Œæ— æ³•å°†å†…å­˜å—æ”¾å…¥äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ã€‚

**å˜é‡ä¸æ•°æ®äº¤äº’çš„æ–¹å¼ï¼šå…‹éš†**

```rust

#![allow(unused_variables)]
fn main() {
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
}

```

#### Rustå¯æ‹·è´ç±»å‹

* æ‰€æœ‰æ•´æ•°ç±»å‹ï¼Œä¾‹å¦‚u32ã€‚
* å¸ƒå°”ç±»å‹ï¼Œboolå€¼trueå’Œfalseã€‚
* æ‰€æœ‰æµ®ç‚¹ç±»å‹ï¼Œä¾‹å¦‚f64ã€‚
* å­—ç¬¦ç±»å‹charã€‚
* å…ƒç»„ï¼ˆå¦‚æœå®ƒä»¬ä»…åŒ…å«alsoçš„ç±»å‹ï¼‰Copyã€‚ä¾‹å¦‚ï¼Œ (i32, i32)æ˜¯Copyï¼Œä½†(i32, String)ä¸æ˜¯ã€‚

```rust
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so itâ€™s okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.

```

#### è¿”å›å€¼å’ŒèŒƒå›´

è¿”å›å€¼ä¹Ÿå¯ä»¥è½¬ç§»æ‰€æœ‰æƒã€‚

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from("hello");     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
  // moved, so nothing happens. s1 goes out of scope and is dropped.

fn gives_ownership() -> String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from("hello"); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// takes_and_gives_back will take a String and return one
fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
```

å˜é‡çš„æ‰€æœ‰æƒæ¯æ¬¡éƒ½éµå¾ªç›¸åŒçš„æ¨¡å¼ï¼šå°†å€¼åˆ†é…ç»™å¦ä¸€ä¸ªå˜é‡å°†å…¶ç§»åŠ¨ã€‚å½“åŒ…å«å †ä¸Šæ•°æ®çš„å˜é‡è¶…å‡ºèŒƒå›´æ—¶ï¼Œå°†æ¸…é™¤è¯¥å€¼ï¼Œdropé™¤éå·²å°†æ•°æ®ç§»è‡³å¦ä¸€ä¸ªå˜é‡æ‰€æ‹¥æœ‰ã€‚

æ‹¥æœ‰æ‰€æœ‰æƒç„¶åè¿”å›æ‰€æœ‰åŠŸèƒ½çš„æ‰€æœ‰æƒæœ‰ç‚¹ä¹å‘³ã€‚å¦‚æœè¦è®©å‡½æ•°ä½¿ç”¨å€¼è€Œä¸æ˜¯æ‰€æœ‰æƒæ€ä¹ˆåŠï¼Ÿä»¤äººååˆ†çƒ¦æ¼çš„æ˜¯ï¼Œé™¤äº†å¯èƒ½è¿˜æƒ³è¿”å›çš„å‡½æ•°ä¸»ä½“æ‰€äº§ç”Ÿçš„ä»»ä½•æ•°æ®ä¹‹å¤–ï¼Œå¦‚æœæƒ³è¦å†æ¬¡ä½¿ç”¨å®ƒï¼Œåˆ™è¿˜éœ€è¦å°†è¿”å›çš„ä¿¡æ¯ä¼ é€’å›å»ã€‚

å¯ä»¥ä½¿ç”¨å…ƒç»„è¿”å›å¤šä¸ªå€¼ï¼Œ

```rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
```

#### Rustå¼•ç”¨

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

*æ³¨æ„ï¼šä½¿ç”¨`&`è¿›è¡Œå¼•ç”¨çš„åä¹‰è¯æ˜¯è§£å¼•ç”¨ï¼Œè¿™æ˜¯é€šè¿‡è§£å¼•ç”¨è¿ç®—ç¬¦æ¥å®Œæˆçš„`*`ã€‚*

å¦‚æœå˜é‡åœ¨é»˜è®¤æƒ…å†µä¸‹æ˜¯ä¸å¯å˜çš„ï¼Œå¼•ç”¨ä¹Ÿæ˜¯å¦‚æ­¤ï¼Œä¸å…è®¸ä¿®æ”¹å¼•ç”¨çš„å†…å®¹ã€‚

##### å¯å˜å¼•ç”¨

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

ä½†æ˜¯å¯å˜å¼•ç”¨æœ‰ä¸€ä¸ªå¾ˆå¤§çš„é™åˆ¶ï¼šåªèƒ½åœ¨ä¸€ä¸ªç‰¹å®šèŒƒå›´å†…å¯¹ä¸€ä¸ªç‰¹å®šçš„æ•°æ®è¿›è¡Œä¸€ä¸ªå¯å˜å¼•ç”¨ã€‚ä¸‹é¢ä»£ç å°†å¤±è´¥ï¼š

```rust
let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s;

println!("{}, {}", r1, r2);

```

è¯¥é™åˆ¶å…è®¸çªå˜ï¼Œä½†æ˜¯ä»¥éå¸¸å—æ§çš„æ–¹å¼ã€‚è¿™æ˜¯æ–°çš„Rustaceansè‹¦è‹¦æŒ£æ‰çš„äº‹æƒ…ï¼Œå› ä¸ºå¤§å¤šæ•°è¯­è¨€éƒ½å…è®¸éšæ—¶æ›´æ”¹ã€‚

å…·æœ‰æ­¤é™åˆ¶çš„å¥½å¤„æ˜¯Rustå¯ä»¥é˜²æ­¢åœ¨ç¼–è¯‘æ—¶å‘ç”Ÿæ•°æ®äº‰ç”¨ã€‚ä¸€ä¸ªæ•°æ®çš„æ¯”èµ›ç›¸ä¼¼ï¼Œç«äº‰æ¡ä»¶ï¼Œå½“è¿™ä¸‰ç§è¡Œä¸ºçš„å‘ç”Ÿæƒ…å†µï¼š

* ä¸¤ä¸ªæˆ–å¤šä¸ªæŒ‡é’ˆåŒæ—¶è®¿é—®ç›¸åŒçš„æ•°æ®ã€‚
* è‡³å°‘æœ‰ä¸€ä¸ªæŒ‡é’ˆç”¨äºå†™å…¥æ•°æ®ã€‚
* æ²¡æœ‰ç”¨äºåŒæ­¥å¯¹æ•°æ®çš„è®¿é—®çš„æœºåˆ¶ã€‚

ä¸å¾€å¸¸ä¸€æ ·ï¼Œå¯ä»¥ä½¿ç”¨å¤§æ‹¬å·åˆ›å»ºæ–°çš„èŒƒå›´ï¼Œä»è€Œå…è®¸å¤šä¸ªå¯å˜å¼•ç”¨ï¼Œè€Œä¸èƒ½åŒæ—¶å¼•ç”¨ï¼š

```rust
#![allow(unused_variables)]
fn main() {
let mut s = String::from("hello");

{
    let r1 = &mut s;

} // r1 goes out of scope here, so we can make a new reference with no problems.

let r2 = &mut s;
}
```

##### æ‚¬ç©ºå¼•ç”¨

åœ¨å¸¦æœ‰æŒ‡é’ˆçš„è¯­è¨€ä¸­ï¼Œå¾ˆå®¹æ˜“é”™è¯¯åœ°åˆ›å»ºä¸€ä¸ªæ‚¬ç©ºæŒ‡é’ˆï¼Œå³é€šè¿‡åœ¨ä¿ç•™æŒ‡å‘è¯¥å†…å­˜çš„æŒ‡é’ˆçš„åŒæ—¶é‡Šæ”¾ä¸€äº›å†…å­˜æ¥å¼•ç”¨å¯èƒ½å·²åˆ†é…ç»™ä»–äººçš„å†…å­˜ä¸­æŸä¸ªä½ç½®çš„æŒ‡é’ˆã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œåœ¨Rustä¸­ï¼Œç¼–è¯‘å™¨ä¿è¯å¼•ç”¨æ°¸è¿œä¸ä¼šæˆä¸ºæ‚¬æŒ‚å¼•ç”¨ï¼šå¦‚æœå¯¹æŸäº›æ•°æ®å…·æœ‰å¼•ç”¨ï¼Œåˆ™ç¼–è¯‘å™¨å°†ç¡®ä¿æ•°æ®ä¸ä¼šè¶…å‡ºå¯¹æ•°æ®çš„å¼•ç”¨èŒƒå›´ã€‚

è®©å°è¯•åˆ›å»ºä¸€ä¸ªæ‚¬ç©ºçš„å¼•ç”¨ï¼ŒRustå°†é€šè¿‡ç¼–è¯‘æ—¶é”™è¯¯é˜²æ­¢å®ƒï¼š

```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
```

è¿™æ˜¯é”™è¯¯:

```rust
error[E0106]: missing lifetime specifier
 --> main.rs:5:16
  |
5 | fn dangle() -> &String {
  |                ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is
  no value for it to be borrowed from
  = help: consider giving it a 'static lifetime
```

### Ruståˆ‡ç‰‡ç±»å‹

sliceä¹Ÿæ˜¯å¦ä¸€ä¸ªæ²¡æœ‰æ‰€æœ‰æƒçš„æ•°æ®ç±»å‹ã€‚åˆ‡ç‰‡ä½¿å¯ä»¥å¼•ç”¨é›†åˆä¸­è¿ç»­çš„å…ƒç´ åºåˆ—ï¼Œè€Œä¸æ˜¯æ•´ä¸ªé›†åˆã€‚

```rust

#![allow(unused_variables)]
fn main() {
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
}
```

```rust

#![allow(unused_variables)]
fn main() {
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
}
```

è¿™ç±»ä¼¼äºå¯¹æ•´ä½“è¿›è¡Œå¼•ç”¨ï¼Œ`String`ä½†è¦å¤šåŠ ä¸€ `[0..5]`ç‚¹ç‚¹ã€‚è€Œä¸æ˜¯æ•´ä¸ªå‚è€ƒStringï¼Œè€Œæ˜¯å¯¹çš„ä¸€éƒ¨åˆ†çš„å‚è€ƒStringã€‚

é€šè¿‡æŒ‡å®š`[starting_index..ending_index]`ï¼Œå¯ä»¥ä½¿ç”¨æ–¹æ‹¬å·å†…çš„èŒƒå›´æ¥åˆ›å»ºåˆ‡ç‰‡ ï¼Œå…¶ä¸­ï¼Œ`starting_index`æ˜¯åˆ‡ç‰‡ä¸­çš„ç¬¬ä¸€ä¸ªä½ç½®ï¼Œæ¯”åˆ‡ç‰‡ä¸­`ending_index`çš„æœ€åä¸€ä¸ªä½ç½®å¤§ã€‚åœ¨å†…éƒ¨ï¼Œåˆ‡ç‰‡æ•°æ®ç»“æ„å­˜å‚¨åˆ‡ç‰‡çš„èµ·å§‹ä½ç½®å’Œé•¿åº¦ï¼Œè¯¥é•¿åº¦ä¸`ending_indexminus` ç›¸å¯¹åº”`starting_index`ã€‚å› æ­¤ï¼Œåœ¨çš„æƒ…å†µä¸‹`let world = &s[6..11];`ï¼Œ`world`å°†æ˜¯ä¸€ä¸ªåˆ‡ç‰‡ï¼Œè¯¥åˆ‡ç‰‡åŒ…å«ä¸€ä¸ªæŒ‡å‘ç¬¬7ä¸ªå­—èŠ‚ï¼ˆä»1å¼€å§‹ï¼‰çš„æŒ‡é’ˆï¼Œå…¶`s`é•¿åº¦å€¼ä¸º5ã€‚

ä½¿ç”¨Rustçš„..rangeè¯­æ³•ï¼Œå¦‚æœè¦ä»ç¬¬ä¸€ä¸ªç´¢å¼•ï¼ˆé›¶ï¼‰å¼€å§‹ï¼Œåˆ™å¯ä»¥åœ¨ä¸¤ä¸ªå¥ç‚¹ä¹‹å‰åˆ é™¤è¯¥å€¼ã€‚æ¢å¥è¯è¯´ï¼Œè¿™äº›æ˜¯ç›¸ç­‰çš„ï¼š

```rust

#![allow(unused_variables)]
fn main() {
let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2];
}
```

åŒæ ·ï¼Œå¦‚æœçš„åˆ†ç‰‡åŒ…å«çš„æœ€åä¸€ä¸ªå­—èŠ‚ï¼Œåˆ™Stringå¯ä»¥åˆ é™¤å°¾éšæ•°å­—ã€‚è¿™æ„å‘³ç€è¿™äº›æ˜¯ç›¸ç­‰çš„ï¼š

```rust
#![allow(unused_variables)]
fn main() {
let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
}
```

è¿˜å¯ä»¥åˆ é™¤ä¸¤ä¸ªå€¼ä»¥æˆªå–æ•´ä¸ªå­—ç¬¦ä¸²çš„ä¸€éƒ¨åˆ†ã€‚æ‰€ä»¥è¿™äº›æ˜¯ç›¸ç­‰çš„ï¼š

```rust
#![allow(unused_variables)]
fn main() {
let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
}
```

*æ³¨æ„ï¼šå­—ç¬¦ä¸²åˆ‡ç‰‡èŒƒå›´ç´¢å¼•å¿…é¡»å‡ºç°åœ¨æœ‰æ•ˆçš„UTF-8å­—ç¬¦è¾¹ç•Œå¤„ã€‚å¦‚æœå°è¯•åœ¨å¤šå­—èŠ‚å­—ç¬¦çš„ä¸­é—´åˆ›å»ºå­—ç¬¦ä¸²ç‰‡æ®µï¼Œåˆ™ç¨‹åºå°†é€€å‡ºå¹¶æ˜¾ç¤ºé”™è¯¯ã€‚*

```rust

#![allow(unused_variables)]
fn main() {
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
}
```

```rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // error!

    println!("the first word is: {}", word);
}
```

è¿™æ˜¯ç¼–è¯‘å™¨é”™è¯¯ï¼š

```rust
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --> src/main.rs:18:5
   |
16 |     let word = first_word(&s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!("the first word is: {}", word);
   |                                       ---- immutable borrow later used here
```

##### æ•°ç»„åˆ‡ç‰‡

```rust

#![allow(unused_variables)]
fn main() {
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];
}
```

è¯¥åˆ‡ç‰‡å…·æœ‰ç±»å‹`&[i32]`ã€‚é€šè¿‡å­˜å‚¨å¯¹ç¬¬ä¸€ä¸ªå…ƒç´ å’Œé•¿åº¦çš„å¼•ç”¨ï¼Œå®ƒçš„å·¥ä½œæ–¹å¼ä¸å­—ç¬¦ä¸²åˆ‡ç‰‡ç›¸åŒã€‚

### Rustç»“æ„

è¦å®šä¹‰ä¸€ä¸ªç»“æ„ï¼Œè¾“å…¥å…³é”®å­—`struct`å¹¶å‘½åæ•´ä¸ªç»“æ„ã€‚ç»“æ„çš„åç§°åº”è¯´æ˜å°†æ•°æ®åˆ†ç»„åœ¨ä¸€èµ·çš„é‡è¦æ€§ã€‚ç„¶åï¼Œåœ¨å¤§æ‹¬å·å†…ï¼Œå®šä¹‰æ•°æ®æ®µçš„åç§°å’Œç±»å‹ï¼Œå°†å…¶ç§°ä¸ºfieldã€‚

```rust
#![allow(unused_variables)]
fn main() {
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
}
```

è¦åœ¨å®šä¹‰ç»“æ„åä½¿ç”¨ç»“æ„ï¼Œå¯ä»¥é€šè¿‡ä¸ºæ¯ä¸ªå­—æ®µæŒ‡å®šå…·ä½“å€¼æ¥åˆ›å»ºè¯¥ç»“æ„çš„å®ä¾‹ã€‚é€šè¿‡è¯´æ˜ç»“æ„çš„åç§°æ¥åˆ›å»ºå®ä¾‹ï¼Œç„¶åæ·»åŠ åŒ…å«`key: value`å¯¹çš„å¤§æ‹¬å·ï¼Œå…¶ä¸­é”®æ˜¯å­—æ®µçš„åç§°ï¼Œå€¼æ˜¯è¦å­˜å‚¨åœ¨è¿™äº›å­—æ®µä¸­çš„æ•°æ®ã€‚ä¸å¿…æŒ‰ç…§åœ¨ç»“æ„ä¸­å£°æ˜å®ƒä»¬çš„é¡ºåºæ¥æŒ‡å®šå­—æ®µã€‚æ¢å¥è¯è¯´ï¼Œç»“æ„å®šä¹‰å°±åƒè¯¥ç±»å‹çš„é€šç”¨æ¨¡æ¿ï¼Œå®ä¾‹ç”¨ç‰¹å®šçš„æ•°æ®å¡«å……è¯¥æ¨¡æ¿ä»¥åˆ›å»ºè¯¥ç±»å‹çš„å€¼ã€‚

```rust

#![allow(unused_variables)]
fn main() {
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

let mut user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};

user1.email = String::from("anotheremail@example.com");
}

```

#### ä½¿ç”¨ç»“æ„æ›´æ–°è¯­æ³•ä»å…¶ä»–å®ä¾‹åˆ›å»ºå®ä¾‹

```rust

#![allow(unused_variables)]
fn main() {
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

let user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};

let user2 = User {
    email: String::from("another@example.com"),
    username: String::from("anotherusername567"),
    ..user1
};
}
```

#### ä½¿ç”¨æ²¡æœ‰å‘½åå­—æ®µçš„å…ƒç»„ç»“æ„åˆ›å»ºä¸åŒçš„ç±»å‹

è¿˜å¯ä»¥å®šä¹‰çœ‹èµ·æ¥ç±»ä¼¼äºå…ƒç»„çš„ç»“æ„ï¼Œç§°ä¸ºå…ƒç»„ç»“æ„ã€‚å…ƒç»„ç»“æ„å…·æœ‰é™„åŠ çš„å«ä¹‰ï¼Œå³ç»“æ„åç§°æä¾›çš„å«ä¹‰ï¼Œä½†æ²¡æœ‰ä¸å…¶å­—æ®µå…³è”çš„åç§°ï¼›ç›¸åï¼Œå®ƒä»¬åªæ˜¯å­—æ®µçš„ç±»å‹ã€‚å½“æƒ³ç»™æ•´ä¸ªå…ƒç»„èµ·ä¸€ä¸ªåå­—å¹¶ä½¿å…ƒç»„æˆä¸ºä¸å…¶ä»–å…ƒç»„ä¸åŒçš„ç±»å‹æ—¶ï¼Œå…ƒç»„ç»“æ„å¾ˆæœ‰ç”¨ï¼Œå¹¶ä¸”åƒå¸¸è§„ç»“æ„ä¸­é‚£æ ·å‘½åæ¯ä¸ªå­—æ®µéƒ½æ˜¯å†—é•¿æˆ–å¤šä½™çš„ã€‚

è¦å®šä¹‰å…ƒç»„ç»“æ„ï¼Œè¯·ä»`struct`å…³é”®å­—å’Œç»“æ„åç§°å¼€å§‹ï¼Œåè·Ÿå…ƒç»„ä¸­çš„ç±»å‹ã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹æ˜¯ä¸¤ä¸ªåä¸º`Color`å’Œçš„å…ƒç»„ç»“æ„çš„å®šä¹‰å’Œç”¨æ³•`Point`ï¼š

```rust
#![allow(unused_variables)]
fn main() {
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
}
```

è¯·æ³¨æ„ï¼Œ`black`å’Œ`origin`å€¼æ˜¯ä¸åŒçš„ç±»å‹ï¼Œå› ä¸ºå®ƒä»¬æ˜¯ä¸åŒå…ƒç»„ç»“æ„çš„å®ä¾‹ã€‚å®šä¹‰çš„æ¯ä¸ªç»“æ„éƒ½æ˜¯å…¶è‡ªå·±çš„ç±»å‹ï¼Œå³ä½¿è¯¥ç»“æ„ä¸­çš„å­—æ®µå…·æœ‰ç›¸åŒçš„ç±»å‹ã€‚ä¾‹å¦‚ï¼Œå³ä½¿ä¸¤ä¸ªç±»å‹éƒ½ç”±ä¸‰ä¸ªå€¼ç»„æˆï¼Œ`Color`å¸¦æœ‰ç±»å‹å‚æ•°çš„å‡½æ•°ä¹Ÿä¸èƒ½å°†a `Point`ä½œä¸ºå‚æ•°`i32`ã€‚å¦åˆ™ï¼Œå…ƒç»„`struct`å®ä¾‹çš„è¡Œä¸ºç±»ä¼¼äºå…ƒç»„ï¼šå¯ä»¥å°†å®ƒä»¬åˆ†è§£ä¸ºå„è‡ªçš„ç‰‡æ®µï¼Œå¯ä»¥ä½¿ç”¨.åè·Ÿç´¢å¼•çš„ç´¢å¼•æ¥è®¿é—®å•ä¸ªå€¼ï¼Œä¾æ­¤ç±»æ¨ã€‚

#### æ²¡æœ‰ä»»ä½•å­—æ®µçš„ç±»ä¼¼å•å…ƒçš„ç»“æ„

è¿˜å¯ä»¥å®šä¹‰æ²¡æœ‰ä»»ä½•å­—æ®µçš„ç»“æ„ï¼è¿™äº›ä¹‹æ‰€ä»¥ç§°ä¸º å•å…ƒçŠ¶ç»“æ„ï¼Œæ˜¯å› ä¸ºå®ƒä»¬çš„è¡Œä¸ºç±»ä¼¼äº`()`å•å…ƒç±»å‹ã€‚åœ¨éœ€è¦åœ¨æŸç§ç±»å‹ä¸Šå®ç°ç‰¹å¾ä½†åˆä¸æƒ³åœ¨ç±»å‹æœ¬èº«ä¸­å­˜å‚¨ä»»ä½•æ•°æ®çš„æƒ…å†µä¸‹ï¼Œç±»ä¼¼å•å…ƒçš„ç»“æ„å¾ˆæœ‰ç”¨ã€‚

```rust
struct User {
    username: &str,
    email: &str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: "someone@example.com",
        username: "someusername123",
        active: true,
        sign_in_count: 1,
    };
}
```

#### ä½¿ç”¨ç»“æ„çš„ç¤ºä¾‹

```rust
fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        "The area of the rectangle is {} square pixels.",
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -> u32 {
    width * height
}
```

```rust
fn main() {
    let rect1 = (30, 50);

    println!(
        "The area of the rectangle is {} square pixels.",
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -> u32 {
    dimensions.0 * dimensions.1
}
```

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        "The area of the rectangle is {} square pixels.",
        area(&rect1)
    );
}

fn area(rectangle: &Rectangle) -> u32 {
    rectangle.width * rectangle.height
}
```

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!("rect1 is {:?}", rect1);
}
```

### Rustæ–¹æ³•

æ–¹æ³•ç±»ä¼¼äºå‡½æ•°ï¼šå®ƒä»¬ç”¨fnå…³é”®å­—åŠå…¶åç§°å£°æ˜ï¼Œå®ƒä»¬å¯ä»¥å…·æœ‰å‚æ•°å’Œè¿”å›å€¼ï¼Œå¹¶ä¸”å®ƒä»¬åŒ…å«ä¸€äº›ä»å…¶ä»–åœ°æ–¹è°ƒç”¨å®ƒä»¬æ—¶å°†è¿è¡Œçš„ä»£ç ã€‚ä½†æ˜¯ï¼Œæ–¹æ³•ä¸å‡½æ•°çš„ä¸åŒä¹‹å¤„åœ¨äºï¼Œå®ƒä»¬æ˜¯åœ¨structçš„ä¸Šä¸‹æ–‡ä¸­å®šä¹‰çš„ï¼Œå¹¶ä¸”å®ƒä»¬çš„ç¬¬ä¸€ä¸ªå‚æ•°å§‹ç»ˆä¸ºselfï¼Œå®ƒè¡¨ç¤ºè°ƒç”¨è¯¥æ–¹æ³•çš„structå®ä¾‹ã€‚

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```

```rust
fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 10, height: 40 };
    let rect3 = Rectangle { width: 60, height: 45 };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
}
```

```rust

#![allow(unused_variables)]
fn main() {
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
}
```

çš„å¦ä¸€ä¸ªæœ‰ç”¨çš„åŠŸèƒ½`impl`å—çš„æ˜¯ï¼Œèƒ½å®šä¹‰èŒƒå›´å†…çš„åŠŸèƒ½implå—æ˜¯ä¸å¸¦selfä½œä¸ºå‚æ•°ã€‚è¿™äº›è¢«ç§°ä¸ºå…³è”å‡½æ•°ï¼Œå› ä¸ºå®ƒä»¬ä¸ç»“æ„å…³è”ã€‚å®ƒä»¬ä»ç„¶æ˜¯å‡½æ•°ï¼Œè€Œä¸æ˜¯æ–¹æ³•ï¼Œå› ä¸ºå®ƒä»¬æ²¡æœ‰å¯ä½¿ç”¨çš„ç»“æ„å®ä¾‹ã€‚å·²ç»ä½¿ç”¨äº†String::fromå…³è”çš„åŠŸèƒ½ã€‚

å…³è”å‡½æ•°é€šå¸¸ç”¨äºå°†è¿”å›è¯¥ç»“æ„çš„æ–°å®ä¾‹çš„æ„é€ å‡½æ•°ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥æä¾›ä¸€ä¸ªå…³è”çš„å‡½æ•°ï¼Œè¯¥å‡½æ•°å°†å…·æœ‰ä¸€ä¸ªç»´åº¦å‚æ•°å¹¶å°†å…¶ç”¨ä½œå®½åº¦å’Œé«˜åº¦ï¼Œä»è€Œä½¿åˆ›å»ºæ­£æ–¹å½¢Rectangleè€Œä¸æ˜¯å¿…é¡»ä¸¤æ¬¡æŒ‡å®šç›¸åŒçš„å€¼å˜å¾—æ›´åŠ å®¹æ˜“ï¼š

```rust

#![allow(unused_variables)]
fn main() {
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn square(size: u32) -> Rectangle {
        Rectangle { width: size, height: size }
    }
}
}
```

æ¯ä¸ªç»“æ„å…è®¸å…·æœ‰å¤šä¸ª`impl`å—ã€‚

```rust

#![allow(unused_variables)]
fn main() {
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
}

```

### Rustæšä¸¾å’Œæ¨¡å¼åŒ¹é…

```rust

#![allow(unused_variables)]
fn main() {
enum IpAddrKind {
    V4,
    V6,
}
}
```

å¯ä»¥`IpAddrKind`åƒè¿™æ ·åˆ›å»ºä¸¤ä¸ªå˜ä½“çš„æ¯ä¸€ä¸ªçš„å®ä¾‹ï¼š

```rust

#![allow(unused_variables)]
fn main() {
enum IpAddrKind {
    V4,
    V6,
}

let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
}
```

è¯·æ³¨æ„ï¼Œæšä¸¾çš„å˜ä½“åœ¨å…¶æ ‡è¯†ç¬¦ä¸‹å‘½åç©ºé—´ï¼Œå¹¶ä¸”ä½¿ç”¨åŒå†’å·å°†ä¸¤è€…åˆ†å¼€ã€‚ä¹‹æ‰€ä»¥æœ‰ç”¨ï¼Œæ˜¯å› ä¸ºç°åœ¨ä¸¤ä¸ªå€¼`IpAddrKind::V4`å’Œ`IpAddrKind::V6`éƒ½å…·æœ‰ç›¸åŒçš„ç±»å‹ï¼š `IpAddrKind`ã€‚ä¾‹å¦‚ï¼Œç„¶åå¯ä»¥å®šä¹‰ä¸€ä¸ªæ¥å—ä»»æ„å€¼çš„å‡½æ•° `IpAddrKind`ï¼š

```rust

#![allow(unused_variables)]
fn main() {
enum IpAddrKind {
    V4,
    V6,
}

fn route(ip_kind: IpAddrKind) { }
}
```

```rust

#![allow(unused_variables)]
fn main() {
enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
};
}
```

é€šè¿‡å°†æ•°æ®ç›´æ¥æ”¾å…¥æ¯ä¸ªæšä¸¾å˜é‡ä¸­ï¼Œå¯ä»¥ä»…ä½¿ç”¨æšä¸¾è€Œä¸æ˜¯ç»“æ„å†…éƒ¨çš„æšä¸¾ä»¥æ›´ç®€æ´çš„æ–¹å¼è¡¨ç¤ºç›¸åŒçš„æ¦‚å¿µã€‚è¿™ä¸ªæ–°çš„`IpAddr`æšä¸¾å®šä¹‰è¡¨ç¤º`V4`å’Œ`V6` å˜ä½“éƒ½å°†å…·æœ‰å…³è”çš„`String`å€¼ï¼š

```rust

#![allow(unused_variables)]
fn main() {
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));

let loopback = IpAddr::V6(String::from("::1"));
}
```

```rust

#![allow(unused_variables)]
fn main() {
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
}
```

```rust

#![allow(unused_variables)]
fn main() {
struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
}
```

```rust

#![allow(unused_variables)]
fn main() {
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn call(&self) {
        // method body would be defined here
    }
}

let m = Message::Write(String::from("hello"));
m.call();
}
```

```rust

#![allow(unused_variables)]
fn main() {
enum Option<T> {
    Some(T),
    None,
}
}
```

è¯¥`Option<T>`æšä¸¾æ˜¯éå¸¸æœ‰ç”¨ï¼Œå®ƒç”šè‡³åŒ…æ‹¬ä¸­æ‹‰å¼€åºå¹•; æ— éœ€å°†å…¶æ˜ç¡®çº³å…¥èŒƒå›´ã€‚æ­¤å¤–ï¼Œå®ƒçš„å˜ä½“ä¹Ÿæ˜¯å¦‚æ­¤ï¼šå¯ä»¥ç›´æ¥ä½¿ç”¨`Some`å’Œ`None`ä¸å¸¦`Option::`å‰ç¼€ã€‚è¯¥ `Option<T>`æšä¸¾ä»ç„¶åªæ˜¯ä¸€ä¸ªæ™®é€šçš„æšä¸¾ï¼Œå¹¶`Some(T)`å’Œ`None`ç±»å‹ä»ç„¶å˜ç§`Option<T>`ã€‚

è¯¥`<T>`è¯­æ³•æ˜¯ï¼Œè¿˜æ²¡æœ‰è°ˆåˆ°å°šé”ˆçš„ç‰¹ç‚¹ã€‚è¿™æ˜¯ä¸€ä¸ªæ³›å‹ç±»å‹å‚æ•°ï¼Œå°†åœ¨ç¬¬10ç« ä¸­æ›´è¯¦ç»†åœ°ä»‹ç»æ³›å‹ã€‚ç°åœ¨ï¼Œåªéœ€è¦çŸ¥é“ï¼Œè¿™`<T>`æ„å‘³ç€æšä¸¾çš„Someå˜ä½“ Optionå¯ä»¥å®¹çº³ä»»ä½•ç±»å‹çš„æ•°æ®ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›ä½¿ç”¨Optionå€¼ä¿å­˜æ•°å­—ç±»å‹å’Œå­—ç¬¦ä¸²ç±»å‹çš„ç¤ºä¾‹ï¼š

```rust

#![allow(unused_variables)]
fn main() {
let some_number = Some(5);
let some_string = Some("a string");

let absent_number: Option<i32> = None;
}

```

#### Rustæ§åˆ¶æµè¿ç®—ç¬¦match

Rustå…·æœ‰ä¸€ä¸ªéå¸¸å¼ºå¤§çš„æ§åˆ¶æµè¿ç®—ç¬¦matchï¼Œè¯¥è¿ç®—ç¬¦ä½¿å¯ä»¥å°†å€¼ä¸ä¸€ç³»åˆ—æ¨¡å¼è¿›è¡Œæ¯”è¾ƒï¼Œç„¶åæ ¹æ®åŒ¹é…çš„æ¨¡å¼æ‰§è¡Œä»£ç ã€‚æ¨¡å¼å¯ä»¥ç”±æ–‡å­—å€¼ï¼Œå˜é‡åï¼Œé€šé…ç¬¦å’Œè®¸å¤šå…¶ä»–å†…å®¹ç»„æˆï¼›

```rust

#![allow(unused_variables)]
fn main() {
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
}
```

##### æ­é…Option<T>

```rust

#![allow(unused_variables)]
fn main() {
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
}

```

##### `_`å ä½ç¬¦

```rust

#![allow(unused_variables)]
fn main() {
let some_u8_value = 0u8;
match some_u8_value {
    1 => println!("one"),
    3 => println!("three"),
    5 => println!("five"),
    7 => println!("seven"),
    _ => (),
}
}

```

### Rustæ¨¡å—

æ–‡ä»¶src.lib.rs

```rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}

```

#### ä½¿ç”¨pubå…³é”®å­—å…¬å¼€è·¯å¾„

```rust
mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}

```

#### èµ·å§‹ç›¸å¯¹è·¯å¾„ super

```rust
fn serve_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::serve_order();
    }

    fn cook_order() {}
}
fn main() {}

```

#### å…¬å¼€ç»“æ„å’Œæšä¸¾

```rust

#![allow(unused_variables)]
fn main() {
mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    let mut meal = back_of_house::Breakfast::summer("Rye");
    // Change our mind about what bread we'd like
    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal
    // meal.seasonal_fruit = String::from("blueberries");
}
}

```

#### ä½¿ç”¨useå…³é”®å­—å°†è·¯å¾„çº³å…¥èŒƒå›´

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
fn main() {}

```

è¿˜å¯ä»¥é€šè¿‡`use`å’Œç›¸å¯¹è·¯å¾„å°†æŸé¡¹çº³å…¥èŒƒå›´ã€‚

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
fn main() {}

```

#### åˆ›å»ºæƒ¯ç”¨useè·¯å¾„

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
    add_to_waitlist();
    add_to_waitlist();
}
fn main() {}

```

#### ä½¿ç”¨aså…³é”®å­—æä¾›æ–°åç§°

```rust

#![allow(unused_variables)]
fn main() {
use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -> Result {
    // --snip--
    Ok(())
}

fn function2() -> IoResult<()> {
    // --snip--
    Ok(())
}
}

```

ç”¨ä»¥ä¸‹æ–¹å¼é‡æ–°å¯¼å‡ºåç§° pub use,å½“ä½¿ç”¨useå…³é”®å­—å°†åç§°å¸¦å…¥èŒƒå›´æ—¶ï¼Œæ–°èŒƒå›´ä¸­å¯ç”¨çš„åç§°æ˜¯ç§æœ‰çš„ã€‚ä¸ºäº†ä½¿è°ƒç”¨ä»£ç çš„ä»£ç èƒ½å¤Ÿåƒåœ¨è¯¥ä»£ç èŒƒå›´å†…å®šä¹‰è¯¥åç§°ä¸€æ ·å¼•ç”¨è¯¥åç§°ï¼Œå¯ä»¥å°†pub å’Œç»„åˆåœ¨ä¸€èµ·useã€‚è¿™é¡¹æŠ€æœ¯ç§°ä¸ºé‡æ–°å¯¼å‡ºï¼Œå› ä¸ºå°†æŸä¸ªé¡¹ç›®çº³å…¥èŒƒå›´ï¼ŒåŒæ—¶ä¹Ÿä½¿è¯¥é¡¹ç›®å¯ä¾›å…¶ä»–äººè¿›å…¥å…¶èŒƒå›´ã€‚

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
fn main() {}

```

é€šè¿‡ä½¿ç”¨pub useï¼Œå¤–éƒ¨ä»£ç ç°åœ¨å¯ä»¥add_to_waitlistä½¿ç”¨è°ƒç”¨è¯¥å‡½æ•°hosting::add_to_waitlistã€‚å¦‚æœæœªæŒ‡å®špub useï¼Œåˆ™è¯¥ eat_at_restaurantå‡½æ•°å¯ä»¥hosting::add_to_waitliståœ¨å…¶ä½œç”¨åŸŸå†…è°ƒç”¨ï¼Œä½†æ˜¯å¤–éƒ¨ä»£ç æ— æ³•åˆ©ç”¨æ­¤æ–°è·¯å¾„ã€‚

å½“ä»£ç çš„å†…éƒ¨ç»“æ„ä¸è°ƒç”¨ä»£ç çš„ç¨‹åºå‘˜å¯¹åŸŸçš„æ€è€ƒæ–¹å¼ä¸åŒæ—¶ï¼Œé‡æ–°å¯¼å‡ºå¾ˆæœ‰ç”¨ã€‚

#### ä½¿ç”¨å¤–éƒ¨è½¯ä»¶åŒ…

è¯¥é¡¹ç›®ä½¿ç”¨ä¸€ä¸ªåä¸ºçš„å¤–éƒ¨è½¯ä»¶åŒ…randæ¥è·å–éšæœºæ•°ã€‚è¦randåœ¨çš„é¡¹ç›®ä¸­ä½¿ç”¨ï¼Œå°†æ­¤è¡Œæ·»åŠ åˆ°Cargo.tomlä¸­ï¼š

```toml
[dependencies]
rand = "0.5.5"

```

```rust
use rand::Rng;
fn main() {
    let secret_number = rand::thread_rng().gen_range(1, 101);
}

```

Rustç¤¾åŒºçš„æˆå‘˜å·²ç»åœ¨crates.ioä¸Šæä¾›äº†è®¸å¤šè½¯ä»¶åŒ… ï¼Œ

#### ä½¿ç”¨åµŒå¥—è·¯å¾„æ¸…ç†å¤§useåˆ—è¡¨

```rust

#![allow(unused_variables)]
fn main() {
use std::{cmp::Ordering, io};
// ---snip---
}

```

è¿™ä¸¤ä¸ªè·¯å¾„çš„å…±åŒéƒ¨åˆ†æ˜¯std::ioï¼Œè¿™å°±æ˜¯å®Œæ•´çš„ç¬¬ä¸€ä¸ªè·¯å¾„ã€‚è¦å°†è¿™ä¸¤ä¸ªè·¯å¾„åˆå¹¶ä¸ºä¸€æ¡useè¯­å¥ï¼Œå¯ä»¥ä½¿ç”¨selfåµŒå¥—è·¯å¾„ï¼Œ

```rust

#![allow(unused_variables)]
fn main() {
use std::io::{self, Write};
}
r4
```

#### å…¨å±€è¿ç®—ç¬¦

å¦‚æœè¦å°†è·¯å¾„ä¸­å®šä¹‰çš„æ‰€æœ‰å…¬å…±é¡¹ç›®éƒ½çº³å…¥èŒƒå›´ï¼Œå¯ä»¥æŒ‡å®šè¯¥è·¯å¾„ï¼Œåè·Ÿ*ï¼Œå…¨å±€è¿ç®—ç¬¦ï¼š

```rust

#![allow(unused_variables)]
fn main() {
use std::collections::*;
}
```

### ç”¨å®¹å™¨å­˜å‚¨å€¼åˆ—è¡¨

è¦ç ”ç©¶çš„ç¬¬ä¸€ä¸ªé›†åˆç±»å‹æ˜¯å®¹å™¨`Vec<T>`ã€‚å®¹å™¨ä½¿å¯ä»¥åœ¨å•ä¸ªæ•°æ®ç»“æ„ä¸­å­˜å‚¨å¤šä¸ªå€¼ï¼Œè¯¥ç»“æ„å°†æ‰€æœ‰å€¼å½¼æ­¤ç›¸é‚»æ”¾ç½®åœ¨å†…å­˜ä¸­ã€‚

è¦åˆ›å»ºä¸€ä¸ªæ–°çš„ç©ºå®¹å™¨ï¼Œå¯ä»¥è°ƒç”¨è¯¥Vec::newå‡½æ•°ï¼Œ

```rust

#![allow(unused_variables)]
fn main() {
let v: Vec<i32> = Vec::new();
}

```

åœ¨æ›´å®é™…çš„ä»£ç ä¸­ï¼ŒRusté€šå¸¸å¯ä»¥åœ¨æ’å…¥å€¼åå°±æ¨æ–­å‡ºè¦å­˜å‚¨çš„å€¼çš„ç±»å‹ï¼Œå› æ­¤å‡ ä¹ä¸éœ€è¦æ‰§è¡Œæ­¤ç±»å‹æ³¨é‡Šã€‚åˆ›å»º`Vec<T>`å…·æœ‰åˆå§‹å€¼çš„æ›´ä¸ºå¸¸è§ï¼ŒRustæä¾›äº†è¯¥vec!å®ä»¥æ–¹ä¾¿ä½¿ç”¨ã€‚å®å°†åˆ›å»ºä¸€ä¸ªæ–°å®¹å™¨ï¼Œå…¶ä¸­åŒ…å«æä¾›çš„å€¼ã€‚

```rust

#![allow(unused_variables)]
fn main() {
let v = vec![1, 2, 3];
}
```

#### æ›´æ–°vector

```rust

#![allow(unused_variables)]
fn main() {
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
}
```

#### åˆ é™¤vectorå…ƒç´ 

```rust

#![allow(unused_variables)]
fn main() {
{
    let v = vec![1, 2, 3, 4];

    // do stuff with v

} // <- v goes out of scope and is freed here
}

```

æ—¢ç„¶çŸ¥é“å¦‚ä½•åˆ›å»ºï¼Œæ›´æ–°å’Œé”€æ¯å®¹å™¨ï¼Œé‚£ä¹ˆä¸‹ä¸€æ­¥å°±æ˜¯äº†è§£å¦‚ä½•è¯»å–å®¹å™¨çš„å†…å®¹ã€‚æœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥å¼•ç”¨å­˜å‚¨åœ¨å®¹å™¨ä¸­çš„å€¼ã€‚

```rust

#![allow(unused_variables)]
fn main() {
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2];
println!("The third element is {}", third);

match v.get(2) {
    Some(third) => println!("The third element is {}", third),
    None => println!("There is no third element."),
}
}
```

Rustæœ‰ä¸¤ç§å¼•ç”¨å…ƒç´ çš„æ–¹å¼ï¼Œå› æ­¤å¯ä»¥é€‰æ‹©åœ¨å°è¯•ä½¿ç”¨å‘é‡æ²¡æœ‰å…ƒç´ çš„ç´¢å¼•å€¼æ—¶ç¨‹åºçš„è¡Œä¸ºã€‚

```rust

#![allow(unused_variables)]
fn main() {
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &v[100];
let does_not_exist = v.get(100);
}

```

#### éå†å®¹å™¨ä¸­çš„å€¼

```rust

#![allow(unused_variables)]
fn main() {
let v = vec![100, 32, 57];
for i in &v {
    println!("{}", i);
}
}
```

#### è¿­ä»£å¯¹å‘é‡ä¸­å…ƒç´ çš„å¯å˜å¼•ç”¨

```rust

#![allow(unused_variables)]
fn main() {
let mut v = vec![100, 32, 57];
for i in &mut v {
    *i += 50;
}
}
```

#### å®šä¹‰å°†ä¸€ä¸ªenumä¸åŒç±»å‹çš„å€¼å­˜å‚¨åœ¨ä¸€ä¸ªå‘é‡ä¸­

```rust

#![allow(unused_variables)]
fn main() {
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
}

```

### Rustå­—ç¬¦ä¸²

ä»newåˆ›å»ºå­—ç¬¦ä¸²çš„å‡½æ•°

```rust

#![allow(unused_variables)]
fn main() {
let mut s = String::new();
}
```

#### ä½¿ç”¨è¯¥to_stringæ–¹æ³•Stringä»å­—ç¬¦ä¸²æ–‡å­—åˆ›å»ºä¸€ä¸ª

```rust

#![allow(unused_variables)]
fn main() {
let data = "initial contents";

let s = data.to_string();

// the method also works on a literal directly:
let s = "initial contents".to_string();
}

```

å­—ç¬¦ä¸²æ˜¯UTF-8ç¼–ç çš„ï¼Œå› æ­¤å¯ä»¥åœ¨å…¶ä¸­åŒ…å«ä»»ä½•æ­£ç¡®ç¼–ç çš„æ•°æ®ï¼Œ

```rust

#![allow(unused_variables)]
fn main() {
let hello = String::from("Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…");
let hello = String::from("DobrÃ½ den");
let hello = String::from("Hello");
let hello = String::from("×©Ö¸××œ×•Ö¹×");
let hello = String::from("à¤¨à¤®à¤¸à¥à¤¤à¥‡");
let hello = String::from("ã“ã‚“ã«ã¡ã¯");
let hello = String::from("ì•ˆë…•í•˜ì„¸ìš”");
let hello = String::from("å¥½");
let hello = String::from("OlÃ¡");
let hello = String::from("Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ");
let hello = String::from("Hola");
}
```

**æ›´æ–°å­—ç¬¦ä¸²**

```rust

#![allow(unused_variables)]
fn main() {
let mut s = String::from("foo");
s.push_str("bar");
}

```

**ä¸+è¿ç®—ç¬¦æˆ–format!å®ä¸²è”**

```rust

#![allow(unused_variables)]
fn main() {
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used
}

```

```rust

#![allow(unused_variables)]
fn main() {
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{}-{}-{}", s1, s2, s3);
}

```

**éå†å­—ç¬¦ä¸²**

```rust

#![allow(unused_variables)]
fn main() {
for c in "à¤¨à¤®à¤¸à¥à¤¤à¥‡".chars() {
    println!("{}", c);
}
}
```

```rust

#![allow(unused_variables)]
fn main() {
for b in "à¤¨à¤®à¤¸à¥à¤¤à¥‡".bytes() {
    println!("{}", b);
}
}

```

### Rustå“ˆå¸Œ

```rust

#![allow(unused_variables)]
fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);
}

```

```rust

#![allow(unused_variables)]
fn main() {
use std::collections::HashMap;

let teams  = vec![String::from("Blue"), String::from("Yellow")];
let initial_scores = vec![10, 50];

let scores: HashMap<_, _> = teams.iter().zip(initial_scores.iter()).collect();
}

```

**å“ˆå¸Œå’Œæ‰€æœ‰æƒ**

```rust

#![allow(unused_variables)]
fn main() {
use std::collections::HashMap;

let field_name = String::from("Favorite color");
let field_value = String::from("Blue");

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name and field_value are invalid at this point, try using them and
// see what compiler error you get!
}

```

**è®¿é—®éå†å“ˆå¸Œçš„å€¼**

```rust

#![allow(unused_variables)]
fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

let team_name = String::from("Blue");
let score = scores.get(&team_name);
}

```

```rust

#![allow(unused_variables)]
fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

for (key, value) in &scores {
    println!("{}: {}", key, value);
}
}

```

é€šå¸¸æ£€æŸ¥ç‰¹å®šé”®æ˜¯å¦å…·æœ‰å€¼ï¼Œå¦‚æœæ²¡æœ‰ï¼Œè¯·ä¸ºå…¶æ’å…¥å€¼ã€‚å“ˆå¸Œæ˜ å°„ä¸ºæ­¤æœ‰ä¸€ä¸ªç‰¹æ®Šçš„API entry ï¼Œå®ƒå°†æƒ³è¦æ£€æŸ¥çš„é”®ä½œä¸ºå‚æ•°ã€‚è¯¥entryæ–¹æ³•çš„è¿”å›å€¼ æ˜¯ä¸€ä¸ªç§°ä¸ºçš„æšä¸¾Entryï¼Œè¡¨ç¤ºå¯èƒ½å­˜åœ¨æˆ–å¯èƒ½ä¸å­˜åœ¨çš„å€¼ã€‚å‡è®¾è¦æ£€æŸ¥Yellowå›¢é˜Ÿçš„å¯†é’¥æ˜¯å¦å…·æœ‰ä¸å…¶å…³è”çš„å€¼ã€‚å¦‚æœä¸æ˜¯ï¼Œè¦æ’å…¥å€¼50ï¼Œè“è‰²å›¢é˜Ÿä¹Ÿè¦æ’å…¥å€¼50ã€‚ä½¿ç”¨entryAPIï¼Œ

```rust

#![allow(unused_variables)]
fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);

scores.entry(String::from("Yellow")).or_insert(50);
scores.entry(String::from("Blue")).or_insert(50);

println!("{:?}", scores);
}

```

**æ ¹æ®æ—§å€¼æ›´æ–°å€¼**

```rust

#![allow(unused_variables)]
fn main() {
use std::collections::HashMap;

let text = "hello world wonderful world";

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!("{:?}", map);
}

```

#### Rustæ•£åˆ—å‡½æ•°

é»˜è®¤æƒ…å†µä¸‹ï¼ŒHashMapä½¿ç”¨â€œåŠ å¯†å¼ºåº¦é«˜â€çš„1å“ˆå¸Œå‡½æ•°ï¼Œè¯¥å‡½æ•°å¯ä»¥æŠµæŠ—æ‹’ç»æœåŠ¡ï¼ˆDoSï¼‰æ”»å‡»ã€‚è¿™ä¸æ˜¯å¯ç”¨çš„æœ€å¿«çš„å“ˆå¸Œç®—æ³•ï¼Œä½†æ˜¯æ€§èƒ½ä¸‹é™å¸¦æ¥çš„æ›´å¥½å®‰å…¨æ€§çš„æƒè¡¡æ˜¯å€¼å¾—çš„ã€‚å¦‚æœå¯¹ä»£ç è¿›è¡Œæ¦‚è¦åˆ†æå¹¶å‘ç°é»˜è®¤çš„å“ˆå¸Œå‡½æ•°å¯¹äºçš„ç›®çš„è€Œè¨€å¤ªæ…¢ï¼Œåˆ™å¯ä»¥é€šè¿‡æŒ‡å®šå…¶ä»–hasheræ¥åˆ‡æ¢åˆ°å¦ä¸€ä¸ªå‡½æ•° ã€‚æ•£åˆ—å™¨æ˜¯å®ç°BuildHasherç‰¹å¾çš„ä¸€ç§ç±»å‹ã€‚

### Rusté”™è¯¯å¤„ç†

panic!å®å¼•å‘é”™è¯¯

#### å¯æ¢å¤é”™è¯¯Result

```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => {
            panic!("Problem opening the file: {:?}", error)
        },
    };
}

```

**åŒ¹é…ä¸åŒçš„é”™è¯¯**

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            other_error => panic!("Problem opening the file: {:?}", other_error),
        },
    };
}

```

File::openåœ¨Errå˜ä½“å†…éƒ¨è¿”å›çš„å€¼çš„ç±»å‹ä¸º io::Errorï¼Œè¿™æ˜¯æ ‡å‡†åº“æä¾›çš„ç»“æ„ã€‚è¯¥ç»“æ„å…·æœ‰ä¸€ä¸ªkindå¯ä»¥è°ƒç”¨ä»¥è·å–io::ErrorKindå€¼çš„æ–¹æ³•ã€‚æšä¸¾ io::ErrorKindç”±æ ‡å‡†åº“æä¾›ï¼Œå¹¶ä¸”å…·æœ‰è¡¨ç¤ºio æ“ä½œå¯èƒ½å¯¼è‡´çš„å„ç§é”™è¯¯çš„å˜ä½“ã€‚è¦ä½¿ç”¨çš„å˜ä½“æ˜¯ErrorKind::NotFoundï¼Œè¡¨ç¤ºè¦æ‰“å¼€çš„æ–‡ä»¶å°šä¸å­˜åœ¨ã€‚æ‰€ä»¥åŒ¹é…fï¼Œä½†ä¹Ÿæœ‰ä¸€ä¸ªå†…éƒ¨åŒ¹é…error.kind()ã€‚

è¦æ£€æŸ¥å†…éƒ¨åŒ¹é…é¡¹çš„æ¡ä»¶æ˜¯ï¼Œè¿”å›çš„å€¼æ˜¯å¦ä¸ºæšä¸¾error.kind()çš„NotFoundå˜ä½“ErrorKindã€‚å¦‚æœæ˜¯è¿™æ ·ï¼Œå°è¯•ä½¿ç”¨åˆ›å»ºæ–‡ä»¶File::createã€‚ä½†æ˜¯ï¼Œç”±äºFile::create ä¹Ÿå¯èƒ½å¤±è´¥ï¼Œå› æ­¤éœ€è¦åœ¨å†…éƒ¨matchè¡¨è¾¾å¼ä¸­æ·»åŠ ç¬¬äºŒä¸ªåˆ†æ”¯ã€‚æ— æ³•åˆ›å»ºæ–‡ä»¶æ—¶ï¼Œå°†è¾“å‡ºå…¶ä»–é”™è¯¯æ¶ˆæ¯ã€‚å¤–éƒ¨çš„ç¬¬äºŒä¸ªè‡‚matchä¿æŒä¸å˜ï¼Œå› æ­¤ç¨‹åºä¼šå› ç¼ºå°‘æ–‡ä»¶é”™è¯¯è€Œå¯¹ä»»ä½•é”™è¯¯æ„Ÿåˆ°é”™è¯¯ã€‚

å¥½å¤šmatchï¼è¯¥matchè¡¨è¾¾å¼éå¸¸æœ‰ç”¨ï¼Œä½†ä¹Ÿéå¸¸åŸå§‹ã€‚åœ¨ç¬¬13ç« ä¸­ï¼Œå°†å­¦ä¹ é—­åŒ…ã€‚è¯¥`Result<T, E>`ç±»å‹å…·æœ‰è®¸å¤šæ¥å—é—­åŒ…å¹¶ä½¿ç”¨matchè¡¨è¾¾å¼å®ç°çš„æ–¹æ³• ã€‚ä½¿ç”¨è¿™äº›æ–¹æ³•å°†ä½¿çš„ä»£ç æ›´ç®€æ´ã€‚

```rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {:?}", error);
            })
        } else {
            panic!("Problem opening the file: {:?}", error);
        }
    });
}
```

```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt").unwrap();
}

```

expectç±»ä¼¼äºçš„å¦ä¸€ç§æ–¹æ³•ï¼Œunwrapè®©ä¹Ÿå¯ä»¥é€‰æ‹© panic!é”™è¯¯æ¶ˆæ¯ã€‚ä½¿ç”¨expectä»£æ›¿unwrapå¹¶æä¾›è‰¯å¥½çš„é”™è¯¯æ¶ˆæ¯å¯ä»¥ä¼ è¾¾çš„æ„å›¾ï¼Œå¹¶ä½¿è·Ÿè¸ªé”™è¯¯çš„æ ¹æºæ›´åŠ å®¹æ˜“ã€‚

```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt").expect("Failed to open hello.txt");
}

```

**ä¼ æ’­é”™è¯¯**

å½“ç¼–å†™ä¸€ä¸ªå‡½æ•°çš„å®ç°è°ƒç”¨å¯èƒ½å¤±è´¥çš„å‡½æ•°æ—¶ï¼Œå¯ä»¥å°†é”™è¯¯è¿”å›ç»™è°ƒç”¨ä»£ç ï¼Œä»¥ä¾¿å®ƒå¯ä»¥å†³å®šè¦åšä»€ä¹ˆï¼Œè€Œä¸æ˜¯å¤„ç†è¯¥å‡½æ•°ä¸­çš„é”™è¯¯ã€‚è¿™è¢«ç§°ä¸º ä¼ æ’­é”™è¯¯ï¼Œå¹¶èµ‹äºˆäº†è°ƒç”¨ä»£ç æ›´å¤šçš„æ§åˆ¶æƒï¼Œåœ¨è¿™é‡Œï¼Œå¯èƒ½æœ‰æ›´å¤šçš„ä¿¡æ¯æˆ–é€»è¾‘è§„å®šäº†é”™è¯¯çš„å¤„ç†æ–¹å¼ï¼Œè€Œä¸æ˜¯åœ¨ä»£ç ä¸Šä¸‹æ–‡ä¸­å¯ç”¨çš„ä¿¡æ¯æˆ–é€»è¾‘ã€‚

```rust

#![allow(unused_variables)]
fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -> Result<String, io::Error> {
    let f = File::open("hello.txt");

    let mut f = match f {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&mut s) {
        Ok(_) => Ok(s),
        Err(e) => Err(e),
    }
}
}

```

**ä¼ æ’­é”™è¯¯çš„æ·å¾„ï¼š?è¿ç®—ç¬¦**

```rust

#![allow(unused_variables)]
fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut f = File::open("hello.txt")?;
    let mut s = String::new();
    f.read_to_string(&mut s)?;
    Ok(s)
}
}

```

```rust

#![allow(unused_variables)]
fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut s = String::new();

    File::open("hello.txt")?.read_to_string(&mut s)?;

    Ok(s)
}
}

```

å°†æ–‡ä»¶è¯»å…¥å­—ç¬¦ä¸²æ˜¯ä¸€ä¸ªç›¸å½“å¸¸è§çš„æ“ä½œï¼Œå› æ­¤Rustæä¾›äº†ä¾¿æ·çš„fs::read_to_stringåŠŸèƒ½æ¥æ‰“å¼€æ–‡ä»¶ï¼Œåˆ›å»ºæ–°æ–‡ä»¶ Stringï¼Œè¯»å–æ–‡ä»¶å†…å®¹ï¼Œå°†å†…å®¹æ”¾å…¥æ–‡ä»¶ä¸­Stringå¹¶è¿”å›ã€‚å½“ç„¶ï¼Œä½¿ç”¨fs::read_to_stringä¸ä¼šç»™æä¾›è§£é‡Šæ‰€æœ‰é”™è¯¯å¤„ç†çš„æœºä¼šï¼Œå› æ­¤é¦–å…ˆé‡‡ç”¨äº†æ›´é•¿çš„æ–¹æ³•ã€‚

```rust

#![allow(unused_variables)]
fn main() {
use std::io;
use std::fs;

fn read_username_from_file() -> Result<String, io::Error> {
    fs::read_to_string("hello.txt")
}
}

```

è®©çœ‹çœ‹å¦‚æœ?åœ¨mainå‡½æ•°ä¸­ä½¿ç”¨è¿ç®—ç¬¦ä¼šå‘ç”Ÿä»€ä¹ˆï¼Œä¼šè®°å¾—å®ƒçš„è¿”å›ç±»å‹ä¸º()ï¼š

```rust
use std::fs::File;

fn main() {
    let f = File::open("hello.txt")?;
}

```

```rust
error[E0277]: the `?` operator can only be used in a function that returns
`Result` or `Option` (or another type that implements `std::ops::Try`)
 --> src/main.rs:4:13
  |
4 |     let f = File::open("hello.txt")?;
  |             ^^^^^^^^^^^^^^^^^^^^^^^^ cannot use the `?` operator in a
  function that returns `()`
  |
  = help: the trait `std::ops::Try` is not implemented for `()`
  = note: required by `std::ops::Try::from_error`

```

è¯¥é”™è¯¯æŒ‡å‡ºåªå…è®¸?åœ¨è¿”å›çš„å‡½æ•°`Result`æˆ–`Option`å®ç°çš„å…¶ä»–ç±»å‹ä¸­ ä½¿ç”¨è¿ç®—ç¬¦`std::ops::Try`ã€‚å½“åœ¨ä¸è¿”å›è¿™äº›ç±»å‹ä¹‹ä¸€çš„å‡½æ•°ä¸­ç¼–å†™ä»£ç æ—¶ï¼Œå¹¶ä¸”è¦?åœ¨è°ƒç”¨è¿”å›å…¶ä»–å‡½æ•°çš„å…¶ä»–å‡½æ•°æ—¶ä½¿ç”¨`Result<T, E>`ï¼Œæœ‰ä¸¤ç§é€‰æ‹©å¯ä»¥è§£å†³æ­¤é—®é¢˜ã€‚ä¸€ç§æŠ€æœ¯æ˜¯å°†å‡½æ•°çš„è¿”å›ç±»å‹æ›´æ”¹ä¸º`Result<T, E>`åœ¨æ²¡æœ‰é™åˆ¶çš„æƒ…å†µä¸‹è¿”å›ã€‚å¦ä¸€ç§æŠ€æœ¯æ˜¯ä½¿ç”¨ä¸€ç§matchæˆ–å¤šç§`Result<T, E>`æ–¹æ³•ä»¥`Result<T, E>`é€‚å½“çš„æ–¹å¼è¿›è¡Œå¤„ç†ã€‚

è¯¥mainå‡½æ•°æ˜¯ç‰¹æ®Šçš„ï¼Œå¹¶ä¸”å¯¹å®ƒçš„è¿”å›ç±»å‹å¿…é¡»æœ‰é™åˆ¶ã€‚mainçš„ä¸€ç§æœ‰æ•ˆè¿”å›ç±»å‹æ˜¯()ï¼Œå¹¶ä¸”æ–¹ä¾¿åœ°ï¼Œå¦ä¸€ç§æœ‰æ•ˆè¿”å›ç±»å‹æ˜¯Result<T, E>ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```rust
use std::error::Error;
use std::fs::File;

fn main() -> Result<(), Box<dyn Error>> {
    let f = File::open("hello.txt")?;

    Ok(())
}
```

è¯¥`Box<dyn Error>`ç±»å‹ç§°ä¸ºç‰¹å¾å¯¹è±¡ï¼Œ

### æ˜¯å¦ä½¿ç”¨panic!å‡½æ•°

```rust

#![allow(unused_variables)]
fn main() {
use std::net::IpAddr;

let home: IpAddr = "127.0.0.1".parse().unwrap();
}

```

IpAddré€šè¿‡è§£æç¡¬ç¼–ç å­—ç¬¦ä¸²æ¥åˆ›å»ºå®ä¾‹ã€‚å¯ä»¥çœ‹åˆ°è¿™127.0.0.1æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„IPåœ°å€ï¼Œå› æ­¤å¯ä»¥åœ¨unwrap æ­¤å¤„ä½¿ç”¨ã€‚ä½†æ˜¯ï¼Œä½¿ç”¨ç»è¿‡ç¡¬ç¼–ç çš„æœ‰æ•ˆå­—ç¬¦ä¸²ä¸ä¼šæ›´æ”¹æ–¹æ³•çš„è¿”å›ç±»å‹parseï¼šä»ç„¶ä¼šè·å¾—ä¸€ä¸ªResultå€¼ï¼Œå¹¶ä¸”ç¼–è¯‘å™¨ä»å°†ä½¿èƒ½å¤ŸResultåƒå¤„ç†Errå˜ä½“é‚£æ ·å¤„ç†è¯¥å˜é‡ï¼Œå› ä¸ºç¼–è¯‘å™¨ä¸å¤Ÿèªæ˜ï¼Œæ— æ³•çœ‹åˆ°æ­¤å­—ç¬¦ä¸²å§‹ç»ˆæ˜¯æœ‰æ•ˆçš„IPåœ°å€ã€‚å¦‚æœIPåœ°å€å­—ç¬¦ä¸²æ¥è‡ªç”¨æˆ·è€Œä¸æ˜¯ç¡¬ç¼–ç åˆ°ç¨‹åºä¸­ï¼Œå› æ­¤ç¡®å®æœ‰å¤±è´¥çš„å¯èƒ½æ€§ï¼Œè‚¯å®šå¸Œæœ›ä»¥Resultæ›´å¯é çš„æ–¹å¼å¤„ç†å®ƒã€‚

```rust
loop {
    // --snip--

    let guess: i32 = match guess.trim().parse() {
        Ok(num) => num,
        Err(_) => continue,
    };

    if guess < 1 || guess > 100 {
        println!("The secret number will be between 1 and 100.");
        continue;
    }

    match guess.cmp(&secret_number) {
    // --snip--
}

```

å¯ä»¥åˆ›å»ºä¸€ä¸ªæ–°ç±»å‹å¹¶å°†éªŒè¯æ”¾å…¥å‡½æ•°ä¸­ä»¥åˆ›å»ºè¯¥ç±»å‹çš„å®ä¾‹ï¼Œè€Œä¸æ˜¯åœ¨æ‰€æœ‰åœ°æ–¹é‡å¤è¿›è¡ŒéªŒè¯ã€‚è¿™æ ·ï¼Œå‡½æ•°åœ¨ç­¾åä¸­ä½¿ç”¨æ–°ç±»å‹å¹¶æ”¾å¿ƒä½¿ç”¨å…¶æ¥æ”¶çš„å€¼æ˜¯å®‰å…¨çš„ã€‚

```rust

#![allow(unused_variables)]
fn main() {
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }

        Guess {
            value
        }
    }

    pub fn value(&self) -> i32 {
        self.value
    }
}
}

```

### é€šç”¨ç±»å‹ï¼Œç‰¹å¾å’Œå¯¿å‘½

```rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
 assert_eq!(largest, 100);
}

```

```rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}

```

```rust
fn largest<T>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}

```

å¦‚æœç°åœ¨ç¼–è¯‘æ­¤ä»£ç ï¼Œåˆ™ä¼šæ”¶åˆ°æ­¤é”™è¯¯ï¼š

```rust
error[E0369]: binary operation `>` cannot be applied to type `T`
 --> src/main.rs:5:12
  |
5 |         if item > largest {
  |            ^^^^^^^^^^^^^^
  |
  = note: an implementation of `std::cmp::PartialOrd` might be missing for `T`

```

è¿˜å¯ä»¥ä½¿ç”¨`<>`è¯­æ³•åœ¨ä¸€ä¸ªæˆ–å¤šä¸ªå­—æ®µä¸­å®šä¹‰ç»“æ„ä»¥ä½¿ç”¨é€šç”¨ç±»å‹å‚æ•°ã€‚

```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}

```

åœ¨ç»“æ„å®šä¹‰ä¸­ä½¿ç”¨æ³›å‹çš„è¯­æ³•ç±»ä¼¼äºåœ¨å‡½æ•°å®šä¹‰ä¸­ä½¿ç”¨çš„è¯­æ³•ã€‚é¦–å…ˆï¼Œåœ¨ç»“æ„åç§°ä¹‹åçš„å°–æ‹¬å·å†…å£°æ˜ç±»å‹å‚æ•°çš„åç§°ã€‚ç„¶åï¼Œå¯ä»¥åœ¨ç»“æ„å®šä¹‰ä¸­ä½¿ç”¨æ³›å‹ç±»å‹ï¼Œå¦åˆ™å°†æŒ‡å®šå…·ä½“çš„æ•°æ®ç±»å‹ã€‚

è¯·æ³¨æ„ï¼Œå› ä¸ºåªç”¨ä¸€ä¸ªæ³›å‹ç±»å‹å®šä¹‰`Point<T>`ï¼Œè¿™ä¸ªå®šä¹‰è¯´ï¼Œ`Point<T>`ç»“æ„æ˜¯é€šç”¨åœ¨æŸç§ç±»å‹çš„Tï¼Œå’Œç”°é‡xï¼Œå¹¶yæœ‰ä¸¤ä¸ªåŒç±»å‹çš„ï¼Œæ— è®ºè¯¥ç±»å‹è€Œå®šã€‚å¦‚æœåˆ›å»ºä¸€ä¸ª`Point<T>`å…·æœ‰ä¸åŒç±»å‹å€¼çš„å®ä¾‹ï¼Œä»£ç å°†æ— æ³•ç¼–è¯‘ã€‚

```rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}

```

å¯ä»¥å®šä¹‰æšä¸¾ä»¥å°†é€šç”¨æ•°æ®ç±»å‹ä¿å­˜åœ¨å®ƒä»¬çš„å˜é‡ä¸­ã€‚çœ‹çœ‹`Option<T>`å’Œ`Result<T, E>`æ ‡å‡†åº“æä¾›çš„æšä¸¾ï¼Œ

```rust

#![allow(unused_variables)]
fn main() {
enum Option<T> {
    Some(T),
    None,
}
}
```

```rust

#![allow(unused_variables)]
fn main() {
enum Result<T, E> {
    Ok(T),
    Err(E),
}
}

```

**èŒƒå‹æ–¹æ³•**

```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
```

å¯ä»¥ä»…åœ¨`Point<f32>`å®ä¾‹ä¸Šå®ç°æ–¹æ³•ï¼Œè€Œä¸èƒ½åœ¨`Point<T>`å…·æœ‰ä»»ä½•æ³›å‹ç±»å‹çš„å®ä¾‹ä¸Šå®ç°æ–¹æ³•ã€‚

```rust

#![allow(unused_variables)]
fn main() {
struct Point<T> {
    x: T,
    y: T,
}

impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
}

```

ç»“æ„å®šä¹‰ä¸­çš„æ³›å‹ç±»å‹å‚æ•°å¹¶ä¸æ€»æ˜¯ä¸è¯¥ç»“æ„çš„æ–¹æ³•ç­¾åä¸­ä½¿ç”¨çš„å‚æ•°ç›¸åŒã€‚ä¾‹å¦‚ï¼Œ

```rust
struct Point<T, U> {
    x: T,
    y: U,
}

impl<T, U> Point<T, U> {
    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c'};

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}

```

Rusté€šè¿‡åœ¨ç¼–è¯‘æ—¶å¯¹ä½¿ç”¨æ³›å‹çš„ä»£ç è¿›è¡Œå•æ€åŒ–æ¥å®ç°è¿™ä¸€ç‚¹ã€‚å•è‰²åŒ–æ˜¯é€šè¿‡å¡«å……ç¼–è¯‘æ—¶ä½¿ç”¨çš„å…·ä½“ç±»å‹ï¼Œå°†é€šç”¨ä»£ç è½¬æ¢ä¸ºç‰¹å®šä»£ç çš„è¿‡ç¨‹ã€‚

åœ¨æ­¤è¿‡ç¨‹ä¸­ï¼Œ

### ç‰¹æ€§ï¼šå®šä¹‰å…±åŒçš„è¡Œä¸º

ç±»å‹çš„è¡Œä¸ºç”±å¯ä»¥åœ¨è¯¥ç±»å‹ä¸Šè°ƒç”¨çš„æ–¹æ³•ç»„æˆã€‚å¦‚æœå¯ä»¥å¯¹æ‰€æœ‰è¿™äº›ç±»å‹è°ƒç”¨ç›¸åŒçš„æ–¹æ³•ï¼Œåˆ™ä¸åŒçš„ç±»å‹å…·æœ‰ç›¸åŒçš„è¡Œä¸ºã€‚ç‰¹æ€§å®šä¹‰æ˜¯ä¸€ç§å°†æ–¹æ³•ç­¾åç»„åˆåœ¨ä¸€èµ·ä»¥å®šä¹‰å®ç°æŸäº›ç›®çš„æ‰€éœ€çš„è¡Œä¸ºçš„æ–¹æ³•ã€‚

ä¸¾ä¾‹æ¥è¯´ï¼Œå‡è®¾æœ‰å¤šç§ç»“æ„ï¼Œå¯å®¹çº³å„ç§ç±»å‹å’Œæ•°é‡çš„æ–‡æœ¬ï¼šä¸€ç§NewsArticleç»“æ„ï¼Œå¯å®¹çº³åœ¨ç‰¹å®šä½ç½®å½’æ¡£çš„æ–°é—»æŠ¥å¯¼ï¼Œå¹¶ä¸”ç»“æ„Tweetæœ€å¤šå¯åŒ…å«280ä¸ªå­—ç¬¦ä»¥åŠæŒ‡ç¤ºå®ƒæ˜¯å¦ä¸ºæ–°æ¨æ–‡çš„å…ƒæ•°æ®ï¼Œè½¬å‘æˆ–å›å¤å…¶ä»–æ¨æ–‡ã€‚

æƒ³è¦åˆ¶ä½œä¸€ä¸ªåª’ä½“èšåˆå™¨åº“ï¼Œä»¥æ˜¾ç¤ºå¯èƒ½å­˜å‚¨åœ¨NewsArticleæˆ–Tweetå®ä¾‹ä¸­çš„æ•°æ®æ‘˜è¦ã€‚ä¸ºæ­¤ï¼Œéœ€è¦æ¯ç§ç±»å‹çš„æ‘˜è¦ï¼Œå¹¶ä¸”éœ€è¦é€šè¿‡summarizeåœ¨å®ä¾‹ä¸Šè°ƒç”¨æ–¹æ³•æ¥è¯·æ±‚è¯¥æ‘˜è¦ ã€‚

```rust

#![allow(unused_variables)]
fn main() {
pub trait Summary {
    fn summarize(&self) -> String;
}
}

```

#### åœ¨ç±»å‹ä¸Šå®ç°ç‰¹è´¨

```rust

#![allow(unused_variables)]
fn main() {
pub trait Summary {
    fn summarize(&self) -> String;
}

pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
}

```

#### ç‰¹æ€§ä½œä¸ºå‚æ•°

```rust
pub fn notify(item: impl Summary) {
    println!("Breaking news! {}", item.summarize());
}

```

#### ç‰¹æ€§ç»‘å®šè¯­æ³•

```rust
pub fn notify<T: Summary>(item: T) {
    println!("Breaking news! {}", item.summarize());
}

```

è¯¥impl Traitè¯­æ³•æ˜¯æ–¹ä¾¿ï¼Œä½¿å¾—åœ¨ç®€å•çš„æƒ…å†µä¸‹ï¼Œæ›´ç®€æ´çš„ä»£ç ã€‚åœ¨å…¶ä»–æƒ…å†µä¸‹ï¼Œç‰¹å¾ç»‘å®šè¯­æ³•å¯ä»¥è¡¨ç¤ºæ›´å¤šçš„å¤æ‚æ€§ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥æœ‰ä¸¤ä¸ªå®ç°çš„å‚æ•°Summaryã€‚ä½¿ç”¨impl Traitè¯­æ³•å¦‚ä¸‹æ‰€ç¤ºï¼š

```rust
pub fn notify(item1: impl Summary, item2: impl Summary) {

```

æˆ–è€…

```rust
pub fn notify<T: Summary>(item1: T, item2: T) {

```

**ä½¿ç”¨+è¯­æ³•æŒ‡å®šå¤šä¸ªç‰¹å¾ç•Œçº¿**

```rust
pub fn notify(item: impl Summary + Display) {

```

```rust
pub fn notify<T: Summary + Display>(item: T) {

```

**å…·æœ‰whereæ¡æ¬¾çš„æ›´æ¸…æ™°çš„ç‰¹è´¨ç•Œé™**

```rust
fn some_function<T, U>(t: T, u: U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{

```

è¿˜å¯ä»¥impl Traitåœ¨è¿”å›ä½ç½®ä½¿ç”¨è¯­æ³•æ¥è¿”å›å®ç°ç‰¹å¾çš„æŸç§ç±»å‹çš„å€¼ï¼Œ

```rust
fn returns_summarizable() -> impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from("of course, as you probably already know, people"),
        reply: false,
        retweet: false,
    }
}

```

```rust
fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}

```

è¿‡ä½¿ç”¨ä¸implä½¿ç”¨é€šç”¨ç±»å‹å‚æ•°çš„å—ç»‘å®šçš„ç‰¹å¾ï¼Œå¯ä»¥æœ‰æ¡ä»¶åœ°ä¸ºå®ç°æŒ‡å®šç‰¹å¾çš„ç±»å‹å®ç°æ–¹æ³•ã€‚ä¾‹å¦‚ï¼Œ`Pair<T>`ç±»å‹å§‹ç»ˆå®ç°è¯¥ newåŠŸèƒ½ã€‚ä½†`Pair<T>`ä»…å®ç°cmp_displayæ–¹æ³•ï¼Œå¦‚æœå…¶å†…å‹Tå™¨å…·çš„PartialOrdï¼Œä½¿æ¯”è¾ƒæ€§çŠ¶å’Œ æ‰€è¿°Displayä½¿æ‰“å°æ€§çŠ¶ã€‚

```rust

#![allow(unused_variables)]
fn main() {
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self {
            x,
            y,
        }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
}

```

å¯¹äºä»»ä½•å®ç°äº†å¦ä¸€ä¸ªç‰¹å¾çš„ç±»å‹ï¼Œä¹Ÿå¯ä»¥æœ‰æ¡ä»¶åœ°å®ç°ä¸€ä¸ªç‰¹å¾ã€‚æ»¡è¶³ç‰¹å¾ç•Œé™çš„ä»»ä½•ç±»å‹çš„ç‰¹å¾å®ç°éƒ½ç§°ä¸ºè¦†ç›–å®ç°ï¼Œå¹¶ä¸”åœ¨Rustæ ‡å‡†åº“ä¸­å¾—åˆ°äº†å¹¿æ³›çš„ä½¿ç”¨ã€‚ä¾‹å¦‚ï¼Œæ ‡å‡†åº“å¯ä»¥åœ¨å®ç° ToStringç‰¹å¾çš„ä»»ä½•ç±»å‹ä¸Šå®ç°Displayç‰¹å¾ã€‚impl æ ‡å‡†åº“ä¸­çš„å—ç±»ä¼¼äºä»¥ä¸‹ä»£ç ï¼š

```rust
impl<T: Display> ToString for T {
    // --snip--
}

```

å› ä¸ºæ ‡å‡†åº“å…·æœ‰è¿™ç§å…¨é¢çš„å®ç°ï¼Œæ‰€ä»¥å¯ä»¥åœ¨å®ç°è¯¥ç‰¹æ€§çš„ä»»ä½•ç±»å‹ä¸Šè°ƒç”¨to_stringç”±ToStringtrait å®šä¹‰çš„ æ–¹æ³•Displayã€‚ä¾‹å¦‚ï¼Œå¯ä»¥Stringåƒè¿™æ ·å°†æ•´æ•°è½¬æ¢ä¸ºå…¶ç›¸åº”çš„ å€¼ï¼Œå› ä¸ºæ•´æ•°å®ç°Displayï¼š

```rust

#![allow(unused_variables)]
fn main() {
let s = 3.to_string();
}

```

ç‰¹è´¨å’Œç‰¹å¾è¾¹ç•Œä½¿å¯ä»¥ç¼–å†™ä½¿ç”¨é€šç”¨ç±»å‹å‚æ•°å‡å°‘é‡å¤çš„ä»£ç ï¼ŒåŒæ—¶è¿˜å‘ç¼–è¯‘å™¨æŒ‡å®šå¸Œæœ›é€šç”¨ç±»å‹å…·æœ‰ç‰¹å®šè¡Œä¸ºã€‚ç„¶åï¼Œç¼–è¯‘å™¨å¯ä»¥ä½¿ç”¨ç‰¹å¾ç»‘å®šä¿¡æ¯æ¥æ£€æŸ¥ä¸çš„ä»£ç ä¸€èµ·ä½¿ç”¨çš„æ‰€æœ‰å…·ä½“ç±»å‹æ˜¯å¦æä¾›æ­£ç¡®çš„è¡Œä¸ºã€‚åœ¨åŠ¨æ€ç±»å‹çš„è¯­è¨€ä¸­ï¼Œå¦‚æœåœ¨æœªå®ç°å®šä¹‰è¯¥æ–¹æ³•çš„ç±»å‹çš„ç±»å‹ä¸Šè°ƒç”¨æ–¹æ³•ï¼Œåˆ™åœ¨è¿è¡Œæ—¶ä¼šå‡ºé”™ã€‚ä½†æ˜¯Rustä¼šå°†è¿™äº›é”™è¯¯è½¬ç§»åˆ°ç¼–è¯‘æ—¶ï¼Œå› æ­¤ä¸å¾—ä¸åœ¨ä»£ç æ— æ³•è¿è¡Œä¹‹å‰è§£å†³é—®é¢˜ã€‚å¦å¤–ï¼Œä¸å¿…ç¼–å†™åœ¨è¿è¡Œæ—¶æ£€æŸ¥è¡Œä¸ºçš„ä»£ç ï¼Œå› ä¸ºå·²ç»åœ¨ç¼–è¯‘æ—¶è¿›è¡Œäº†æ£€æŸ¥ã€‚è¿™æ ·åšå¯ä»¥æé«˜æ€§èƒ½ï¼Œè€Œä¸å¿…æ”¾å¼ƒæ³›å‹çš„çµæ´»æ€§ã€‚

### ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸéªŒè¯å¼•ç”¨

ç”Ÿå‘½å‘¨æœŸçš„ä¸»è¦ç›®çš„æ˜¯é˜²æ­¢æ‚¬è€Œæœªå†³çš„å¼•ç”¨ï¼Œè¿™äº›å¼•ç”¨ä½¿ç¨‹åºå¼•ç”¨çš„ä¸æ˜¯å…¶è¦å¼•ç”¨çš„æ•°æ®ã€‚è€ƒè™‘ä¸‹é¢çš„ç¨‹åºï¼Œå®ƒå…·æœ‰ä¸€ä¸ªå¤–éƒ¨ä½œç”¨åŸŸå’Œä¸€ä¸ªå†…éƒ¨ä½œç”¨åŸŸã€‚

```rust
{
    let r;

    {
        let x = 5;
        r = &x;
    }

    println!("r: {}", r);
}
```

å¤–éƒ¨ä½œç”¨åŸŸå£°æ˜ä¸€ä¸ªræ²¡æœ‰åˆå§‹å€¼çš„å˜é‡ï¼Œå†…éƒ¨ä½œç”¨åŸŸå£°æ˜ä¸€ä¸ªxåˆå§‹å€¼5 çš„å˜é‡ã€‚åœ¨å†…éƒ¨ä½œç”¨åŸŸå†…ï¼Œå°è¯•å°†çš„å€¼è®¾ç½®rä¸ºå¯¹çš„å¼•ç”¨xã€‚ç„¶åå†…éƒ¨ä½œç”¨åŸŸç»“æŸï¼Œå°è¯•åœ¨ä¸­æ‰“å°å€¼rã€‚è¯¥ä»£ç ä¸ä¼šç¼–è¯‘ï¼Œå› ä¸ºråœ¨å°è¯•ä½¿ç”¨è¯¥å€¼ä¹‹å‰ï¼Œè¯¥å€¼å·²è¶…å‡ºèŒƒå›´ã€‚è¿™æ˜¯é”™è¯¯æ¶ˆæ¯ï¼š

```rust
error[E0597]: `x` does not live long enough
  --> src/main.rs:7:5
   |
6  |         r = &x;
   |              - borrow occurs here
7  |     }
   |     ^ `x` dropped here while still borrowed
...
10 | }
   | - borrowed value needs to live until here

```

#### å€Ÿç”¨æ£€æŸ¥å™¨

Rustç¼–è¯‘å™¨æœ‰ä¸€ä¸ªå€Ÿç”¨æ£€æŸ¥å™¨ï¼Œå¯ä»¥æ¯”è¾ƒä½œç”¨åŸŸä»¥ç¡®å®šæ‰€æœ‰å€Ÿç”¨æ˜¯å¦æœ‰æ•ˆã€‚ä¸‹é¢ä»£ç ä¸ä¸Šé¢ä»£ç ç›¸åŒï¼Œä½†å¸¦æœ‰æ³¨é‡Šï¼Œæ˜¾ç¤ºäº†å˜é‡çš„ç”Ÿå­˜æœŸã€‚

```rust
{
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {}", r); //          |
}                         // ---------+
```

#### å‡½æ•°çš„é€šç”¨ç”Ÿå‘½å‘¨æœŸ

è®©ç¼–å†™ä¸€ä¸ªè¿”å›ä¸¤ä¸ªå­—ç¬¦ä¸²åˆ‡ç‰‡ä¸­è¾ƒé•¿è€…çš„å‡½æ•°ã€‚æ­¤å‡½æ•°å°†è·å–ä¸¤ä¸ªå­—ç¬¦ä¸²åˆ‡ç‰‡å¹¶è¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²åˆ‡ç‰‡ã€‚å®ç°longestå‡½æ•°åï¼Œ

```rust
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
```

#### ç»ˆèº«æ³¨é‡Šè¯­æ³•

ç»ˆèº«æ³¨é‡Šä¸ä¼šæ›´æ”¹ä»»ä½•å¼•ç”¨çš„ç”Ÿå­˜æ—¶é—´ã€‚æ­£å¦‚ç­¾åå¯ä»¥æŒ‡å®šé€šç”¨ç±»å‹å‚æ•°æ—¶å‡½æ•°å¯ä»¥æ¥å—ä»»ä½•ç±»å‹ä¸€æ ·ï¼Œé€šè¿‡æŒ‡å®šé€šç”¨å¯¿å‘½å‚æ•°ï¼Œå‡½æ•°å¯ä»¥æ¥å—å…·æœ‰ä»»ä½•ç”Ÿå­˜æœŸçš„å¼•ç”¨ã€‚ç”Ÿå­˜æœŸæ‰¹æ³¨æè¿°äº†å¤šä¸ªå¼•ç”¨çš„ç”Ÿå­˜æœŸå½¼æ­¤ä¹‹é—´çš„å…³ç³»ï¼Œè€Œä¸ä¼šå½±å“ç”Ÿå­˜æœŸã€‚

ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šçš„è¯­æ³•ç•¥æœ‰ä¸åŒï¼šç”Ÿå‘½å‘¨æœŸå‚æ•°çš„åç§°å¿…é¡»ä»¥æ’‡å·ï¼ˆ'ï¼‰å¼€å¤´ï¼Œå¹¶ä¸”é€šå¸¸éƒ½æ˜¯å°å†™ä¸”éå¸¸çŸ­ï¼Œå°±åƒæ³›å‹ç±»å‹ä¸€æ ·ã€‚å¤§å¤šæ•°äººä½¿ç”¨è¿™ä¸ªåå­—'aã€‚å°†ç”Ÿå‘½å‘¨æœŸå‚æ•°æ³¨é‡Šæ”¾ç½®åœ¨&å¼•ç”¨çš„åé¢ï¼Œå¹¶ä½¿ç”¨ç©ºæ ¼å°†æ³¨é‡Šä¸å¼•ç”¨çš„ç±»å‹åˆ†å¼€ã€‚

ä»¥ä¸‹æ˜¯ä¸€äº›ç¤ºä¾‹ï¼šå¯¹i32ä¸å¸¦ç”Ÿå‘½å‘¨æœŸå‚æ•°çš„çš„å¼•ç”¨ï¼Œå¯¹i32å…·æœ‰ç”Ÿå‘½å‘¨æœŸå‚æ•°åä¸ºçš„çš„'aå¼•ç”¨ä»¥åŠi32å¯¹ä¹Ÿå…·æœ‰ç”Ÿå‘½å‘¨æœŸçš„çš„å¯å˜å¼•ç”¨'aã€‚

```rust
&i32        // a reference
&'a i32     // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime
```

#### æ–¹æ³•å®šä¹‰ä¸­çš„ç”Ÿå‘½å‘¨æœŸæ³¨é‡Š

åœ¨å…·æœ‰ç”Ÿå‘½å‘¨æœŸçš„ç»“æ„ä¸Šå®ç°æ–¹æ³•æ—¶ï¼Œä½¿ç”¨ä¸æ¸…å•10-11ä¸­æ‰€ç¤ºçš„æ³›å‹ç±»å‹å‚æ•°ç›¸åŒçš„è¯­æ³•ã€‚å£°æ˜å’Œä½¿ç”¨ç”Ÿå‘½å‘¨æœŸå‚æ•°çš„ä½ç½®å–å†³äºå®ƒä»¬æ˜¯å¦ä¸structå­—æ®µæˆ–æ–¹æ³•å‚æ•°ä»¥åŠè¿”å›å€¼ç›¸å…³ã€‚

å§‹ç»ˆéœ€è¦åœ¨impl å…³é”®å­—ä¹‹åå£°æ˜ç»“æ„å­—æ®µçš„ç”Ÿå‘½å‘¨æœŸåç§°ï¼Œç„¶ååœ¨ç»“æ„åç§°ä¹‹åä½¿ç”¨ï¼Œå› ä¸ºè¿™äº›ç”Ÿå‘½å‘¨æœŸæ˜¯ç»“æ„ç±»å‹çš„ä¸€éƒ¨åˆ†ã€‚

åœ¨implå—å†…çš„æ–¹æ³•ç­¾åä¸­ï¼Œå¼•ç”¨å¯èƒ½ä¸ç»“æ„å­—æ®µä¸­å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸç›¸å…³ï¼Œæˆ–è€…å®ƒä»¬å¯èƒ½æ˜¯ç‹¬ç«‹çš„ã€‚æ­¤å¤–ï¼Œç”Ÿå­˜æœŸçœç•¥è§„åˆ™é€šå¸¸ä½¿ä¹‹æˆä¸ºå¿…éœ€ï¼Œå› æ­¤åœ¨æ–¹æ³•ç­¾åä¸­ä¸éœ€è¦ç”Ÿå­˜æœŸæ‰¹æ³¨ã€‚è®©çœ‹ä¸€ä¸‹ä½¿ç”¨ImportantExcerptæ¸…å•10-25ä¸­å®šä¹‰çš„å‘½åç»“æ„çš„ä¸€äº›ç¤ºä¾‹ã€‚

é¦–å…ˆï¼Œå°†ä½¿ç”¨åä¸ºlevelçš„æ–¹æ³•ï¼Œè¯¥æ–¹æ³•çš„å”¯ä¸€å‚æ•°æ˜¯å¯¹çš„å¼•ç”¨ï¼Œ selfè€Œè¿”å›å€¼æ˜¯i32ï¼Œè€Œä¸æ˜¯å¯¹ä»»ä½•å†…å®¹çš„å¼•ç”¨ï¼š

```rust

#![allow(unused_variables)]
fn main() {
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
}
```

implè¦æ±‚åœ¨ç±»å‹åç§°åä½¿ç”¨ç”Ÿå‘½å‘¨æœŸå‚æ•°å£°æ˜ä»¥åŠåœ¨ç±»å‹åç§°åä½¿ç”¨å®ƒï¼Œä½†æ˜¯selfç”±äºç¬¬ä¸€ä¸ªçœç•¥è§„åˆ™ï¼Œä¸éœ€è¦æ³¨é‡Šå¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸã€‚

è¿™æ˜¯ç¬¬ä¸‰ä¸ªç”Ÿå­˜æœŸåˆ é™¤è§„åˆ™é€‚ç”¨çš„ç¤ºä¾‹ï¼š

```rust

#![allow(unused_variables)]
fn main() {
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part
    }
}
}

```

æœ‰ä¸¤ä¸ªè¾“å…¥å¯¿å‘½ï¼Œæ‰€ä»¥é”ˆç—…åº”ç”¨ç¬¬ä¸€ç”Ÿå­˜æ³•åˆ™çœéŸ³å¹¶ç»™å‡ºäº†ä¸¤ä¸ª&selfå’Œannouncementè‡ªå·±çš„å¯¿å‘½ã€‚ç„¶åï¼Œç”±äºå‚æ•°ä¹‹ä¸€æ˜¯&selfï¼Œè¿”å›ç±»å‹çš„ç”Ÿå­˜æœŸä¸º&selfï¼Œå¹¶ä¸”æ‰€æœ‰ç”Ÿå­˜æœŸå‡å·²è€ƒè™‘åœ¨å†…ã€‚

#### é™æ€å¯¿å‘½

éœ€è¦è®¨è®ºçš„ä¸€ä¸ªç‰¹æ®Šå¯¿å‘½æ˜¯'staticï¼Œè¿™æ„å‘³ç€è¯¥å¼•ç”¨å¯ä»¥åœ¨ç¨‹åºçš„æ•´ä¸ªè¿‡ç¨‹ä¸­æœ‰æ•ˆã€‚æ‰€æœ‰å­—ç¬¦ä¸²æ–‡å­—éƒ½æœ‰'staticç”Ÿå‘½å‘¨æœŸï¼Œå¯ä»¥å¦‚ä¸‹æ³¨é‡Šï¼š

```rust

#![allow(unused_variables)]
fn main() {
let s: &'static str = "I have a static lifetime.";
}

```

è¯¥å­—ç¬¦ä¸²çš„æ–‡æœ¬ç›´æ¥å­˜å‚¨åœ¨ç¨‹åºçš„äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ï¼Œè¯¥äºŒè¿›åˆ¶æ–‡ä»¶å§‹ç»ˆå¯ç”¨ã€‚å› æ­¤ï¼Œæ‰€æœ‰å­—ç¬¦ä¸²æ–‡å­—çš„ç”Ÿå­˜æœŸä¸º 'staticã€‚

å¯èƒ½ä¼š'staticåœ¨é”™è¯¯æ¶ˆæ¯ä¸­çœ‹åˆ°æœ‰å…³ä½¿ç”¨ç”Ÿå­˜æœŸçš„å»ºè®®ã€‚ä½†æ˜¯åœ¨æŒ‡å®š'staticä½œä¸ºå‚è€ƒçš„ç”Ÿå­˜æœŸä¹‹å‰ï¼Œè¯·è€ƒè™‘ä¸€ä¸‹æ‰€æ‹¥æœ‰çš„å‚è€ƒæ˜¯å¦çœŸæ­£å­˜åœ¨äºç¨‹åºçš„æ•´ä¸ªç”Ÿå­˜æœŸä¸­ã€‚å¯èƒ½ä¼šè€ƒè™‘æ˜¯å¦å¸Œæœ›å®ƒå¯¿å‘½è¿™ä¹ˆé•¿ï¼Œå³ä½¿å¯ä»¥ã€‚åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œé—®é¢˜æ˜¯ç”±äºå°è¯•åˆ›å»ºæ‚¬ç©ºå‚è€ƒæˆ–å¯ç”¨å¯¿å‘½ä¸åŒ¹é…è€Œå¯¼è‡´çš„ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè§£å†³æ–¹æ¡ˆå°†è§£å†³è¿™äº›é—®é¢˜ï¼Œè€Œä¸æŒ‡å®š'staticå¯¿å‘½ã€‚

#### é€šç”¨ç±»å‹å‚æ•°ï¼Œç‰¹è´¨ç•Œé™å’Œå¯¿å‘½

ç®€è¦åœ°çœ‹ä¸€ä¸‹åœ¨ä¸€ä¸ªå‡½æ•°ä¸­æŒ‡å®šæ³›å‹ç±»å‹å‚æ•°ï¼Œç‰¹å¾èŒƒå›´å’Œç”Ÿå­˜æœŸçš„è¯­æ³•ï¼

```rust

#![allow(unused_variables)]
fn main() {
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str
    where T: Display
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
}
```

### ç¼–å†™è‡ªåŠ¨åŒ–æµ‹è¯•

Edsger W. Dijkstraåœ¨1972å¹´çš„è®ºæ–‡â€œè°¦è™šçš„ç¨‹åºå‘˜â€ä¸­è¯´ï¼šâ€œç¨‹åºæµ‹è¯•å¯ä»¥æ˜¯æ˜¾ç¤ºé”™è¯¯å­˜åœ¨çš„éå¸¸æœ‰æ•ˆçš„æ–¹æ³•ï¼Œä½†æ˜¯å®ƒä¸è¶³ä»¥æ˜¾ç¤ºé”™è¯¯çš„å­˜åœ¨ã€‚â€ è¿™å¹¶ä¸æ„å‘³ç€ä¸åº”è¯¥å°è¯•å°½å¯èƒ½å¤šåœ°è¿›è¡Œæµ‹è¯•ï¼

ç¨‹åºä¸­çš„æ­£ç¡®æ€§æ˜¯çš„ä»£ç æŒ‰é¢„æœŸæ‰§è¡Œçš„ç¨‹åº¦ã€‚Rustçš„è®¾è®¡é«˜åº¦å…³æ³¨ç¨‹åºçš„æ­£ç¡®æ€§ï¼Œä½†æ˜¯æ­£ç¡®æ€§å¾ˆå¤æ‚å¹¶ä¸”ä¸å®¹æ˜“è¯æ˜ã€‚Rustçš„ç±»å‹ç³»ç»Ÿæ‰¿æ‹…äº†å¾ˆå¤§çš„è´Ÿæ‹…ï¼Œä½†æ˜¯ç±»å‹ç³»ç»Ÿæ— æ³•æ•è·å„ç§é”™è¯¯ã€‚å› æ­¤ï¼ŒRustæ”¯æŒä½¿ç”¨è¯¥è¯­è¨€ç¼–å†™è‡ªåŠ¨è½¯ä»¶æµ‹è¯•ã€‚

ä¾‹å¦‚ï¼Œå‡è®¾ç¼–å†™äº†ä¸€ä¸ªåä¸ºçš„å‡½æ•°add_twoï¼Œè¯¥å‡½æ•°ä¼šå°†ä¼ é€’ç»™å®ƒçš„ä»»ä½•æ•°å­—åŠ 2ã€‚è¯¥å‡½æ•°çš„ç­¾åæ¥å—ä¸€ä¸ªæ•´æ•°ä½œä¸ºå‚æ•°ï¼Œå¹¶è¿”å›ä¸€ä¸ªæ•´æ•°ä½œä¸ºç»“æœã€‚å½“å®ç°å¹¶ç¼–è¯‘è¯¥å‡½æ•°æ—¶ï¼ŒRustä¼šè¿›è¡Œåˆ°ç›®å‰ä¸ºæ­¢æ‰€å­¦çš„æ‰€æœ‰ç±»å‹æ£€æŸ¥å’Œå€Ÿä½æ£€æŸ¥ï¼Œä»¥ç¡®ä¿ä¾‹å¦‚ï¼Œä¸ä¼šStringå¯¹è¯¥å‡½æ•°ä¼ é€’å€¼æˆ–æ— æ•ˆå¼•ç”¨ã€‚ä½†æ˜¯Rust æ— æ³•æ£€æŸ¥æ­¤å‡½æ•°æ˜¯å¦èƒ½å¤Ÿå‡†ç¡®æ‰§è¡Œçš„é¢„æœŸï¼Œå³è¿”å›å‚æ•°åŠ 2è€Œä¸æ˜¯å‚æ•°åŠ 10æˆ–å‚æ•°å‡50ï¼é‚£å°±æ˜¯æµ‹è¯•çš„åœ°æ–¹ã€‚

å¯ä»¥ç¼–å†™æµ‹è¯•æ¥æ–­è¨€ä¾‹å¦‚ï¼Œå½“ä¼ é€’3ç»™ add_twoå‡½æ•°æ—¶ï¼Œè¿”å›çš„å€¼ä¸º5ã€‚åªè¦å¯¹ä»£ç è¿›è¡Œæ›´æ”¹ï¼Œå°±å¯ä»¥è¿è¡Œè¿™äº›æµ‹è¯•ï¼Œä»¥ç¡®ä¿ä»»ä½•ç°æœ‰çš„æ­£ç¡®è¡Œä¸ºéƒ½æ²¡æœ‰æ›´æ”¹ã€‚

æµ‹è¯•æ˜¯ä¸€é¡¹å¤æ‚çš„æŠ€èƒ½ï¼šå°½ç®¡ä¸èƒ½åœ¨ä¸€ç« ä¸­æ¶µç›–æœ‰å…³å¦‚ä½•ç¼–å†™è‰¯å¥½æµ‹è¯•çš„æ‰€æœ‰ç»†èŠ‚ï¼Œä½†å°†è®¨è®ºRustæµ‹è¯•è®¾æ–½çš„æœºåˆ¶ã€‚å°†è®¨è®ºç¼–å†™æµ‹è¯•æ—¶ä¸ºæä¾›çš„æ³¨é‡Šå’Œå®ï¼Œä¸ºè¿è¡Œæµ‹è¯•æä¾›çš„é»˜è®¤è¡Œä¸ºå’Œé€‰é¡¹ï¼Œä»¥åŠå¦‚ä½•å°†æµ‹è¯•ç»„ç»‡ä¸ºå•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•ã€‚

æµ‹è¯•æ˜¯Rustå‡½æ•°ï¼Œç”¨äºéªŒè¯éæµ‹è¯•ä»£ç æ˜¯å¦æŒ‰é¢„æœŸæ–¹å¼å·¥ä½œã€‚æµ‹è¯•åŠŸèƒ½çš„ä¸»ä½“é€šå¸¸æ‰§è¡Œä»¥ä¸‹ä¸‰ä¸ªæ“ä½œï¼š

* è®¾ç½®ä»»ä½•éœ€è¦çš„æ•°æ®æˆ–çŠ¶æ€ã€‚
* è¿è¡Œè¦æµ‹è¯•çš„ä»£ç ã€‚
* æ–­è¨€ç»“æœå°±æ˜¯æ‰€æœŸæœ›çš„ã€‚
* 
è®©çœ‹ä¸€ä¸‹Rustä¸ºç¼–å†™æ‰§è¡Œè¿™äº›æ“ä½œçš„æµ‹è¯•è€Œä¸“é—¨æä¾›çš„åŠŸèƒ½ï¼Œè¿™äº›æµ‹è¯•åŒ…æ‹¬`test`å±æ€§ï¼Œä¸€äº›å®å’Œ `should_panic`å±æ€§ã€‚

```rust
fn main() {}
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}

```

å‡½æ•°ä½“ä½¿ç”¨assert_eq!å®å£°æ˜2 + 2ç­‰äº4ã€‚æ­¤å£°æ˜ç”¨ä½œå…¸å‹æµ‹è¯•æ ¼å¼çš„ç¤ºä¾‹ã€‚è®©è¿è¡Œå®ƒä»¥æŸ¥çœ‹æ­¤æµ‹è¯•æ˜¯å¦é€šè¿‡ã€‚

è¯¥`cargo test`å‘½ä»¤è¿è¡Œé¡¹ç›®ä¸­çš„æ‰€æœ‰æµ‹è¯•ï¼Œ

```rust
fn main() {}
#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
        panic!("Make this test fail");
    }
}

```

assert!å½“è¦ç¡®ä¿æµ‹è¯•ä¸­çš„æŸäº›æ¡ä»¶æ±‚å’Œæ—¶ï¼Œæ ‡å‡†åº“æä¾›çš„å®éå¸¸æœ‰ç”¨trueã€‚ç»™ assert!å®ä¸€ä¸ªå‚æ•°ï¼Œå…¶ç»“æœä¸ºå¸ƒå°”å€¼ã€‚å¦‚æœå€¼ä¸º trueï¼Œassert!åˆ™ä¸æ‰§è¡Œä»»ä½•æ“ä½œï¼Œæµ‹è¯•é€šè¿‡ã€‚å¦‚æœå€¼ä¸ºfalseï¼Œåˆ™assert!å®å°†è°ƒç”¨è¯¥panic!å®ï¼Œè¿™å°†å¯¼è‡´æµ‹è¯•å¤±è´¥ã€‚ä½¿ç”¨assert!å®æœ‰åŠ©äºæ£€æŸ¥ä»£ç æ˜¯å¦æŒ‰é¢„æœŸçš„æ–¹å¼è¿è¡Œã€‚

```rust
fn main() {}
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

```

```rust
fn main() {}
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

```

```rust
fn main() {}
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle { width: 8, height: 7 };
        let smaller = Rectangle { width: 5, height: 1 };

        assert!(larger.can_hold(&smaller));
    }
}

```

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œå·²ç»ç¼–å†™äº†åœ¨å¤±è´¥æ—¶ä¼šå‡ºç°å¼‚å¸¸çš„æµ‹è¯•ã€‚ä¹Ÿå¯ä»¥ç¼–å†™ä½¿ç”¨çš„æµ‹è¯•`Result<T, E>`ï¼è¿™æ˜¯æ¸…å•11-1ä¸­çš„æµ‹è¯•ï¼Œè¢«é‡å†™ä¸ºä½¿ç”¨`Result<T, E>`å¹¶è¿”å›a Errè€Œä¸æ˜¯å¼‚å¸¸ï¼š

```rust

#![allow(unused_variables)]
fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -> Result<(), String> {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
}
}

```

#### æ§åˆ¶æµ‹è¯•çš„è¿è¡Œæ–¹å¼

å°±åƒcargo runç¼–è¯‘ä»£ç ç„¶åè¿è¡Œç”Ÿæˆçš„äºŒè¿›åˆ¶æ–‡ä»¶ä¸€æ ·ï¼Œ cargo teståœ¨æµ‹è¯•æ¨¡å¼ä¸‹ç¼–è¯‘ä»£ç å¹¶è¿è¡Œç”Ÿæˆçš„æµ‹è¯•äºŒè¿›åˆ¶æ–‡ä»¶ã€‚å¯ä»¥æŒ‡å®šå‘½ä»¤è¡Œé€‰é¡¹æ¥æ›´æ”¹çš„é»˜è®¤è¡Œä¸º cargo testã€‚ä¾‹å¦‚ï¼Œç”Ÿæˆçš„äºŒè¿›åˆ¶æ–‡ä»¶çš„é»˜è®¤è¡Œä¸º cargo testæ˜¯å¹¶è¡Œè¿è¡Œæ‰€æœ‰æµ‹è¯•ï¼Œå¹¶æ•è·æµ‹è¯•è¿è¡ŒæœŸé—´ç”Ÿæˆçš„è¾“å‡ºï¼Œä»è€Œé˜»æ­¢æ˜¾ç¤ºè¾“å‡ºï¼Œå¹¶ä½¿è¯»å–ä¸æµ‹è¯•ç»“æœç›¸å…³çš„è¾“å‡ºæ›´åŠ å®¹æ˜“ã€‚

æœ‰äº›å‘½ä»¤è¡Œé€‰é¡¹è½¬åˆ°cargo testï¼Œæœ‰äº›è½¬åˆ°ç”Ÿæˆçš„æµ‹è¯•äºŒè¿›åˆ¶æ–‡ä»¶ã€‚è¦åˆ†éš”è¿™ä¸¤ç§ç±»å‹çš„å‚æ•°ï¼Œè¯·åˆ—å‡ºè¦ä¼ é€’çš„å‚æ•°ï¼Œcargo teståè·Ÿåˆ†éš”ç¬¦--ï¼Œç„¶ååˆ—å‡ºè¦ä¼ é€’è‡³æµ‹è¯•äºŒè¿›åˆ¶æ–‡ä»¶çš„å‚æ•°ã€‚è¿è¡Œcargo test --helpæ˜¾ç¤ºå¯ä»¥ä½¿ç”¨çš„é€‰é¡¹cargo testï¼Œè¿è¡Œcargo test -- --helpæ˜¾ç¤ºåœ¨åˆ†éš”ç¬¦ä¹‹åä½¿ç”¨çš„é€‰é¡¹--ã€‚

##### å¹¶è¡Œæˆ–è¿ç»­è¿è¡Œæµ‹è¯•

å½“è¿è¡Œå¤šä¸ªæµ‹è¯•æ—¶ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œå®ƒä»¬ä½¿ç”¨çº¿ç¨‹å¹¶è¡Œè¿è¡Œã€‚è¿™æ„å‘³ç€æµ‹è¯•å°†æ›´å¿«åœ°å®Œæˆè¿è¡Œï¼Œå› æ­¤å¯ä»¥æ›´å¿«åœ°è·å¾—æœ‰å…³ä»£ç æ˜¯å¦æ­£å¸¸å·¥ä½œçš„åé¦ˆã€‚ç”±äºæµ‹è¯•æ˜¯åŒæ—¶è¿è¡Œçš„ï¼Œå› æ­¤è¯·ç¡®ä¿çš„æµ‹è¯•ä¸ç›¸äº’ä¾èµ–ï¼Œä¹Ÿä¸ä¾èµ–ä»»ä½•å…±äº«çŠ¶æ€ï¼ŒåŒ…æ‹¬å…±äº«ç¯å¢ƒï¼Œä¾‹å¦‚å½“å‰çš„å·¥ä½œç›®å½•æˆ–ç¯å¢ƒå˜é‡ã€‚

ä¾‹å¦‚ï¼Œå‡è®¾çš„æ¯ä¸ªæµ‹è¯•éƒ½è¿è¡Œä¸€äº›ä»£ç ï¼Œè¿™äº›ä»£ç ä¼šåœ¨ç£ç›˜ä¸Šåˆ›å»ºä¸€ä¸ªåä¸ºtest-output.txtçš„æ–‡ä»¶ï¼Œå¹¶å°†ä¸€äº›æ•°æ®å†™å…¥è¯¥æ–‡ä»¶ã€‚ç„¶åï¼Œæ¯ä¸ªæµ‹è¯•è¯»å–è¯¥æ–‡ä»¶ä¸­çš„æ•°æ®ï¼Œå¹¶æ–­è¨€è¯¥æ–‡ä»¶åŒ…å«ä¸€ä¸ªç‰¹å®šå€¼ï¼Œè¯¥å€¼åœ¨æ¯ä¸ªæµ‹è¯•ä¸­éƒ½ä¸åŒã€‚å› ä¸ºæµ‹è¯•æ˜¯åŒæ—¶è¿è¡Œçš„ï¼Œæ‰€ä»¥åœ¨å¦ä¸€ä¸ªæµ‹è¯•å†™å…¥å’Œè¯»å–æ–‡ä»¶ä¹‹é—´ï¼Œä¸€ä¸ªæµ‹è¯•å¯èƒ½ä¼šè¦†ç›–æ–‡ä»¶ã€‚ç„¶åï¼Œç¬¬äºŒä¸ªæµ‹è¯•å°†å¤±è´¥ï¼Œè¿™ä¸æ˜¯å› ä¸ºä»£ç ä¸æ­£ç¡®ï¼Œè€Œæ˜¯å› ä¸ºåœ¨å¹¶è¡Œè¿è¡Œæ—¶æµ‹è¯•ä¹‹é—´ç›¸äº’å¹²æ‰°ã€‚ä¸€ç§è§£å†³æ–¹æ¡ˆæ˜¯ç¡®ä¿æ¯ä¸ªæµ‹è¯•éƒ½å†™å…¥ä¸åŒçš„æ–‡ä»¶ã€‚å¦ä¸€ç§è§£å†³æ–¹æ¡ˆæ˜¯ä¸€æ¬¡è¿è¡Œä¸€æ¬¡æµ‹è¯•ã€‚

å¦‚æœä¸æƒ³å¹¶è¡Œè¿è¡Œæµ‹è¯•ï¼Œæˆ–è€…æƒ³è¦å¯¹ä½¿ç”¨çš„çº¿ç¨‹æ•°è¿›è¡Œæ›´ç»†ç²’åº¦çš„æ§åˆ¶ï¼Œåˆ™å¯ä»¥å°†--test-threadsæ ‡å¿—å’Œè¦ä½¿ç”¨çš„çº¿ç¨‹æ•°å‘é€åˆ°æµ‹è¯•äºŒè¿›åˆ¶æ–‡ä»¶ã€‚çœ‹ä¸‹é¢çš„ä¾‹å­ï¼š

```
$ cargo test -- --test-threads=1
```

#### æ˜¾ç¤ºåŠŸèƒ½è¾“å‡º

é»˜è®¤æƒ…å†µä¸‹ï¼Œå¦‚æœæµ‹è¯•é€šè¿‡ï¼ŒRustçš„æµ‹è¯•åº“å°†æ•è·æ‰“å°åˆ°æ ‡å‡†è¾“å‡ºçš„æ‰€æœ‰å†…å®¹ã€‚ä¾‹å¦‚ï¼Œå¦‚æœè°ƒç”¨println!ä¸€ä¸ªæµ‹è¯•å¹¶ä¸”æµ‹è¯•é€šè¿‡ï¼Œåˆ™println!åœ¨ç»ˆç«¯ä¸­å°†çœ‹ä¸åˆ°è¾“å‡ºã€‚å°†ä»…çœ‹åˆ°æŒ‡ç¤ºæµ‹è¯•é€šè¿‡çš„è¡Œã€‚å¦‚æœæµ‹è¯•å¤±è´¥ï¼Œå°†åœ¨å…¶ä½™å¤±è´¥æ¶ˆæ¯ä¸­çœ‹åˆ°æ‰“å°åˆ°æ ‡å‡†è¾“å‡ºçš„æ‰€æœ‰å†…å®¹ã€‚

ä¾‹å¦‚ï¼Œæ¸…å•11-10å…·æœ‰ä¸€ä¸ªå‚»å‡½æ•°ï¼Œè¯¥å‡½æ•°æ‰“å°å…¶å‚æ•°çš„å€¼å¹¶è¿”å›10ï¼Œä»¥åŠé€šè¿‡å’Œå¤±è´¥çš„æµ‹è¯•ã€‚

```rust

#![allow(unused_variables)]
fn main() {
fn prints_and_returns_10(a: i32) -> i32 {
    println!("I got the value {}", a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}
}
```

#### æŒ‰åç§°è¿è¡Œæµ‹è¯•å­é›†

æœ‰æ—¶ï¼Œè¿è¡Œå®Œæ•´çš„æµ‹è¯•å¥—ä»¶å¯èƒ½éœ€è¦å¾ˆé•¿æ—¶é—´ã€‚å¦‚æœåœ¨ç‰¹å®šåŒºåŸŸä¸­å¤„ç†ä»£ç ï¼Œåˆ™å¯èƒ½åªæƒ³è¿è¡Œä¸è¯¥ä»£ç æœ‰å…³çš„æµ‹è¯•ã€‚å¯ä»¥é€šè¿‡ä¼ é€’cargo testè¦ä½œä¸ºå‚æ•°è¿è¡Œçš„æµ‹è¯•åç§°æ¥é€‰æ‹©è¦è¿è¡Œçš„æµ‹è¯•ã€‚

```rust

#![allow(unused_variables)]
fn main() {
pub fn add_two(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
}

```

#### è¿è¡Œå•é¡¹æµ‹è¯•

å¯ä»¥ä¼ é€’ä»»ä½•æµ‹è¯•å‡½æ•°çš„åç§°cargo testä»¥ä»…è¿è¡Œè¯¥æµ‹è¯•ï¼š

```rust
$ cargo test one_hundred
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-06a75b4a1f2515e9

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out

```

#### é™¤éç‰¹åˆ«è¦æ±‚ï¼Œå¦åˆ™å¿½ç•¥æŸäº›æµ‹è¯•

æœ‰æ—¶æ‰§è¡Œä¸€äº›ç‰¹å®šçš„æµ‹è¯•å¯èƒ½éå¸¸è€—æ—¶ï¼Œå› æ­¤å¯èƒ½å¸Œæœ›åœ¨å¤§å¤šæ•°è¿è¡ŒæœŸé—´å°†å…¶æ’é™¤cargo testã€‚å¯ä»¥ä½¿ç”¨ignoreå±æ€§å°†å®ƒä»¬æ’é™¤åœ¨å¤–ï¼Œè€Œä¸æ˜¯å°†æƒ³è¿è¡Œçš„æ‰€æœ‰æµ‹è¯•éƒ½åˆ—ä¸ºå‚æ•°ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```rust

#![allow(unused_variables)]
fn main() {
#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn expensive_test() {
    // code that takes an hour to run
}
}

```

### æµ‹è¯•ç»„ç»‡

å¦‚æœ¬ç« å¼€å¤´æ‰€è¿°ï¼Œæµ‹è¯•æ˜¯ä¸€é—¨å¤æ‚çš„å­¦ç§‘ï¼Œä¸åŒçš„äººä½¿ç”¨ä¸åŒçš„æœ¯è¯­å’Œç»„ç»‡ã€‚Rustç¤¾åŒºä»ä¸¤ä¸ªä¸»è¦ç±»åˆ«æ¥è€ƒè™‘æµ‹è¯•ï¼šå•å…ƒæµ‹è¯•å’Œ é›†æˆæµ‹è¯•ã€‚å•å…ƒæµ‹è¯•ä½“ç§¯å°ä¸”é‡ç‚¹çªå‡ºï¼Œå¯ä»¥ä¸€æ¬¡å•ç‹¬æµ‹è¯•ä¸€ä¸ªæ¨¡å—ï¼Œå¹¶ä¸”å¯ä»¥æµ‹è¯•ä¸“ç”¨æ¥å£ã€‚é›†æˆæµ‹è¯•å®Œå…¨åœ¨çš„åº“å¤–éƒ¨ï¼Œå¹¶ä¸”ä»¥ä¸å…¶ä»–ä»»ä½•å¤–éƒ¨ä»£ç ç›¸åŒçš„æ–¹å¼ä½¿ç”¨çš„ä»£ç ï¼Œä»…ä½¿ç”¨å…¬å…±æ¥å£ï¼Œå¹¶ä¸”æ¯ä¸ªæµ‹è¯•å¯èƒ½ä½¿ç”¨å¤šä¸ªæ¨¡å—ã€‚

ç¼–å†™ä¸¤ç§æµ‹è¯•å¯¹äºç¡®ä¿åº“ä¸­çš„å„ä¸ªéƒ¨åˆ†åˆ†åˆ«æˆ–ä¸€èµ·æ‰§è¡Œé¢„æœŸçš„å·¥ä½œéå¸¸é‡è¦ã€‚

#### å•å…ƒæµ‹è¯•

å•å…ƒæµ‹è¯•çš„ç›®çš„æ˜¯ä¸å…¶ä½™ä»£ç éš”ç¦»åœ°æµ‹è¯•æ¯ä¸ªä»£ç å•å…ƒï¼Œä»¥å¿«é€ŸæŸ¥æ˜ä»£ç åœ¨å“ªé‡Œæ­£å¸¸å·¥ä½œå’Œä¸æ­£å¸¸å·¥ä½œã€‚å°†ä½¿ç”¨å®ƒä»¬æ­£åœ¨æµ‹è¯•çš„ä»£ç å°†å•å…ƒæµ‹è¯•æ”¾åœ¨æ¯ä¸ªæ–‡ä»¶çš„srcç›®å½•ä¸­ã€‚çº¦å®šæ˜¯tests åœ¨æ¯ä¸ªæ–‡ä»¶ä¸­åˆ›å»ºä¸€ä¸ªå‘½åæ¨¡å—ä»¥åŒ…å«æµ‹è¯•åŠŸèƒ½ï¼Œå¹¶ä½¿ç”¨å¯¹å…¶è¿›è¡Œæ³¨é‡Š cfg(test)ã€‚

##### æµ‹è¯•æ¨¡å—å’Œ `#[cfg(test)]`

è¯¥`#[cfg(test)]`æµ‹è¯•æ¨¡å—ä¸Šçš„æ³¨è§£å‘Šè¯‰é”ˆç¼–è¯‘åªæœ‰å½“è¿è¡Œè¿è¡Œæµ‹è¯•ä»£ç cargo testï¼Œè€Œä¸æ˜¯å½“è¿è¡Œcargo buildã€‚å½“åªæƒ³æ„å»ºåº“æ—¶ï¼Œè¿™æ ·å¯ä»¥èŠ‚çœç¼–è¯‘æ—¶é—´ï¼Œå¹¶ä¸”ç”±äºä¸åŒ…æ‹¬æµ‹è¯•ï¼Œå› æ­¤å¯ä»¥èŠ‚çœç”Ÿæˆçš„ç¼–è¯‘å·¥ä»¶ä¸­çš„ç©ºé—´ã€‚ä¼šçœ‹åˆ°ï¼Œç”±äºé›†æˆæµ‹è¯•ä½äºä¸åŒçš„ç›®å½•ä¸­ï¼Œå› æ­¤å®ƒä»¬ä¸éœ€è¦`#[cfg(test)]`æ³¨é‡Šã€‚ä½†æ˜¯ï¼Œç”±äºå•å…ƒæµ‹è¯•ä¸ä»£ç ä½äºç›¸åŒçš„æ–‡ä»¶ä¸­ï¼Œå› æ­¤å°†ç”¨äº`#[cfg(test)]`æŒ‡å®šä¸åº”å°†å…¶åŒ…å«åœ¨ç¼–è¯‘ç»“æœä¸­ã€‚

```rust

#![allow(unused_variables)]
fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
}

```

æ­¤ä»£ç æ˜¯è‡ªåŠ¨ç”Ÿæˆçš„æµ‹è¯•æ¨¡å—ã€‚è¯¥å±æ€§cfg ä»£è¡¨é…ç½®ï¼Œå¹¶å‘Šè¯‰Rustä»…åœ¨å…·æœ‰ç‰¹å®šé…ç½®é€‰é¡¹çš„æƒ…å†µä¸‹æ‰åº”åŒ…æ‹¬ä»¥ä¸‹é¡¹ç›®ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œé…ç½®é€‰é¡¹ä¸ºtestï¼Œç”±Rustæä¾›ï¼Œç”¨äºç¼–è¯‘å’Œè¿è¡Œæµ‹è¯•ã€‚é€šè¿‡ä½¿ç”¨è¯¥cfgå±æ€§ï¼Œä»…å½“ä½¿ç”¨ç§¯æè¿è¡Œæµ‹è¯•æ—¶ï¼ŒCargoæ‰ä¼šç¼–è¯‘æµ‹è¯•ä»£ç cargo testã€‚é™¤äº†ä½¿ç”¨æ³¨é‡Šçš„åŠŸèƒ½å¤–ï¼Œå®ƒè¿˜åŒ…æ‹¬æ­¤æ¨¡å—ä¸­å¯èƒ½åŒ…å«çš„æ‰€æœ‰å¸®åŠ©ç¨‹åºåŠŸèƒ½`#[test]`ã€‚

##### æµ‹è¯•ç§æœ‰åŠŸèƒ½

åœ¨æµ‹è¯•ç¤¾åŒºä¸­ï¼Œæ˜¯å¦åº”ç›´æ¥æµ‹è¯•ç§æœ‰åŠŸèƒ½å­˜åœ¨äº‰è®ºï¼Œè€Œå…¶ä»–è¯­è¨€ä½¿æµ‹è¯•ç§æœ‰åŠŸèƒ½å˜å¾—å›°éš¾æˆ–ä¸å¯èƒ½ã€‚æ— è®ºéµå¾ªå“ªç§æµ‹è¯•æ€æƒ³ï¼ŒRustçš„éšç§è§„åˆ™éƒ½å¯ä»¥è®©æµ‹è¯•ç§æœ‰åŠŸèƒ½ã€‚

```rust
fn main() {}

pub fn add_two(a: i32) -> i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}

```

#### æ•´åˆæµ‹è¯•

åœ¨Rustä¸­ï¼Œé›†æˆæµ‹è¯•å®Œå…¨åœ¨çš„åº“å¤–éƒ¨ã€‚ä»–ä»¬ä»¥ä¸å…¶ä»–ä»»ä½•ä»£ç ç›¸åŒçš„æ–¹å¼ä½¿ç”¨çš„åº“ï¼Œè¿™æ„å‘³ç€å®ƒä»¬åªèƒ½è°ƒç”¨å±äºåº“çš„å…¬å…±APIçš„å‡½æ•°ã€‚å®ƒä»¬çš„ç›®çš„æ˜¯æµ‹è¯•åº“ä¸­çš„è®¸å¤šéƒ¨åˆ†æ˜¯å¦å¯ä»¥æ­£å¸¸ååŒå·¥ä½œã€‚å•ç‹¬å·¥ä½œçš„ä»£ç å•å…ƒåœ¨é›†æˆæ—¶å¯èƒ½ä¼šå‡ºç°é—®é¢˜ï¼Œå› æ­¤æµ‹è¯•é›†æˆä»£ç çš„è¦†ç›–èŒƒå›´ä¹Ÿå¾ˆé‡è¦ã€‚è¦åˆ›å»ºé›†æˆæµ‹è¯•ï¼Œé¦–å…ˆéœ€è¦ä¸€ä¸ªtestsç›®å½•ã€‚

```rust
use adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}

```

##### é›†æˆæµ‹è¯•ä¸­çš„å­æ¨¡å—

å½“æ·»åŠ æ›´å¤šé›†æˆæµ‹è¯•æ—¶ï¼Œå¯èƒ½å¸Œæœ›åœ¨testsç›®å½•ä¸­åˆ¶ä½œå¤šä¸ªæ–‡ä»¶æ¥å¸®åŠ©ç»„ç»‡å®ƒä»¬ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥æŒ‰æµ‹è¯•åŠŸèƒ½å¯¹æµ‹è¯•åŠŸèƒ½è¿›è¡Œåˆ†ç»„ã€‚å¦‚å‰æ‰€è¿°ï¼Œtestsç›®å½•ä¸­çš„æ¯ä¸ªæ–‡ä»¶éƒ½è¢«ç¼–è¯‘ä¸ºè‡ªå·±çš„å•ç‹¬æ¿æ¡ç®±ã€‚

å°†æ¯ä¸ªé›†æˆæµ‹è¯•æ–‡ä»¶è§†ä¸ºè‡ªå·±çš„æ¿æ¡ç®±å¯¹äºåˆ›å»ºå•ç‹¬çš„ä½œç”¨åŸŸéå¸¸æœ‰ç”¨ï¼Œè¿™äº›èŒƒå›´æ›´åƒæœ€ç»ˆç”¨æˆ·å°†ä½¿ç”¨çš„æ¿æ¡ç®±ã€‚ä½†æ˜¯ï¼Œè¿™æ„å‘³ç€testsç›®å½•ä¸­çš„æ–‡ä»¶ä¸srcä¸­çš„æ–‡ä»¶ä¸å…·æœ‰ç›¸åŒçš„è¡Œä¸ºï¼Œæ­£å¦‚åœ¨ç¬¬7ç« ä¸­äº†è§£çš„æœ‰å…³å¦‚ä½•å°†ä»£ç åˆ†ä¸ºæ¨¡å—å’Œæ–‡ä»¶çš„çŸ¥è¯†ä¸€æ ·ã€‚

å½“å…·æœ‰ä¸€ç»„åœ¨å¤šä¸ªé›†æˆæµ‹è¯•æ–‡ä»¶ä¸­æœ‰ç”¨çš„å¸®åŠ©ç¨‹åºåŠŸèƒ½å¹¶ä¸”å°è¯•æŒ‰ç…§ ç¬¬7ç« çš„â€œå°†æ¨¡å—åˆ†ä¸ºä¸åŒçš„æ–‡ä»¶â€ä¸€èŠ‚ä¸­çš„æ­¥éª¤æ“ä½œæ—¶ï¼Œtestsç›®å½•ä¸­æ–‡ä»¶çš„ä¸åŒè¡Œä¸ºæœ€ä¸ºæ˜æ˜¾ã€‚å°†å®ƒä»¬æå–åˆ°ä¸€ä¸ªé€šç”¨æ¨¡å—ä¸­ã€‚ä¾‹å¦‚ï¼Œå¦‚æœåˆ›å»ºtests / common.rså¹¶åœ¨å…¶ä¸­æ”¾ç½®ä¸€ä¸ªå‘½åå‡½æ•°ï¼Œåˆ™å¯ä»¥åœ¨å¤šä¸ªæµ‹è¯•æ–‡ä»¶ä¸­æ·»åŠ è¦ä»å¤šä¸ªæµ‹è¯•å‡½æ•°è°ƒç”¨çš„ä»£ç ï¼šsetupsetup

```rust
use adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}

```

### I/Oé¡¹ç›®ï¼šæ„å»ºå‘½ä»¤è¡Œç¨‹åº

#### æ¥å—å‘½ä»¤è¡Œå‚æ•°

##### è¯»å–å‚æ•°å€¼

éœ€è¦ä¸€ä¸ªRustæ ‡å‡†åº“ä¸­æä¾›çš„å‡½æ•° std::env::argsã€‚

```rust
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();
    println!("{:?}", args);
}

```

*æ³¨æ„ï¼šè¯·æ³¨æ„ï¼Œstd::env::argså¦‚æœä»»ä½•å‚æ•°åŒ…å«æ— æ•ˆçš„Unicode ï¼Œå°†æ„Ÿåˆ°å¼‚å¸¸ã€‚å¦‚æœçš„ç¨‹åºéœ€è¦æ¥å—åŒ…å«æ— æ•ˆUnicodeçš„å‚æ•°ï¼Œè¯·std::env::args_osæ”¹ç”¨ã€‚è¯¥å‡½æ•°è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼Œè¯¥è¿­ä»£å™¨ç”ŸæˆOsStringå€¼è€Œä¸æ˜¯Stringå€¼ã€‚ä¹‹æ‰€ä»¥é€‰æ‹©std::env::argsæ­¤å¤„ä¸ºç®€å•èµ·è§ï¼Œå› ä¸ºOsStringæ¯ä¸ªå¹³å°çš„å€¼ä¸åŒï¼Œå¹¶ä¸”ä½¿ç”¨èµ·æ¥Stringæ¯”å€¼æ›´å¤æ‚ã€‚*

#### å°†å‚æ•°å€¼ä¿å­˜åœ¨å˜é‡ä¸­

æ‰“å°å‚æ•°å‘é‡çš„å€¼è¯´æ˜è¯¥ç¨‹åºèƒ½å¤Ÿè®¿é—®æŒ‡å®šä¸ºå‘½ä»¤è¡Œå‚æ•°çš„å€¼ã€‚ç°åœ¨éœ€è¦å°†ä¸¤ä¸ªå‚æ•°çš„å€¼ä¿å­˜åœ¨å˜é‡ä¸­ï¼Œä»¥ä¾¿å¯ä»¥åœ¨ç¨‹åºçš„å…¶ä½™éƒ¨åˆ†ä¸­ä½¿ç”¨è¿™äº›å€¼ã€‚

```rust
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();

    let query = &args[1];
    let filename = &args[2];

    println!("Searching for {}", query);
    println!("In file {}", filename);
}

```

æ­£å¦‚çœ‹åˆ°çš„é‚£æ ·ï¼Œåœ¨æ‰“å°çŸ¢é‡æ—¶ï¼Œç¨‹åºçš„åç§°å æ®äº†çŸ¢é‡ä¸­çš„ç¬¬ä¸€ä¸ªå€¼`args[0]`ï¼Œå› æ­¤ä»indexå¼€å§‹1ã€‚ç¬¬ä¸€ä¸ªå‚æ•°minigrepæ˜¯è¦æœç´¢çš„å­—ç¬¦ä¸²ï¼Œå› æ­¤åœ¨å˜é‡ä¸­å¼•ç”¨äº†ç¬¬ä¸€ä¸ªå‚æ•°queryã€‚ç¬¬äºŒä¸ªå‚æ•°æ˜¯æ–‡ä»¶åï¼Œå› æ­¤åœ¨å˜é‡ä¸­å¼•ç”¨äº†ç¬¬äºŒä¸ªå‚æ•°filenameã€‚

```rust
use std::env;
use std::fs;

fn main() {
    let args: Vec<String> = env::args().collect();

    let query = &args[1];
    let filename = &args[2];

    println!("Searching for {}", query);
    // --snip--
    println!("In file {}", filename);

    let contents = fs::read_to_string(filename)
        .expect("Something went wrong reading the file");

    println!("With text:\n{}", contents);
}

```

#### æå–å‚æ•°è§£æå™¨

```rust
fn main() {
    let args: Vec<String> = env::args().collect();

    let (query, filename) = parse_config(&args);

    // --snip--
}

fn parse_config(args: &[String]) -> (&str, &str) {
    let query = &args[1];
    let filename = &args[2];

    (query, filename)
}

```

```rust
use std::env;
use std::fs;

fn main() {
    let args: Vec<String> = env::args().collect();

    let config = parse_config(&args);

    println!("Searching for {}", config.query);
    println!("In file {}", config.filename);

    let contents = fs::read_to_string(config.filename)
        .expect("Something went wrong reading the file");

    // --snip--
}

struct Config {
    query: String,
    filename: String,
}

fn parse_config(args: &[String]) -> Config {
    let query = args[1].clone();
    let filename = args[2].clone();

    Config { query, filename }
}

```

```rust
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args);

    // --snip--
}

struct Config {
    query: String,
    filename: String,
}

// --snip--

impl Config {
    fn new(args: &[String]) -> Config {
        let query = args[1].clone();
        let filename = args[2].clone();

        Config { query, filename }
    }
}

```

##### æ”¹å–„é”™è¯¯ä¿¡æ¯

```rust
// --snip--
fn new(args: &[String]) -> Config {
    if args.len() < 3 {
        panic!("not enough arguments");
    }
    // --snip--

```

```rust
impl Config {
    fn new(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}

```

###### è°ƒç”¨Config::newå’Œå¤„ç†é”™è¯¯

```rust
use std::process;

fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args).unwrap_or_else(|err| {
        println!("Problem parsing arguments: {}", err);
        process::exit(1);
    });

    // --snip--

```

åœ¨æ­¤ç¨‹åºä¸­ï¼Œä½¿ç”¨äº†ä»¥å‰æ²¡æœ‰æ¶‰åŠçš„æ–¹æ³•ï¼š unwrap_or_elseï¼Œå®ƒæ˜¯`Result<T, E>`ç”±æ ‡å‡†åº“å®šä¹‰çš„ã€‚ä½¿ç”¨unwrap_or_elseå…è®¸å®šä¹‰ä¸€äº›è‡ªå®šä¹‰çš„ï¼Œépanic!é”™è¯¯çš„å¤„ç†ã€‚å¦‚æœResultæ˜¯ä¸€ä¸ªOkå€¼ï¼Œåˆ™æ­¤æ–¹æ³•çš„è¡Œä¸ºç±»ä¼¼äºunwrapï¼šå®ƒè¿”å›OkåŒ…è£…çš„å†…éƒ¨å€¼ã€‚ä½†æ˜¯ï¼Œå¦‚æœå€¼æ˜¯ä¸€ä¸ªErrå€¼ï¼Œåˆ™æ­¤æ–¹æ³•å°†è°ƒç”¨é—­åŒ…ä¸­çš„ä»£ç ï¼Œè¯¥é—­åŒ…æ˜¯å®šä¹‰çš„åŒ¿åå‡½æ•°ï¼Œå¹¶ä½œä¸ºå‚æ•°ä¼ é€’ç»™unwrap_or_elseã€‚

#### ä»ä¸­æå–é€»è¾‘ main

```rust
fn main() {
    // --snip--

    println!("Searching for {}", config.query);
    println!("In file {}", config.filename);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.filename)
        .expect("Something went wrong reading the file");

    println!("With text:\n{}", contents);
}

// --snip--

```

#### ä»runå‡½æ•°è¿”å›é”™è¯¯

å°†å…¶ä½™çš„ç¨‹åºé€»è¾‘åˆ†ç¦»åˆ°runå‡½æ•°ä¸­ï¼Œå¯ä»¥åƒConfig::newæ¸…å•12-9ä¸­é‚£æ ·æ”¹è¿›é”™è¯¯å¤„ç†ã€‚å½“å‡ºç°é—®é¢˜æ—¶expectï¼Œrun å‡½æ•°å°†è¿”å›a ï¼Œè€Œä¸æ˜¯é€šè¿‡è°ƒç”¨ä½¿ç¨‹åºå¼‚å¸¸`Result<T, E>`ã€‚è¿™å°†ä½¿è¿›ä¸€æ­¥mainä»¥ç”¨æˆ·å‹å¥½çš„æ–¹å¼æ•´åˆåˆ°å¤„ç†é”™è¯¯çš„é€»è¾‘ä¸­ã€‚

```rust
use std::error::Error;

// --snip--

fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.filename)?;

    println!("With text:\n{}", contents);

    Ok(())
}

```

#### å¤„ç†é”™è¯¯è¿”å›ä»runåœ¨main

```rust
fn main() {
    // --snip--

    println!("Searching for {}", config.query);
    println!("In file {}", config.filename);

    if let Err(e) = run(config) {
        println!("Application error: {}", e);

        process::exit(1);
    }
}

```

ä½¿ç”¨if letè€Œä¸æ˜¯unwrap_or_elseæ£€æŸ¥æ˜¯å¦runè¿”å›Errå€¼ï¼Œç„¶åè°ƒç”¨è¿”å› å€¼process::exit(1)ã€‚è¯¥runå‡½æ•°ä¸ä¼šä»¥ è¿”å›å®ä¾‹unwrapçš„ç›¸åŒæ–¹å¼Config::newè¿”å›æƒ³è¦çš„å€¼Configã€‚å› ä¸ºåœ¨æˆåŠŸæƒ…å†µä¸‹runè¿”å›()ï¼Œæ‰€ä»¥åªå…³å¿ƒæ£€æµ‹é”™è¯¯ï¼Œå› æ­¤ä¸éœ€è¦unwrap_or_elseè¿”å›å±•å¼€çš„å€¼ï¼Œå› ä¸ºå®ƒåªä¼šæ˜¯()ã€‚

#### å°†ä»£ç æ‹†åˆ†ä¸ºä¸åŒçš„æ–‡ä»¶

```rust
use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub filename: String,
}

impl Config {
    pub fn new(args: &[String]) -> Result<Config, &'static str> {
        // --snip--
    }
}

pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    // --snip--
}

```

```rust
use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --snip--
    if let Err(e) = minigrep::run(config) {
        // --snip--
    }
}

```

### é€šè¿‡æµ‹è¯•é©±åŠ¨å¼€å‘æ¥å¼€å‘åº“çš„åŠŸèƒ½

ä½¿ç”¨æµ‹è¯•é©±åŠ¨çš„å¼€å‘ï¼ˆTDDï¼‰æµç¨‹å°†æœç´¢é€»è¾‘æ·»åŠ åˆ°ç¨‹åºä¸­ã€‚æ­¤è½¯ä»¶å¼€å‘æŠ€æœ¯éµå¾ªä»¥ä¸‹æ­¥éª¤ï¼š

1. ç¼–å†™ä¸€ä¸ªå¤±è´¥çš„æµ‹è¯•å¹¶è¿è¡Œå®ƒï¼Œä»¥ç¡®ä¿ç”±äºæœŸæœ›çš„åŸå› è€Œå¤±è´¥ã€‚
2. ç¼–å†™æˆ–ä¿®æ”¹è¶³å¤Ÿçš„ä»£ç ä»¥ä½¿æ–°çš„æµ‹è¯•é€šè¿‡ã€‚
3. é‡æ„åˆšåˆšæ·»åŠ æˆ–æ›´æ”¹çš„ä»£ç ï¼Œå¹¶ç¡®ä¿æµ‹è¯•ç»§ç»­é€šè¿‡ã€‚
4. ä»æ­¥éª¤1å¼€å§‹é‡å¤ï¼

æ­¤è¿‡ç¨‹åªæ˜¯ç¼–å†™è½¯ä»¶çš„è®¸å¤šæ–¹æ³•ä¹‹ä¸€ï¼Œä½†æ˜¯TDDä¹Ÿå¯ä»¥å¸®åŠ©é©±åŠ¨ä»£ç è®¾è®¡ã€‚åœ¨ç¼–å†™ä½¿æµ‹è¯•é€šè¿‡çš„ä»£ç ä¹‹å‰ç¼–å†™æµ‹è¯•æœ‰åŠ©äºåœ¨æ•´ä¸ªè¿‡ç¨‹ä¸­ä¿æŒè¾ƒé«˜çš„æµ‹è¯•è¦†ç›–ç‡ã€‚

#### ç¼–å†™å¤±è´¥çš„æµ‹è¯•

```rust

#![allow(unused_variables)]
fn main() {
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
     vec![]
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.";

        assert_eq!(
            vec!["safe, fast, productive."],
            search(query, contents)
        );
    }
}
}

```

```rust

#![allow(unused_variables)]
fn main() {
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    vec![]
}
}

```

è¦'aåœ¨ç­¾åä¸­å®šä¹‰çš„æ˜¾å¼ç”Ÿå­˜æœŸï¼Œ searchå¹¶ä¸contentså‚æ•°å’Œè¿”å›å€¼ä¸€èµ·ä½¿ç”¨ã€‚

#### ç¼–å†™ä»£ç é€šè¿‡æµ‹è¯•

ç›®å‰ï¼Œçš„æµ‹è¯•å¤±è´¥äº†ï¼Œå› ä¸ºæ€»æ˜¯è¿”å›ä¸€ä¸ªç©ºå‘é‡ã€‚è¦è§£å†³æ­¤é—®é¢˜å¹¶å®æ–½searchï¼Œçš„ç¨‹åºéœ€è¦éµå¾ªä»¥ä¸‹æ­¥éª¤ï¼š

* éå†å†…å®¹çš„æ¯ä¸€è¡Œã€‚
* æ£€æŸ¥è¯¥è¡Œæ˜¯å¦åŒ…å«çš„æŸ¥è¯¢å­—ç¬¦ä¸²ã€‚
* å¦‚æœæ˜¯è¿™æ ·ï¼Œè¯·å°†å…¶æ·»åŠ åˆ°è¦è¿”å›çš„å€¼åˆ—è¡¨ä¸­ã€‚
* å¦‚æœæ²¡æœ‰ï¼Œåˆ™ä»€ä¹ˆä¹Ÿä¸åšã€‚
* è¿”å›åŒ¹é…çš„ç»“æœåˆ—è¡¨ã€‚

è®©å®Œæˆæ¯ä¸ªæ­¥éª¤ï¼Œä»éå†è¡Œå¼€å§‹ã€‚

##### é€šè¿‡è¯¥linesæ–¹æ³•è¿­ä»£çº¿

```rust
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    for line in contents.lines() {
        // do something with line
    }
}
```

##### åœ¨æ¯ä¸€è¡Œä¸­æœç´¢æŸ¥è¯¢

æ¥ä¸‹æ¥ï¼Œå°†æ£€æŸ¥å½“å‰è¡Œæ˜¯å¦åŒ…å«æŸ¥è¯¢å­—ç¬¦ä¸²ã€‚å¹¸è¿çš„æ˜¯ï¼Œå­—ç¬¦ä¸²æœ‰ä¸€ä¸ªæœ‰ç”¨çš„åä¸ºçš„æ–¹æ³•containsï¼Œå¯ä»¥ä¸ºåšåˆ°è¿™ä¸€ç‚¹ï¼containsåœ¨searchå‡½æ•°ä¸­æ·»åŠ å¯¹æ–¹æ³•çš„è°ƒç”¨

```rust
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}

```

##### å­˜å‚¨åŒ¹é…çš„è¡Œ

è¿˜éœ€è¦ä¸€ä¸ªæ–¹æ³•æ¥å­˜å‚¨åŒ…å«æŸ¥è¯¢å­—ç¬¦ä¸²çš„è¡Œã€‚ä¸ºæ­¤å¯ä»¥åœ¨ for å¾ªç¯ä¹‹å‰åˆ›å»ºä¸€ä¸ªå¯å˜çš„ vector å¹¶è°ƒç”¨ push æ–¹æ³•åœ¨ vector ä¸­å­˜æ”¾ä¸€ä¸ª lineã€‚åœ¨ for å¾ªç¯ä¹‹åï¼Œè¿”å›è¿™ä¸ª vectorï¼Œ

```rust
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}

```

##### åœ¨ run å‡½æ•°ä¸­ä½¿ç”¨ search å‡½æ•°

ç°åœ¨ search å‡½æ•°æ˜¯å¯ä»¥å·¥ä½œå¹¶æµ‹è¯•é€šè¿‡äº†çš„ï¼Œéœ€è¦å®é™…åœ¨ run å‡½æ•°ä¸­è°ƒç”¨ searchã€‚éœ€è¦å°† config.query å€¼å’Œ run ä»æ–‡ä»¶ä¸­è¯»å–çš„ contents ä¼ é€’ç»™ search å‡½æ•°ã€‚æ¥ç€ run ä¼šæ‰“å°å‡º search è¿”å›çš„æ¯ä¸€è¡Œï¼š

```rust
pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.filename)?;

    for line in search(&config.query, &contents) {
        println!("{}", line);
    }

    Ok(())
}

```

#### ç¼–å†™ä¸€ä¸ªå¤§å°å†™ä¸æ•æ„Ÿ search å‡½æ•°çš„å¤±è´¥æµ‹è¯•

å¸Œæœ›å¢åŠ ä¸€ä¸ªæ–°å‡½æ•° search_case_insensitiveï¼Œå¹¶å°†ä¼šåœ¨è®¾ç½®äº†ç¯å¢ƒå˜é‡æ—¶è°ƒç”¨å®ƒã€‚è¿™é‡Œå°†ç»§ç»­éµå¾ª TDD è¿‡ç¨‹ï¼Œå…¶ç¬¬ä¸€æ­¥æ˜¯å†æ¬¡ç¼–å†™ä¸€ä¸ªå¤±è´¥æµ‹è¯•ã€‚å°†ä¸ºæ–°çš„å¤§å°å†™ä¸æ•æ„Ÿæœç´¢å‡½æ•°æ–°å¢ä¸€ä¸ªæµ‹è¯•å‡½æ•°ï¼Œå¹¶å°†è€çš„æµ‹è¯•å‡½æ•°ä» one_result æ”¹åä¸º case_sensitive æ¥æ›´æ¸…æ¥šçš„è¡¨æ˜è¿™ä¸¤ä¸ªæµ‹è¯•çš„åŒºåˆ«ï¼Œ

```rust

#![allow(unused_variables)]
fn main() {
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = "duct";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Duct tape.";

        assert_eq!(
            vec!["safe, fast, productive."],
            search(query, contents)
        );
    }

    #[test]
    fn case_insensitive() {
        let query = "rUsT";
        let contents = "\
Rust:
safe, fast, productive.
Pick three.
Trust me.";

        assert_eq!(
            vec!["Rust:", "Trust me."],
            search_case_insensitive(query, contents)
        );
    }
}
}
```

æ³¨æ„ä¹Ÿæ”¹å˜äº†è€æµ‹è¯•ä¸­ contents çš„å€¼ã€‚è¿˜æ–°å¢äº†ä¸€ä¸ªå«æœ‰æ–‡æœ¬ "Duct tape." çš„è¡Œï¼Œå®ƒæœ‰ä¸€ä¸ªå¤§å†™çš„ Dï¼Œè¿™åœ¨å¤§å°å†™æ•æ„Ÿæœç´¢æ—¶ä¸åº”è¯¥åŒ¹é… "duct"ã€‚ä¿®æ”¹è¿™ä¸ªæµ‹è¯•ä»¥ç¡®ä¿ä¸ä¼šæ„å¤–ç ´åå·²ç»å®ç°çš„å¤§å°å†™æ•æ„Ÿæœç´¢åŠŸèƒ½ï¼›è¿™ä¸ªæµ‹è¯•ç°åœ¨åº”è¯¥èƒ½é€šè¿‡å¹¶åœ¨å¤„ç†å¤§å°å†™ä¸æ•æ„Ÿæœç´¢æ—¶åº”è¯¥èƒ½ä¸€ç›´é€šè¿‡ã€‚

å¤§å°å†™ ä¸æ•æ„Ÿ æœç´¢çš„æ–°æµ‹è¯•ä½¿ç”¨ "rUsT" ä½œä¸ºå…¶æŸ¥è¯¢å­—ç¬¦ä¸²ã€‚åœ¨å°†è¦å¢åŠ çš„ search_case_insensitive å‡½æ•°ä¸­ï¼Œ"rUsT" æŸ¥è¯¢åº”è¯¥åŒ…å«å¸¦æœ‰ä¸€ä¸ªå¤§å†™ R çš„ "Rust:" è¿˜æœ‰ "Trust me." è¿™ä¸¤è¡Œï¼Œå³ä¾¿ä»–ä»¬ä¸æŸ¥è¯¢çš„å¤§å°å†™éƒ½ä¸åŒã€‚è¿™ä¸ªæµ‹è¯•ç°åœ¨ä¼šç¼–è¯‘å¤±è´¥å› ä¸ºè¿˜æ²¡æœ‰å®šä¹‰ search_case_insensitive å‡½æ•°ã€‚è¯·éšæ„å¢åŠ ä¸€ä¸ªæ€»æ˜¯è¿”å›ç©º vector çš„éª¨æ¶å®ç°ï¼Œ

#### å®ç° search_case_insensitive å‡½æ•°

search_case_insensitive å‡½æ•°ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼Œå°†ä¸ search å‡½æ•°åŸºæœ¬ç›¸åŒã€‚å”¯ä¸€çš„åŒºåˆ«æ˜¯å®ƒä¼šå°† query å˜é‡å’Œæ¯ä¸€ line éƒ½å˜ä¸ºå°å†™ï¼Œè¿™æ ·ä¸ç®¡è¾“å…¥å‚æ•°æ˜¯å¤§å†™è¿˜æ˜¯å°å†™ï¼Œåœ¨æ£€æŸ¥è¯¥è¡Œæ˜¯å¦åŒ…å«æŸ¥è¯¢å­—ç¬¦ä¸²æ—¶éƒ½ä¼šæ˜¯å°å†™ã€‚

```rust

#![allow(unused_variables)]
fn main() {
pub fn search_case_insensitive<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&query) {
            results.push(line);
        }
    }

    results
}
}
```

é¦–å…ˆå°† query å­—ç¬¦ä¸²è½¬æ¢ä¸ºå°å†™ï¼Œå¹¶å°†å…¶è¦†ç›–åˆ°åŒåçš„å˜é‡ä¸­ã€‚å¯¹æŸ¥è¯¢å­—ç¬¦ä¸²è°ƒç”¨ to_lowercase æ˜¯å¿…éœ€çš„ï¼Œè¿™æ ·ä¸ç®¡ç”¨æˆ·çš„æŸ¥è¯¢æ˜¯ "rust"ã€"RUST"ã€"Rust" æˆ–è€… "rUsT"ï¼Œéƒ½å°†å…¶å½“ä½œ "rust" å¤„ç†å¹¶å¯¹å¤§å°å†™ä¸æ•æ„Ÿã€‚

æ³¨æ„ query ç°åœ¨æ˜¯ä¸€ä¸ª String è€Œä¸æ˜¯å­—ç¬¦ä¸² sliceï¼Œå› ä¸ºè°ƒç”¨ to_lowercase æ˜¯åœ¨åˆ›å»ºæ–°æ•°æ®ï¼Œè€Œä¸æ˜¯å¼•ç”¨ç°æœ‰æ•°æ®ã€‚å¦‚æœæŸ¥è¯¢å­—ç¬¦ä¸²æ˜¯ "rUsT"ï¼Œè¿™ä¸ªå­—ç¬¦ä¸² slice å¹¶ä¸åŒ…å«å¯ä¾›ä½¿ç”¨çš„å°å†™çš„ u æˆ– tï¼Œæ‰€ä»¥å¿…éœ€åˆ†é…ä¸€ä¸ªåŒ…å« "rust" çš„æ–° Stringã€‚ç°åœ¨å½“å°† query ä½œä¸ºä¸€ä¸ªå‚æ•°ä¼ é€’ç»™ contains æ–¹æ³•æ—¶ï¼Œéœ€è¦å¢åŠ ä¸€ä¸ª & å› ä¸º contains çš„ç­¾åè¢«å®šä¹‰ä¸ºè·å–ä¸€ä¸ªå­—ç¬¦ä¸² sliceã€‚

æ¥ä¸‹æ¥åœ¨æ£€æŸ¥æ¯ä¸ª line æ˜¯å¦åŒ…å« search ä¹‹å‰å¢åŠ äº†ä¸€ä¸ª to_lowercase è°ƒç”¨å°†ä»–ä»¬éƒ½å˜ä¸ºå°å†™ã€‚ç°åœ¨å°† line å’Œ query éƒ½è½¬æ¢æˆäº†å°å†™ï¼Œè¿™æ ·å°±å¯ä»¥ä¸ç®¡æŸ¥è¯¢çš„å¤§å°å†™è¿›è¡ŒåŒ¹é…äº†ã€‚

```rust

#![allow(unused_variables)]
fn main() {
pub struct Config {
    pub query: String,
    pub filename: String,
    pub case_sensitive: bool,
}
}
```

è¿™é‡Œå¢åŠ äº† case_sensitive å­—ç¬¦æ¥å­˜æ”¾ä¸€ä¸ªå¸ƒå°”å€¼ã€‚æ¥ç€éœ€è¦ run å‡½æ•°æ£€æŸ¥ case_sensitive å­—æ®µçš„å€¼å¹¶ä½¿ç”¨å®ƒæ¥å†³å®šæ˜¯å¦è°ƒç”¨ search å‡½æ•°æˆ– search_case_insensitive å‡½æ•°ï¼Œ

```rust

#![allow(unused_variables)]
fn main() {
use std::error::Error;
use std::fs::{self, File};
use std::io::prelude::*;

pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
     vec![]
}

pub fn search_case_insensitive<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
     vec![]
}

pub struct Config {
    query: String,
    filename: String,
    case_sensitive: bool,
}

pub fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.filename)?;

    let results = if config.case_sensitive {
        search(&config.query, &contents)
    } else {
        search_case_insensitive(&config.query, &contents)
    };

    for line in results {
        println!("{}", line);
    }

    Ok(())
}
}
```

æœ€åéœ€è¦å®é™…æ£€æŸ¥ç¯å¢ƒå˜é‡ã€‚å¤„ç†ç¯å¢ƒå˜é‡çš„å‡½æ•°ä½äºæ ‡å‡†åº“çš„ env æ¨¡å—ä¸­ï¼Œæ‰€ä»¥éœ€è¦åœ¨ src/lib.rs çš„å¼€å¤´å¢åŠ ä¸€ä¸ª use std::env; è¡Œå°†è¿™ä¸ªæ¨¡å—å¼•å…¥ä½œç”¨åŸŸä¸­ã€‚æ¥ç€åœ¨ Config::new ä¸­ä½¿ç”¨ env æ¨¡å—çš„ var æ–¹æ³•æ¥æ£€æŸ¥ä¸€ä¸ªå«åš CASE_INSENSITIVE çš„ç¯å¢ƒå˜é‡ï¼Œ

```rust

#![allow(unused_variables)]
fn main() {
use std::env;
struct Config {
    query: String,
    filename: String,
    case_sensitive: bool,
}

// --snip--

impl Config {
    pub fn new(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var("CASE_INSENSITIVE").is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
}
```

è¿™é‡Œåˆ›å»ºäº†ä¸€ä¸ªæ–°å˜é‡ case_sensitiveã€‚ä¸ºäº†è®¾ç½®å®ƒçš„å€¼ï¼Œéœ€è¦è°ƒç”¨ env::var å‡½æ•°å¹¶ä¼ é€’éœ€è¦å¯»æ‰¾çš„ç¯å¢ƒå˜é‡åç§°ï¼ŒCASE_INSENSITIVEã€‚env::var è¿”å›ä¸€ä¸ª Resultï¼Œå®ƒåœ¨ç¯å¢ƒå˜é‡è¢«è®¾ç½®æ—¶è¿”å›åŒ…å«å…¶å€¼çš„ Ok æˆå‘˜ï¼Œå¹¶åœ¨ç¯å¢ƒå˜é‡æœªè¢«è®¾ç½®æ—¶è¿”å› Err æˆå‘˜ã€‚

ä½¿ç”¨ Result çš„ is_err æ–¹æ³•æ¥æ£€æŸ¥å…¶æ˜¯å¦æ˜¯ä¸€ä¸ª errorï¼ˆä¹Ÿå°±æ˜¯ç¯å¢ƒå˜é‡æœªè¢«è®¾ç½®çš„æƒ…å†µï¼‰ï¼Œè¿™ä¹Ÿå°±æ„å‘³ç€ éœ€è¦ è¿›è¡Œä¸€ä¸ªå¤§å°å†™æ•æ„Ÿæœç´¢ã€‚å¦‚æœCASE_INSENSITIVE ç¯å¢ƒå˜é‡è¢«è®¾ç½®ä¸ºä»»ä½•å€¼ï¼Œis_err ä¼šè¿”å› false å¹¶å°†è¿›è¡Œå¤§å°å†™ä¸æ•æ„Ÿæœç´¢ã€‚å¹¶ä¸å…³å¿ƒç¯å¢ƒå˜é‡æ‰€è®¾ç½®çš„ å€¼ï¼Œåªå…³å¿ƒå®ƒæ˜¯å¦è¢«è®¾ç½®äº†ï¼Œæ‰€ä»¥æ£€æŸ¥ is_err è€Œä¸æ˜¯ unwrapã€expect æˆ–ä»»ä½•å·²ç»è§è¿‡çš„ Result çš„æ–¹æ³•ã€‚

å°†å˜é‡ case_sensitive çš„å€¼ä¼ é€’ç»™ Config å®ä¾‹ï¼Œè¿™æ · run å‡½æ•°å¯ä»¥è¯»å–å…¶å€¼å¹¶å†³å®šæ˜¯å¦è°ƒç”¨ search æˆ–è€…ç¤ºä¾‹ 12-22 ä¸­å®ç°çš„ search_case_insensitiveã€‚

#### æ£€æŸ¥é”™è¯¯åº”è¯¥å†™å…¥ä½•å¤„

é¦–å…ˆï¼Œè®©è§‚å¯Ÿä¸€ä¸‹ç›®å‰ minigrep æ‰“å°çš„æ‰€æœ‰å†…å®¹æ˜¯å¦‚ä½•è¢«å†™å…¥æ ‡å‡†è¾“å‡ºçš„ï¼ŒåŒ…æ‹¬é‚£äº›åº”è¯¥è¢«å†™å…¥æ ‡å‡†é”™è¯¯çš„é”™è¯¯ä¿¡æ¯ã€‚å¯ä»¥é€šè¿‡å°†æ ‡å‡†è¾“å‡ºæµé‡å®šå‘åˆ°ä¸€ä¸ªæ–‡ä»¶åŒæ—¶æœ‰æ„äº§ç”Ÿä¸€ä¸ªé”™è¯¯æ¥åšåˆ°è¿™ä¸€ç‚¹ã€‚æ²¡æœ‰é‡å®šå‘æ ‡å‡†é”™è¯¯æµï¼Œæ‰€ä»¥ä»»ä½•å‘é€åˆ°æ ‡å‡†é”™è¯¯çš„å†…å®¹å°†ä¼šç»§ç»­æ˜¾ç¤ºåœ¨å±å¹•ä¸Šã€‚

å‘½ä»¤è¡Œç¨‹åºè¢«æœŸæœ›å°†é”™è¯¯ä¿¡æ¯å‘é€åˆ°æ ‡å‡†é”™è¯¯æµï¼Œè¿™æ ·å³ä¾¿é€‰æ‹©å°†æ ‡å‡†è¾“å‡ºæµé‡å®šå‘åˆ°æ–‡ä»¶ä¸­æ—¶ä»ç„¶èƒ½çœ‹åˆ°é”™è¯¯ä¿¡æ¯ã€‚ç›®å‰çš„ç¨‹åºå¹¶ä¸ç¬¦åˆæœŸæœ›ï¼›ç›¸åå°†çœ‹åˆ°å®ƒå°†é”™è¯¯ä¿¡æ¯è¾“å‡ºä¿å­˜åˆ°äº†æ–‡ä»¶ä¸­ã€‚

#### å°†é”™è¯¯æ‰“å°åˆ°æ ‡å‡†é”™è¯¯

```rust
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {}", err);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!("Application error: {}", e);

        process::exit(1);
    }
}

```

### Rust ä¸­çš„å‡½æ•°å¼è¯­è¨€åŠŸèƒ½ï¼šè¿­ä»£å™¨ä¸é—­åŒ…

Rust çš„è®¾è®¡çµæ„Ÿæ¥æºäºå¾ˆå¤šç°å­˜çš„è¯­è¨€å’ŒæŠ€æœ¯ã€‚å…¶ä¸­ä¸€ä¸ªæ˜¾è‘—çš„å½±å“å°±æ˜¯ å‡½æ•°å¼ç¼–ç¨‹ï¼ˆfunctional programmingï¼‰ã€‚å‡½æ•°å¼ç¼–ç¨‹é£æ ¼é€šå¸¸åŒ…å«å°†å‡½æ•°ä½œä¸ºå‚æ•°å€¼æˆ–å…¶ä»–å‡½æ•°çš„è¿”å›å€¼ã€å°†å‡½æ•°èµ‹å€¼ç»™å˜é‡ä»¥ä¾›ä¹‹åæ‰§è¡Œç­‰ç­‰ã€‚

æœ¬ç« ä¸ä¼šè®¨è®ºå‡½æ•°å¼ç¼–ç¨‹æ˜¯æˆ–ä¸æ˜¯ä»€ä¹ˆçš„é—®é¢˜ï¼Œè€Œæ˜¯å±•ç¤º Rust çš„ä¸€äº›åœ¨åŠŸèƒ½ä¸Šä¸å…¶ä»–è¢«è®¤ä¸ºæ˜¯å‡½æ•°å¼è¯­è¨€ç±»ä¼¼çš„ç‰¹æ€§ã€‚

æ›´å…·ä½“çš„ï¼Œå°†è¦æ¶‰åŠï¼š

* **é—­åŒ…ï¼ˆClosuresï¼‰**ï¼Œä¸€ä¸ªå¯ä»¥å‚¨å­˜åœ¨å˜é‡é‡Œçš„ç±»ä¼¼å‡½æ•°çš„ç»“æ„
* **è¿­ä»£å™¨ï¼ˆIteratorsï¼‰**ï¼Œä¸€ç§å¤„ç†å…ƒç´ åºåˆ—çš„æ–¹å¼

#### é—­åŒ…ï¼šå¯ä»¥æ•è·ç¯å¢ƒçš„åŒ¿åå‡½æ•°

Rust çš„ é—­åŒ…ï¼ˆclosuresï¼‰æ˜¯å¯ä»¥ä¿å­˜è¿›å˜é‡æˆ–ä½œä¸ºå‚æ•°ä¼ é€’ç»™å…¶ä»–å‡½æ•°çš„åŒ¿åå‡½æ•°ã€‚å¯ä»¥åœ¨ä¸€ä¸ªåœ°æ–¹åˆ›å»ºé—­åŒ…ï¼Œç„¶ååœ¨ä¸åŒçš„ä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œé—­åŒ…è¿ç®—ã€‚ä¸åŒäºå‡½æ•°ï¼Œé—­åŒ…å…è®¸æ•è·è°ƒç”¨è€…ä½œç”¨åŸŸä¸­çš„å€¼ã€‚å°†å±•ç¤ºé—­åŒ…çš„è¿™äº›åŠŸèƒ½å¦‚ä½•å¤ç”¨ä»£ç å’Œè‡ªå®šä¹‰è¡Œä¸ºã€‚

#### ä½¿ç”¨é—­åŒ…åˆ›å»ºè¡Œä¸ºçš„æŠ½è±¡

è®©æ¥çœ‹ä¸€ä¸ªå­˜å‚¨ç¨åè¦æ‰§è¡Œçš„é—­åŒ…çš„ç¤ºä¾‹ã€‚å…¶é—´ä¼šè®¨è®ºé—­åŒ…çš„è¯­æ³•ã€ç±»å‹æ¨æ–­å’Œ traitã€‚

è€ƒè™‘ä¸€ä¸‹è¿™ä¸ªå‡æƒ³çš„æƒ…å†µï¼šåœ¨ä¸€ä¸ªé€šè¿‡ app ç”Ÿæˆè‡ªå®šä¹‰å¥èº«è®¡åˆ’çš„åˆåˆ›ä¼ä¸šå·¥ä½œã€‚å…¶åç«¯ä½¿ç”¨ Rust ç¼–å†™ï¼Œè€Œç”Ÿæˆå¥èº«è®¡åˆ’çš„ç®—æ³•éœ€è¦è€ƒè™‘å¾ˆå¤šä¸åŒçš„å› ç´ ï¼Œæ¯”å¦‚ç”¨æˆ·çš„å¹´é¾„ã€èº«ä½“è´¨é‡æŒ‡æ•°ï¼ˆBody Mass Indexï¼‰ã€ç”¨æˆ·å–œå¥½ã€æœ€è¿‘çš„å¥èº«æ´»åŠ¨å’Œç”¨æˆ·æŒ‡å®šçš„å¼ºåº¦ç³»æ•°ã€‚æœ¬ä¾‹ä¸­å®é™…çš„ç®—æ³•å¹¶ä¸é‡è¦ï¼Œé‡è¦çš„æ˜¯è¿™ä¸ªè®¡ç®—åªèŠ±è´¹å‡ ç§’é’Ÿã€‚åªå¸Œæœ›åœ¨éœ€è¦æ—¶è°ƒç”¨ç®—æ³•ï¼Œå¹¶ä¸”åªå¸Œæœ›è°ƒç”¨ä¸€æ¬¡ï¼Œè¿™æ ·å°±ä¸ä¼šè®©ç”¨æˆ·ç­‰å¾—å¤ªä¹…ã€‚

```rust

#![allow(unused_variables)]
fn main() {
use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: u32) -> u32 {
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    intensity
}
}
```

æ¥ä¸‹æ¥ï¼Œmain å‡½æ•°ä¸­å°†ä¼šåŒ…å«æœ¬ä¾‹çš„å¥èº« app ä¸­çš„é‡è¦éƒ¨åˆ†ã€‚è¿™ä»£è¡¨å½“ç”¨æˆ·è¯·æ±‚å¥èº«è®¡åˆ’æ—¶ app ä¼šè°ƒç”¨çš„ä»£ç ã€‚å› ä¸ºä¸ app å‰ç«¯çš„äº¤äº’ä¸é—­åŒ…çš„ä½¿ç”¨å¹¶ä¸ç›¸å…³ï¼Œæ‰€ä»¥å°†ç¡¬ç¼–ç ä»£è¡¨ç¨‹åºè¾“å…¥çš„å€¼å¹¶æ‰“å°è¾“å‡ºã€‚

æ‰€éœ€çš„è¾“å…¥æœ‰è¿™äº›ï¼š

* ä¸€ä¸ªæ¥è‡ªç”¨æˆ·çš„ intensity æ•°å­—ï¼Œè¯·æ±‚å¥èº«è®¡åˆ’æ—¶æŒ‡å®šï¼Œå®ƒä»£è¡¨ç”¨æˆ·å–œå¥½ä½å¼ºåº¦è¿˜æ˜¯é«˜å¼ºåº¦å¥èº«ã€‚
* ä¸€ä¸ªéšæœºæ•°ï¼Œå…¶ä¼šåœ¨å¥èº«è®¡åˆ’ä¸­ç”Ÿæˆå˜åŒ–ã€‚

ç¨‹åºçš„è¾“å‡ºå°†ä¼šæ˜¯å»ºè®®çš„é”»ç‚¼è®¡åˆ’ã€‚ç¤ºä¾‹ 13-2 å±•ç¤ºäº†å°†è¦ä½¿ç”¨çš„ main å‡½æ•°ï¼š

```rust
fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;

    generate_workout(
        simulated_user_specified_value,
        simulated_random_number
    );
}
fn generate_workout(intensity: u32, random_number: u32) {}

```

å‡ºäºç®€å•è€ƒè™‘è¿™é‡Œç¡¬ç¼–ç äº† simulated_user_specified_value å˜é‡çš„å€¼ä¸º 10 å’Œ simulated_random_number å˜é‡çš„å€¼ä¸º 7ï¼›ä¸€ä¸ªå®é™…çš„ç¨‹åºä¼šä» app å‰ç«¯è·å–å¼ºåº¦ç³»æ•°å¹¶ä½¿ç”¨ rand crate æ¥ç”Ÿæˆéšæœºæ•°ï¼Œæ­£å¦‚ç¬¬äºŒç« çš„çŒœçŒœçœ‹æ¸¸æˆæ‰€åšçš„é‚£æ ·ã€‚main å‡½æ•°ä½¿ç”¨æ¨¡æ‹Ÿçš„è¾“å…¥å€¼è°ƒç”¨ generate_workout å‡½æ•°ï¼š

ç°åœ¨æœ‰äº†æ‰§è¡Œä¸Šä¸‹æ–‡ï¼Œè®©ç¼–å†™ç®—æ³•ã€‚ç¤ºä¾‹ 13-3 ä¸­çš„ generate_workout å‡½æ•°åŒ…å«æœ¬ä¾‹ä¸­æœ€å…³å¿ƒçš„ app ä¸šåŠ¡é€»è¾‘ã€‚æœ¬ä¾‹ä¸­ä½™ä¸‹çš„ä»£ç ä¿®æ”¹éƒ½å°†åœ¨è¿™ä¸ªå‡½æ•°ä¸­è¿›è¡Œï¼š

```rust

#![allow(unused_variables)]
fn main() {
use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(num: u32) -> u32 {
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    num
}

fn generate_workout(intensity: u32, random_number: u32) {
    if intensity < 25 {
        println!(
            "Today, do {} pushups!",
            simulated_expensive_calculation(intensity)
        );
        println!(
            "Next, do {} situps!",
            simulated_expensive_calculation(intensity)
        );
    } else {
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!(
                "Today, run for {} minutes!",
                simulated_expensive_calculation(intensity)
            );
        }
    }
}
}
```

ç°åœ¨è¿™ä»½ä»£ç èƒ½å¤Ÿåº”å¯¹çš„éœ€æ±‚äº†ï¼Œä½†æ•°æ®ç§‘å­¦éƒ¨é—¨çš„åŒå­¦å‘ŠçŸ¥å°†æ¥ä¼šå¯¹è°ƒç”¨ simulated_expensive_calculation çš„æ–¹å¼åšå‡ºä¸€äº›æ”¹å˜ã€‚ä¸ºäº†åœ¨è¦åšè¿™äº›æ”¹åŠ¨çš„æ—¶å€™ç®€åŒ–æ›´æ–°æ­¥éª¤ï¼Œå°†é‡æ„ä»£ç æ¥è®©å®ƒåªè°ƒç”¨ simulated_expensive_calculation ä¸€æ¬¡ã€‚åŒæ—¶è¿˜å¸Œæœ›å»æ‰ç›®å‰å¤šä½™çš„è¿ç»­ä¸¤æ¬¡å‡½æ•°è°ƒç”¨ï¼Œå¹¶ä¸å¸Œæœ›åœ¨è®¡ç®—è¿‡ç¨‹ä¸­å¢åŠ ä»»ä½•å…¶ä»–æ­¤å‡½æ•°çš„è°ƒç”¨ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸å¸Œæœ›åœ¨å®Œå…¨æ— éœ€å…¶ç»“æœçš„æƒ…å†µè°ƒç”¨å‡½æ•°ï¼Œä¸è¿‡ä»ç„¶å¸Œæœ›åªè°ƒç”¨å‡½æ•°ä¸€æ¬¡ã€‚

#### ä½¿ç”¨å‡½æ•°é‡æ„

```rust

#![allow(unused_variables)]
fn main() {
use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(num: u32) -> u32 {
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    num
}

fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_result =
        simulated_expensive_calculation(intensity);

    if intensity < 25 {
        println!(
            "Today, do {} pushups!",
            expensive_result
        );
        println!(
            "Next, do {} situps!",
            expensive_result
        );
    } else {
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!(
                "Today, run for {} minutes!",
                expensive_result
            );
        }
    }
}
}
```

#### é‡æ„ä½¿ç”¨é—­åŒ…å‚¨å­˜ä»£ç 

ä¸åŒäºæ€»æ˜¯åœ¨ if å—ä¹‹å‰è°ƒç”¨ simulated_expensive_calculation å‡½æ•°å¹¶å‚¨å­˜å…¶ç»“æœï¼Œå¯ä»¥å®šä¹‰ä¸€ä¸ªé—­åŒ…å¹¶å°†å…¶å‚¨å­˜åœ¨å˜é‡ä¸­ï¼Œå¦‚ç¤ºä¾‹ 13-5 æ‰€ç¤ºã€‚å®é™…ä¸Šå¯ä»¥é€‰æ‹©å°†æ•´ä¸ª simulated_expensive_calculation å‡½æ•°ä½“ç§»åŠ¨åˆ°è¿™é‡Œå¼•å…¥çš„é—­åŒ…ä¸­ï¼š

```rust

#![allow(unused_variables)]
fn main() {
use std::thread;
use std::time::Duration;

let expensive_closure = |num| {
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    num
};
expensive_closure(5);
}
```

é—­åŒ…å®šä¹‰æ˜¯ expensive_closure èµ‹å€¼çš„ = ä¹‹åçš„éƒ¨åˆ†ã€‚é—­åŒ…çš„å®šä¹‰ä»¥ä¸€å¯¹ç«–çº¿ï¼ˆ|ï¼‰å¼€å§‹ï¼Œåœ¨ç«–çº¿ä¸­æŒ‡å®šé—­åŒ…çš„å‚æ•°ï¼›ä¹‹æ‰€ä»¥é€‰æ‹©è¿™ä¸ªè¯­æ³•æ˜¯å› ä¸ºå®ƒä¸ Smalltalk å’Œ Ruby çš„é—­åŒ…å®šä¹‰ç±»ä¼¼ã€‚è¿™ä¸ªé—­åŒ…æœ‰ä¸€ä¸ªå‚æ•° numï¼›å¦‚æœæœ‰å¤šäºä¸€ä¸ªå‚æ•°ï¼Œå¯ä»¥ä½¿ç”¨é€—å·åˆ†éš”ï¼Œæ¯”å¦‚ |param1, param2|ã€‚

å‚æ•°ä¹‹åæ˜¯å­˜æ”¾é—­åŒ…ä½“çš„å¤§æ‹¬å· â€”â€” å¦‚æœé—­åŒ…ä½“åªæœ‰ä¸€è¡Œåˆ™å¤§æ‹¬å·æ˜¯å¯ä»¥çœç•¥çš„ã€‚å¤§æ‹¬å·ä¹‹åé—­åŒ…çš„ç»“å°¾ï¼Œéœ€è¦ç”¨äº let è¯­å¥çš„åˆ†å·ã€‚å› ä¸ºé—­åŒ…ä½“çš„æœ€åä¸€è¡Œæ²¡æœ‰åˆ†å·ï¼ˆæ­£å¦‚å‡½æ•°ä½“ä¸€æ ·ï¼‰ï¼Œæ‰€ä»¥é—­åŒ…ä½“ï¼ˆnumï¼‰æœ€åä¸€è¡Œçš„è¿”å›å€¼ä½œä¸ºè°ƒç”¨é—­åŒ…æ—¶çš„è¿”å›å€¼ ã€‚

æ³¨æ„è¿™ä¸ª let è¯­å¥æ„å‘³ç€ expensive_closure åŒ…å«ä¸€ä¸ªåŒ¿åå‡½æ•°çš„ å®šä¹‰ï¼Œä¸æ˜¯è°ƒç”¨åŒ¿åå‡½æ•°çš„ è¿”å›å€¼ã€‚å›å¿†ä¸€ä¸‹ä½¿ç”¨é—­åŒ…çš„åŸå› æ˜¯éœ€è¦åœ¨ä¸€ä¸ªä½ç½®å®šä¹‰ä»£ç ï¼Œå‚¨å­˜ä»£ç ï¼Œå¹¶åœ¨ä¹‹åçš„ä½ç½®å®é™…è°ƒç”¨å®ƒï¼›æœŸæœ›è°ƒç”¨çš„ä»£ç ç°åœ¨å‚¨å­˜åœ¨ expensive_closure ä¸­ã€‚

å®šä¹‰äº†é—­åŒ…ä¹‹åï¼Œå¯ä»¥æ”¹å˜ if å—ä¸­çš„ä»£ç æ¥è°ƒç”¨é—­åŒ…ä»¥æ‰§è¡Œä»£ç å¹¶è·å–ç»“æœå€¼ã€‚è°ƒç”¨é—­åŒ…ç±»ä¼¼äºè°ƒç”¨å‡½æ•°ï¼›æŒ‡å®šå­˜æ”¾é—­åŒ…å®šä¹‰çš„å˜é‡åå¹¶åè·ŸåŒ…å«æœŸæœ›ä½¿ç”¨çš„å‚æ•°çš„æ‹¬å·ï¼Œ

```rust

#![allow(unused_variables)]
fn main() {
use std::thread;
use std::time::Duration;

fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num| {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };

    if intensity < 25 {
        println!(
            "Today, do {} pushups!",
            expensive_closure(intensity)
        );
        println!(
            "Next, do {} situps!",
            expensive_closure(intensity)
        );
    } else {
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!(
                "Today, run for {} minutes!",
                expensive_closure(intensity)
            );
        }
    }
}
}
```

ä»ç„¶åœ¨ç¬¬ä¸€ä¸ª if å—ä¸­è°ƒç”¨äº†é—­åŒ…ä¸¤æ¬¡ï¼Œè¿™è°ƒç”¨äº†æ…¢è®¡ç®—ä»£ç ä¸¤æ¬¡è€Œä½¿å¾—ç”¨æˆ·éœ€è¦å¤šç­‰å¾…ä¸€å€çš„æ—¶é—´ã€‚å¯ä»¥é€šè¿‡åœ¨ if å—ä¸­åˆ›å»ºä¸€ä¸ªæœ¬åœ°å˜é‡å­˜æ”¾é—­åŒ…è°ƒç”¨çš„ç»“æœæ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä¸è¿‡é—­åŒ…å¯ä»¥æä¾›å¦å¤–ä¸€ç§è§£å†³æ–¹æ¡ˆã€‚ç¨åä¼šè®¨è®ºè¿™ä¸ªæ–¹æ¡ˆï¼Œä¸è¿‡ç›®å‰è®©é¦–å…ˆè®¨è®ºä¸€ä¸‹ä¸ºä½•é—­åŒ…å®šä¹‰ä¸­å’Œæ‰€æ¶‰åŠçš„ trait ä¸­æ²¡æœ‰ç±»å‹æ³¨è§£ã€‚

#### é—­åŒ…ç±»å‹æ¨æ–­å’Œæ³¨è§£

é—­åŒ…ä¸è¦æ±‚åƒ fn å‡½æ•°é‚£æ ·åœ¨å‚æ•°å’Œè¿”å›å€¼ä¸Šæ³¨æ˜ç±»å‹ã€‚å‡½æ•°ä¸­éœ€è¦ç±»å‹æ³¨è§£æ˜¯å› ä¸ºä»–ä»¬æ˜¯æš´éœ²ç»™ç”¨æˆ·çš„æ˜¾å¼æ¥å£çš„ä¸€éƒ¨åˆ†ã€‚ä¸¥æ ¼çš„å®šä¹‰è¿™äº›æ¥å£å¯¹äºä¿è¯æ‰€æœ‰äººéƒ½è®¤åŒå‡½æ•°ä½¿ç”¨å’Œè¿”å›å€¼çš„ç±»å‹æ¥è¯´æ˜¯å¾ˆé‡è¦çš„ã€‚ä½†æ˜¯é—­åŒ…å¹¶ä¸ç”¨äºè¿™æ ·æš´éœ²åœ¨å¤–çš„æ¥å£ï¼šä»–ä»¬å‚¨å­˜åœ¨å˜é‡ä¸­å¹¶è¢«ä½¿ç”¨ï¼Œä¸ç”¨å‘½åä»–ä»¬æˆ–æš´éœ²ç»™åº“çš„ç”¨æˆ·è°ƒç”¨ã€‚

é—­åŒ…é€šå¸¸å¾ˆçŸ­å¹¶åªä¸å¯¹åº”ç›¸å¯¹ä»»æ„çš„åœºæ™¯è¾ƒå°çš„ä¸Šä¸‹æ–‡ä¸­ã€‚åœ¨è¿™äº›æœ‰é™åˆ¶çš„ä¸Šä¸‹æ–‡ä¸­ï¼Œç¼–è¯‘å™¨èƒ½å¯é çš„æ¨æ–­å‚æ•°å’Œè¿”å›å€¼çš„ç±»å‹ï¼Œç±»ä¼¼äºå®ƒæ˜¯å¦‚ä½•èƒ½å¤Ÿæ¨æ–­å¤§éƒ¨åˆ†å˜é‡çš„ç±»å‹ä¸€æ ·ã€‚

å¼ºåˆ¶åœ¨è¿™äº›å°çš„åŒ¿åå‡½æ•°ä¸­æ³¨æ˜ç±»å‹æ˜¯å¾ˆæ¼äººçš„ï¼Œå¹¶ä¸”ä¸ç¼–è¯‘å™¨å·²çŸ¥çš„ä¿¡æ¯å­˜åœ¨å¤§é‡çš„é‡å¤ã€‚

ç±»ä¼¼äºå˜é‡ï¼Œå¦‚æœç›¸æ¯”ä¸¥æ ¼çš„å¿…è¦æ€§æ›´å¸Œæœ›å¢åŠ æ˜ç¡®æ€§å¹¶å˜å¾—æ›´å•°å—¦ï¼Œå¯ä»¥é€‰æ‹©å¢åŠ ç±»å‹æ³¨è§£ï¼›

```rust

#![allow(unused_variables)]
fn main() {
use std::thread;
use std::time::Duration;

let expensive_closure = |num: u32| -> u32 {
    println!("calculating slowly...");
    thread::sleep(Duration::from_secs(2));
    num
};
}
```

æœ‰äº†ç±»å‹æ³¨è§£é—­åŒ…çš„è¯­æ³•å°±æ›´ç±»ä¼¼å‡½æ•°äº†ã€‚å¦‚ä¸‹æ˜¯ä¸€ä¸ªå¯¹å…¶å‚æ•°åŠ ä¸€çš„å‡½æ•°çš„å®šä¹‰ä¸æ‹¥æœ‰ç›¸åŒè¡Œä¸ºé—­åŒ…è¯­æ³•çš„çºµå‘å¯¹æ¯”ã€‚è¿™é‡Œå¢åŠ äº†ä¸€äº›ç©ºæ ¼æ¥å¯¹é½ç›¸åº”éƒ¨åˆ†ã€‚è¿™å±•ç¤ºäº†é—­åŒ…è¯­æ³•å¦‚ä½•ç±»ä¼¼äºå‡½æ•°è¯­æ³•ï¼Œé™¤äº†ä½¿ç”¨ç«–çº¿è€Œä¸æ˜¯æ‹¬å·ä»¥åŠå‡ ä¸ªå¯é€‰çš„è¯­æ³•ä¹‹å¤–ï¼š

```rust
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;

```

ç¬¬ä¸€è¡Œå±•ç¤ºäº†ä¸€ä¸ªå‡½æ•°å®šä¹‰ï¼Œè€Œç¬¬äºŒè¡Œå±•ç¤ºäº†ä¸€ä¸ªå®Œæ•´æ ‡æ³¨çš„é—­åŒ…å®šä¹‰ã€‚ç¬¬ä¸‰è¡Œé—­åŒ…å®šä¹‰ä¸­çœç•¥äº†ç±»å‹æ³¨è§£ï¼Œè€Œç¬¬å››è¡Œå»æ‰äº†å¯é€‰çš„å¤§æ‹¬å·ï¼Œå› ä¸ºé—­åŒ…ä½“åªæœ‰ä¸€è¡Œã€‚è¿™äº›éƒ½æ˜¯æœ‰æ•ˆçš„é—­åŒ…å®šä¹‰ï¼Œå¹¶åœ¨è°ƒç”¨æ—¶äº§ç”Ÿç›¸åŒçš„è¡Œä¸ºã€‚

é—­åŒ…å®šä¹‰ä¼šä¸ºæ¯ä¸ªå‚æ•°å’Œè¿”å›å€¼æ¨æ–­ä¸€ä¸ªå…·ä½“ç±»å‹ã€‚ä¾‹å¦‚ï¼Œä¸‹ä¾‹ä¸­å±•ç¤ºäº†ä»…ä»…å°†å‚æ•°ä½œä¸ºè¿”å›å€¼çš„ç®€çŸ­çš„é—­åŒ…å®šä¹‰ã€‚é™¤äº†ä½œä¸ºç¤ºä¾‹çš„ç›®çš„è¿™ä¸ªé—­åŒ…å¹¶ä¸æ˜¯å¾ˆå®ç”¨ã€‚æ³¨æ„å…¶å®šä¹‰å¹¶æ²¡æœ‰å¢åŠ ä»»ä½•ç±»å‹æ³¨è§£ï¼šå¦‚æœå°è¯•è°ƒç”¨é—­åŒ…ä¸¤æ¬¡ï¼Œç¬¬ä¸€æ¬¡ä½¿ç”¨ String ç±»å‹ä½œä¸ºå‚æ•°è€Œç¬¬äºŒæ¬¡ä½¿ç”¨ u32ï¼Œåˆ™ä¼šå¾—åˆ°ä¸€ä¸ªé”™è¯¯ï¼š

```rust
let example_closure = |x| x;

let s = example_closure(String::from("hello"));
let n = example_closure(5);

```

#### ä½¿ç”¨å¸¦æœ‰æ³›å‹å’Œ Fn trait çš„é—­åŒ…

ä»ç„¶è°ƒç”¨äº†å¤šäºéœ€è¦çš„æ…¢è®¡ç®—é—­åŒ…ã€‚è§£å†³è¿™ä¸ªé—®é¢˜çš„ä¸€ä¸ªæ–¹æ³•æ˜¯åœ¨å…¨éƒ¨ä»£ç ä¸­çš„æ¯ä¸€ä¸ªéœ€è¦å¤šä¸ªæ…¢è®¡ç®—é—­åŒ…ç»“æœçš„åœ°æ–¹ï¼Œå¯ä»¥å°†ç»“æœä¿å­˜è¿›å˜é‡ä»¥ä¾›å¤ç”¨ï¼Œè¿™æ ·å°±å¯ä»¥ä½¿ç”¨å˜é‡è€Œä¸æ˜¯å†æ¬¡è°ƒç”¨é—­åŒ…ã€‚ä½†æ˜¯è¿™æ ·å°±ä¼šæœ‰å¾ˆå¤šé‡å¤çš„ä¿å­˜ç»“æœå˜é‡çš„åœ°æ–¹ã€‚

å¹¸è¿çš„æ˜¯ï¼Œè¿˜æœ‰å¦ä¸€ä¸ªå¯ç”¨çš„æ–¹æ¡ˆã€‚å¯ä»¥åˆ›å»ºä¸€ä¸ªå­˜æ”¾é—­åŒ…å’Œè°ƒç”¨é—­åŒ…ç»“æœçš„ç»“æ„ä½“ã€‚è¯¥ç»“æ„ä½“åªä¼šåœ¨éœ€è¦ç»“æœæ—¶æ‰§è¡Œé—­åŒ…ï¼Œå¹¶ä¼šç¼“å­˜ç»“æœå€¼ï¼Œè¿™æ ·ä½™ä¸‹çš„ä»£ç å°±ä¸å¿…å†è´Ÿè´£ä¿å­˜ç»“æœå¹¶å¯ä»¥å¤ç”¨è¯¥å€¼ã€‚å¯èƒ½è§è¿‡è¿™ç§æ¨¡å¼è¢«ç§° memoization æˆ– lazy evaluationã€‚

ä¸ºäº†è®©ç»“æ„ä½“å­˜æ”¾é—­åŒ…ï¼Œéœ€è¦æŒ‡å®šé—­åŒ…çš„ç±»å‹ï¼Œå› ä¸ºç»“æ„ä½“å®šä¹‰éœ€è¦çŸ¥é“å…¶æ¯ä¸€ä¸ªå­—æ®µçš„ç±»å‹ã€‚æ¯ä¸€ä¸ªé—­åŒ…å®ä¾‹æœ‰å…¶è‡ªå·±ç‹¬æœ‰çš„åŒ¿åç±»å‹ï¼šä¹Ÿå°±æ˜¯è¯´ï¼Œå³ä¾¿ä¸¤ä¸ªé—­åŒ…æœ‰ç€ç›¸åŒçš„ç­¾åï¼Œä»–ä»¬çš„ç±»å‹ä»ç„¶å¯ä»¥è¢«è®¤ä¸ºæ˜¯ä¸åŒã€‚ä¸ºäº†å®šä¹‰ä½¿ç”¨é—­åŒ…çš„ç»“æ„ä½“ã€æšä¸¾æˆ–å‡½æ•°å‚æ•°ï¼Œéœ€è¦åƒç¬¬åç« è®¨è®ºçš„é‚£æ ·ä½¿ç”¨æ³›å‹å’Œ trait boundã€‚

Fn ç³»åˆ— trait ç”±æ ‡å‡†åº“æä¾›ã€‚æ‰€æœ‰çš„é—­åŒ…éƒ½å®ç°äº† trait Fnã€FnMut æˆ– FnOnce ä¸­çš„ä¸€ä¸ªã€‚åœ¨ â€œé—­åŒ…ä¼šæ•è·å…¶ç¯å¢ƒâ€ éƒ¨åˆ†ä¼šè®¨è®ºè¿™äº› trait çš„åŒºåˆ«ï¼›åœ¨è¿™ä¸ªä¾‹å­ä¸­å¯ä»¥ä½¿ç”¨ Fn traitã€‚

ä¸ºäº†æ»¡è¶³ Fn trait bound å¢åŠ äº†ä»£è¡¨é—­åŒ…æ‰€å¿…é¡»çš„å‚æ•°å’Œè¿”å›å€¼ç±»å‹çš„ç±»å‹ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œé—­åŒ…æœ‰ä¸€ä¸ª u32 çš„å‚æ•°å¹¶è¿”å›ä¸€ä¸ª u32ï¼Œè¿™æ ·æ‰€æŒ‡å®šçš„ trait bound å°±æ˜¯ Fn(u32) -> u32ã€‚

```rust

#![allow(unused_variables)]
fn main() {
struct Cacher<T>
    where T: Fn(u32) -> u32
{
    calculation: T,
    value: Option<u32>,
}
}
```

ç»“æ„ä½“ Cacher æœ‰ä¸€ä¸ªæ³›å‹ T çš„å­—æ®µ calculationã€‚T çš„ trait bound æŒ‡å®šäº† T æ˜¯ä¸€ä¸ªä½¿ç”¨ Fn çš„é—­åŒ…ã€‚ä»»ä½•å¸Œæœ›å‚¨å­˜åˆ° Cacher å®ä¾‹çš„ calculation å­—æ®µçš„é—­åŒ…å¿…é¡»æœ‰ä¸€ä¸ª u32 å‚æ•°ï¼ˆç”± Fn ä¹‹åçš„æ‹¬å·çš„å†…å®¹æŒ‡å®šï¼‰å¹¶å¿…é¡»è¿”å›ä¸€ä¸ª u32ï¼ˆç”± -> ä¹‹åçš„å†…å®¹ï¼‰ã€‚

å­—æ®µ value æ˜¯ `Option<u32>` ç±»å‹çš„ã€‚åœ¨æ‰§è¡Œé—­åŒ…ä¹‹å‰ï¼Œvalue å°†æ˜¯ Noneã€‚å¦‚æœä½¿ç”¨ Cacher çš„ä»£ç è¯·æ±‚é—­åŒ…çš„ç»“æœï¼Œè¿™æ—¶ä¼šæ‰§è¡Œé—­åŒ…å¹¶å°†ç»“æœå‚¨å­˜åœ¨ value å­—æ®µçš„ Some æˆå‘˜ä¸­ã€‚æ¥ç€å¦‚æœä»£ç å†æ¬¡è¯·æ±‚é—­åŒ…çš„ç»“æœï¼Œè¿™æ—¶ä¸å†æ‰§è¡Œé—­åŒ…ï¼Œè€Œæ˜¯ä¼šè¿”å›å­˜æ”¾åœ¨ Some æˆå‘˜ä¸­çš„ç»“æœã€‚

```rust

#![allow(unused_variables)]
fn main() {
struct Cacher<T>
    where T: Fn(u32) -> u32
{
    calculation: T,
    value: Option<u32>,
}

impl<T> Cacher<T>
    where T: Fn(u32) -> u32
{
    fn new(calculation: T) -> Cacher<T> {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&mut self, arg: u32) -> u32 {
        match self.value {
            Some(v) => v,
            None => {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            },
        }
    }
}
}
```

Cacher ç»“æ„ä½“çš„å­—æ®µæ˜¯ç§æœ‰çš„ï¼Œå› ä¸ºå¸Œæœ› Cacher ç®¡ç†è¿™äº›å€¼è€Œä¸æ˜¯ä»»ç”±è°ƒç”¨ä»£ç æ½œåœ¨çš„ç›´æ¥æ”¹å˜ä»–ä»¬ã€‚

Cacher::new å‡½æ•°è·å–ä¸€ä¸ªæ³›å‹å‚æ•° Tï¼Œå®ƒå®šä¹‰äº impl å—ä¸Šä¸‹æ–‡ä¸­å¹¶ä¸ Cacher ç»“æ„ä½“æœ‰ç€ç›¸åŒçš„ trait boundã€‚Cacher::new è¿”å›ä¸€ä¸ªåœ¨ calculation å­—æ®µä¸­å­˜æ”¾äº†æŒ‡å®šé—­åŒ…å’Œåœ¨ value å­—æ®µä¸­å­˜æ”¾äº† None å€¼çš„ Cacher å®ä¾‹ï¼Œå› ä¸ºè¿˜æœªæ‰§è¡Œé—­åŒ…ã€‚

å½“è°ƒç”¨ä»£ç éœ€è¦é—­åŒ…çš„æ‰§è¡Œç»“æœæ—¶ï¼Œä¸åŒäºç›´æ¥è°ƒç”¨é—­åŒ…ï¼Œå®ƒä¼šè°ƒç”¨ value æ–¹æ³•ã€‚è¿™ä¸ªæ–¹æ³•ä¼šæ£€æŸ¥ self.value æ˜¯å¦å·²ç»æœ‰äº†ä¸€ä¸ª Some çš„ç»“æœå€¼ï¼›å¦‚æœæœ‰ï¼Œå®ƒè¿”å› Some ä¸­çš„å€¼å¹¶ä¸ä¼šå†æ¬¡æ‰§è¡Œé—­åŒ…ã€‚

å¦‚æœ self.value æ˜¯ Noneï¼Œåˆ™ä¼šè°ƒç”¨ self.calculation ä¸­å‚¨å­˜çš„é—­åŒ…ï¼Œå°†ç»“æœä¿å­˜åˆ° self.value ä»¥ä¾¿å°†æ¥ä½¿ç”¨ï¼Œå¹¶åŒæ—¶è¿”å›ç»“æœå€¼ã€‚

```rust

#![allow(unused_variables)]
fn main() {
use std::thread;
use std::time::Duration;

struct Cacher<T>
    where T: Fn(u32) -> u32
{
    calculation: T,
    value: Option<u32>,
}

impl<T> Cacher<T>
    where T: Fn(u32) -> u32
{
    fn new(calculation: T) -> Cacher<T> {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&mut self, arg: u32) -> u32 {
        match self.value {
            Some(v) => v,
            None => {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            },
        }
    }
}

fn generate_workout(intensity: u32, random_number: u32) {
    let mut expensive_result = Cacher::new(|num| {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    });

    if intensity < 25 {
        println!(
            "Today, do {} pushups!",
            expensive_result.value(intensity)
        );
        println!(
            "Next, do {} situps!",
            expensive_result.value(intensity)
        );
    } else {
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!(
                "Today, run for {} minutes!",
                expensive_result.value(intensity)
            );
        }
    }
}
}
```

#### Cacher å®ç°çš„é™åˆ¶

å€¼ç¼“å­˜æ˜¯ä¸€ç§æ›´åŠ å¹¿æ³›çš„å®ç”¨è¡Œä¸ºï¼Œå¯èƒ½å¸Œæœ›åœ¨ä»£ç ä¸­çš„å…¶ä»–é—­åŒ…ä¸­ä¹Ÿä½¿ç”¨ä»–ä»¬ã€‚ç„¶è€Œï¼Œç›®å‰ Cacher çš„å®ç°å­˜åœ¨ä¸¤ä¸ªå°é—®é¢˜ï¼Œè¿™ä½¿å¾—åœ¨ä¸åŒä¸Šä¸‹æ–‡ä¸­å¤ç”¨å˜å¾—å¾ˆå›°éš¾ã€‚

```rust
#[test]
fn call_with_different_values() {
    let mut c = Cacher::new(|a| a);

    let v1 = c.value(1);
    let v2 = c.value(2);

    assert_eq!(v2, 2);
}

```

è¿™ä¸ªæµ‹è¯•ä½¿ç”¨è¿”å›ä¼ é€’ç»™å®ƒçš„å€¼çš„é—­åŒ…åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„ Cacher å®ä¾‹ã€‚ä½¿ç”¨ä¸º 1 çš„ arg å’Œä¸º 2 çš„ arg è°ƒç”¨ Cacher å®ä¾‹çš„ value æ–¹æ³•ï¼ŒåŒæ—¶æœŸæœ›ä½¿ç”¨ä¸º 2 çš„ arg è°ƒç”¨ value ä¼šè¿”å› 2ã€‚

è¿™é‡Œçš„é—®é¢˜æ˜¯ç¬¬ä¸€æ¬¡ä½¿ç”¨ 1 è°ƒç”¨ c.valueï¼ŒCacher å®ä¾‹å°† Some(1) ä¿å­˜è¿› self.valueã€‚åœ¨è¿™ä¹‹åï¼Œæ— è®ºä¼ é€’ä»€ä¹ˆå€¼è°ƒç”¨ valueï¼Œå®ƒæ€»æ˜¯ä¼šè¿”å› 1ã€‚

å°è¯•ä¿®æ”¹ Cacher å­˜æ”¾ä¸€ä¸ªå“ˆå¸Œ map è€Œä¸æ˜¯å•ç‹¬ä¸€ä¸ªå€¼ã€‚å“ˆå¸Œ map çš„ key å°†æ˜¯ä¼ é€’è¿›æ¥çš„ arg å€¼ï¼Œè€Œ value åˆ™æ˜¯å¯¹åº” key è°ƒç”¨é—­åŒ…çš„ç»“æœå€¼ã€‚ç›¸æ¯”ä¹‹å‰æ£€æŸ¥ self.value ç›´æ¥æ˜¯ Some è¿˜æ˜¯ None å€¼ï¼Œç°åœ¨ value å‡½æ•°ä¼šåœ¨å“ˆå¸Œ map ä¸­å¯»æ‰¾ argï¼Œå¦‚æœæ‰¾åˆ°çš„è¯å°±è¿”å›å…¶å¯¹åº”çš„å€¼ã€‚å¦‚æœä¸å­˜åœ¨ï¼ŒCacher ä¼šè°ƒç”¨é—­åŒ…å¹¶å°†ç»“æœå€¼ä¿å­˜åœ¨å“ˆå¸Œ map å¯¹åº” arg å€¼çš„ä½ç½®ã€‚

å½“å‰ Cacher å®ç°çš„ç¬¬äºŒä¸ªé—®é¢˜æ˜¯å®ƒçš„åº”ç”¨è¢«é™åˆ¶ä¸ºåªæ¥å—è·å–ä¸€ä¸ª u32 å€¼å¹¶è¿”å›ä¸€ä¸ª u32 å€¼çš„é—­åŒ…ã€‚æ¯”å¦‚è¯´ï¼Œå¯èƒ½éœ€è¦èƒ½å¤Ÿç¼“å­˜ä¸€ä¸ªè·å–å­—ç¬¦ä¸² slice å¹¶è¿”å› usize å€¼çš„é—­åŒ…çš„ç»“æœã€‚è¯·å°è¯•å¼•å…¥æ›´å¤šæ³›å‹å‚æ•°æ¥å¢åŠ  Cacher åŠŸèƒ½çš„çµæ´»æ€§ã€‚

#### é—­åŒ…ä¼šæ•è·å…¶ç¯å¢ƒ

```rust
fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}

```

```rust
fn main() {
    let x = 4;

    fn equal_to_x(z: i32) -> bool { z == x }

    let y = 4;

    assert!(equal_to_x(y));
}

```

ç¼–è¯‘å™¨ç”šè‡³ä¼šæç¤ºè¿™åªèƒ½ç”¨äºé—­åŒ…ï¼

å½“é—­åŒ…ä»ç¯å¢ƒä¸­æ•è·ä¸€ä¸ªå€¼ï¼Œé—­åŒ…ä¼šåœ¨é—­åŒ…ä½“ä¸­å‚¨å­˜è¿™ä¸ªå€¼ä»¥ä¾›ä½¿ç”¨ã€‚è¿™ä¼šä½¿ç”¨å†…å­˜å¹¶äº§ç”Ÿé¢å¤–çš„å¼€é”€ï¼Œåœ¨æ›´ä¸€èˆ¬çš„åœºæ™¯ä¸­ï¼Œå½“ä¸éœ€è¦é—­åŒ…æ¥æ•è·ç¯å¢ƒæ—¶ï¼Œä¸å¸Œæœ›äº§ç”Ÿè¿™äº›å¼€é”€ã€‚å› ä¸ºå‡½æ•°ä»æœªå…è®¸æ•è·ç¯å¢ƒï¼Œå®šä¹‰å’Œä½¿ç”¨å‡½æ•°ä¹Ÿå°±ä»ä¸ä¼šæœ‰è¿™äº›é¢å¤–å¼€é”€ã€‚

é—­åŒ…å¯ä»¥é€šè¿‡ä¸‰ç§æ–¹å¼æ•è·å…¶ç¯å¢ƒï¼Œä»–ä»¬ç›´æ¥å¯¹åº”å‡½æ•°çš„ä¸‰ç§è·å–å‚æ•°çš„æ–¹å¼ï¼šè·å–æ‰€æœ‰æƒï¼Œå¯å˜å€Ÿç”¨å’Œä¸å¯å˜å€Ÿç”¨ã€‚è¿™ä¸‰ç§æ•è·å€¼çš„æ–¹å¼è¢«ç¼–ç ä¸ºå¦‚ä¸‹ä¸‰ä¸ª Fn traitï¼š

* FnOnce æ¶ˆè´¹ä»å‘¨å›´ä½œç”¨åŸŸæ•è·çš„å˜é‡ï¼Œé—­åŒ…å‘¨å›´çš„ä½œç”¨åŸŸè¢«ç§°ä¸ºå…¶ ç¯å¢ƒï¼Œenvironmentã€‚ä¸ºäº†æ¶ˆè´¹æ•è·åˆ°çš„å˜é‡ï¼Œé—­åŒ…å¿…é¡»è·å–å…¶æ‰€æœ‰æƒå¹¶åœ¨å®šä¹‰é—­åŒ…æ—¶å°†å…¶ç§»åŠ¨è¿›é—­åŒ…ã€‚å…¶åç§°çš„ Once éƒ¨åˆ†ä»£è¡¨äº†é—­åŒ…ä¸èƒ½å¤šæ¬¡è·å–ç›¸åŒå˜é‡çš„æ‰€æœ‰æƒçš„äº‹å®ï¼Œæ‰€ä»¥å®ƒåªèƒ½è¢«è°ƒç”¨ä¸€æ¬¡ã€‚
* FnMut è·å–å¯å˜çš„å€Ÿç”¨å€¼æ‰€ä»¥å¯ä»¥æ”¹å˜å…¶ç¯å¢ƒ
* Fn ä»å…¶ç¯å¢ƒè·å–ä¸å¯å˜çš„å€Ÿç”¨å€¼

å½“åˆ›å»ºä¸€ä¸ªé—­åŒ…æ—¶ï¼ŒRust æ ¹æ®å…¶å¦‚ä½•ä½¿ç”¨ç¯å¢ƒä¸­å˜é‡æ¥æ¨æ–­å¸Œæœ›å¦‚ä½•å¼•ç”¨ç¯å¢ƒã€‚ç”±äºæ‰€æœ‰é—­åŒ…éƒ½å¯ä»¥è¢«è°ƒç”¨è‡³å°‘ä¸€æ¬¡ï¼Œæ‰€ä»¥æ‰€æœ‰é—­åŒ…éƒ½å®ç°äº† FnOnce ã€‚é‚£äº›å¹¶æ²¡æœ‰ç§»åŠ¨è¢«æ•è·å˜é‡çš„æ‰€æœ‰æƒåˆ°é—­åŒ…å†…çš„é—­åŒ…ä¹Ÿå®ç°äº† FnMut ï¼Œè€Œä¸éœ€è¦å¯¹è¢«æ•è·çš„å˜é‡è¿›è¡Œå¯å˜è®¿é—®çš„é—­åŒ…åˆ™ä¹Ÿå®ç°äº† Fn ã€‚

```rust
fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    println!("can't use x here: {:?}", x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}

```

è¿™ä¸ªä¾‹å­å¹¶ä¸èƒ½ç¼–è¯‘ï¼Œä¼šäº§ç”Ÿä»¥ä¸‹é”™è¯¯ï¼š

```rust
error[E0382]: use of moved value: `x`
 --> src/main.rs:6:40
  |
4 |     let equal_to_x = move |z| z == x;
  |                      -------- value moved (into closure) here
5 |
6 |     println!("can't use x here: {:?}", x);
  |                                        ^ value used here after move
  |
  = note: move occurs because `x` has type `std::vec::Vec<i32>`, which does not
  implement the `Copy` trait

```

x è¢«ç§»åŠ¨è¿›äº†é—­åŒ…ï¼Œå› ä¸ºé—­åŒ…ä½¿ç”¨ move å…³é”®å­—å®šä¹‰ã€‚æ¥ç€é—­åŒ…è·å–äº† x çš„æ‰€æœ‰æƒï¼ŒåŒæ—¶ main å°±ä¸å†å…è®¸åœ¨ println! è¯­å¥ä¸­ä½¿ç”¨ x äº†ã€‚å»æ‰ println! å³å¯ä¿®å¤é—®é¢˜ã€‚

å¤§éƒ¨åˆ†éœ€è¦æŒ‡å®šä¸€ä¸ª Fn ç³»åˆ— trait bound çš„æ—¶å€™ï¼Œå¯ä»¥ä» Fn å¼€å§‹ï¼Œè€Œç¼–è¯‘å™¨ä¼šæ ¹æ®é—­åŒ…ä½“ä¸­çš„æƒ…å†µå‘Šè¯‰æ˜¯å¦éœ€è¦ FnMut æˆ– FnOnceã€‚

ä¸ºäº†å±•ç¤ºé—­åŒ…ä½œä¸ºå‡½æ•°å‚æ•°æ—¶æ•è·å…¶ç¯å¢ƒçš„ä½œç”¨ï¼Œè®©ç»§ç»­ä¸‹ä¸€ä¸ªä¸»é¢˜ï¼šè¿­ä»£å™¨ã€‚

#### ä½¿ç”¨è¿­ä»£å™¨å¤„ç†å…ƒç´ åºåˆ—

è¿­ä»£å™¨æ¨¡å¼å…è®¸å¯¹ä¸€ä¸ªé¡¹çš„åºåˆ—è¿›è¡ŒæŸäº›å¤„ç†ã€‚è¿­ä»£å™¨ï¼ˆiteratorï¼‰è´Ÿè´£éå†åºåˆ—ä¸­çš„æ¯ä¸€é¡¹å’Œå†³å®šåºåˆ—ä½•æ—¶ç»“æŸçš„é€»è¾‘ã€‚å½“ä½¿ç”¨è¿­ä»£å™¨æ—¶ï¼Œæ— éœ€é‡æ–°å®ç°è¿™äº›é€»è¾‘ã€‚

åœ¨ Rust ä¸­ï¼Œè¿­ä»£å™¨æ˜¯ æƒ°æ€§çš„ï¼ˆlazyï¼‰ï¼Œè¿™æ„å‘³ç€åœ¨è°ƒç”¨æ–¹æ³•ä½¿ç”¨è¿­ä»£å™¨ä¹‹å‰å®ƒéƒ½ä¸ä¼šæœ‰æ•ˆæœã€‚

```rust

#![allow(unused_variables)]
fn main() {
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
}
```

```rust

#![allow(unused_variables)]
fn main() {
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!("Got: {}", val);
}
}
```

åœ¨æ ‡å‡†åº“ä¸­æ²¡æœ‰æä¾›è¿­ä»£å™¨çš„è¯­è¨€ä¸­ï¼Œå¯èƒ½ä¼šä½¿ç”¨ä¸€ä¸ªä» 0 å¼€å§‹çš„ç´¢å¼•å˜é‡ï¼Œä½¿ç”¨è¿™ä¸ªå˜é‡ç´¢å¼• vector ä¸­çš„å€¼ï¼Œå¹¶å¾ªç¯å¢åŠ å…¶å€¼ç›´åˆ°è¾¾åˆ° vector çš„å…ƒç´ æ•°é‡ã€‚

è¿­ä»£å™¨ä¸ºå¤„ç†äº†æ‰€æœ‰è¿™äº›é€»è¾‘ï¼Œè¿™å‡å°‘äº†é‡å¤ä»£ç å¹¶æ¶ˆé™¤äº†æ½œåœ¨çš„æ··ä¹±ã€‚å¦å¤–ï¼Œè¿­ä»£å™¨çš„å®ç°æ–¹å¼æä¾›äº†å¯¹å¤šç§ä¸åŒçš„åºåˆ—ä½¿ç”¨ç›¸åŒé€»è¾‘çš„çµæ´»æ€§ï¼Œè€Œä¸ä»…ä»…æ˜¯åƒ vector è¿™æ ·å¯ç´¢å¼•çš„æ•°æ®ç»“æ„.è®©çœ‹çœ‹è¿­ä»£å™¨æ˜¯å¦‚ä½•åšåˆ°è¿™äº›çš„ã€‚

#### Iterator trait å’Œ next æ–¹æ³•

è¿­ä»£å™¨éƒ½å®ç°äº†ä¸€ä¸ªå«åš Iterator çš„å®šä¹‰äºæ ‡å‡†åº“çš„ traitã€‚è¿™ä¸ª trait çš„å®šä¹‰çœ‹èµ·æ¥åƒè¿™æ ·ï¼š

```rust

#![allow(unused_variables)]
fn main() {
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // æ­¤å¤„çœç•¥äº†æ–¹æ³•çš„é»˜è®¤å®ç°
}
}
```

æ³¨æ„è¿™é‡Œæœ‰ä¸€ä¸‹è¿˜æœªè®²åˆ°çš„æ–°è¯­æ³•ï¼štype Item å’Œ Self::Itemï¼Œä»–ä»¬å®šä¹‰äº† trait çš„ å…³è”ç±»å‹ï¼ˆassociated typeï¼‰ã€‚ç¬¬åä¹ç« ä¼šæ·±å…¥è®²è§£å…³è”ç±»å‹ï¼Œä¸è¿‡ç°åœ¨åªéœ€çŸ¥é“è¿™æ®µä»£ç è¡¨æ˜å®ç° Iterator trait è¦æ±‚åŒæ—¶å®šä¹‰ä¸€ä¸ª Item ç±»å‹ï¼Œè¿™ä¸ª Item ç±»å‹è¢«ç”¨ä½œ next æ–¹æ³•çš„è¿”å›å€¼ç±»å‹ã€‚æ¢å¥è¯è¯´ï¼ŒItem ç±»å‹å°†æ˜¯è¿­ä»£å™¨è¿”å›å…ƒç´ çš„ç±»å‹ã€‚

next æ˜¯ Iterator å®ç°è€…è¢«è¦æ±‚å®šä¹‰çš„å”¯ä¸€æ–¹æ³•ã€‚next ä¸€æ¬¡è¿”å›è¿­ä»£å™¨ä¸­çš„ä¸€ä¸ªé¡¹ï¼Œå°è£…åœ¨ Some ä¸­ï¼Œå½“è¿­ä»£å™¨ç»“æŸæ—¶ï¼Œå®ƒè¿”å› Noneã€‚

å¯ä»¥ç›´æ¥è°ƒç”¨è¿­ä»£å™¨çš„ next æ–¹æ³•ï¼›ä¸‹ä¾‹  æœ‰ä¸€ä¸ªæµ‹è¯•å±•ç¤ºäº†é‡å¤è°ƒç”¨ç”± vector åˆ›å»ºçš„è¿­ä»£å™¨çš„ next æ–¹æ³•æ‰€å¾—åˆ°çš„å€¼ï¼š

```rust

#![allow(unused_variables)]
fn main() {
#[test]
fn iterator_demonstration() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();

    assert_eq!(v1_iter.next(), Some(&1));
    assert_eq!(v1_iter.next(), Some(&2));
    assert_eq!(v1_iter.next(), Some(&3));
    assert_eq!(v1_iter.next(), None);
}
}
```

æ³¨æ„ v1_iter éœ€è¦æ˜¯å¯å˜çš„ï¼šåœ¨è¿­ä»£å™¨ä¸Šè°ƒç”¨ next æ–¹æ³•æ”¹å˜äº†è¿­ä»£å™¨ä¸­ç”¨æ¥è®°å½•åºåˆ—ä½ç½®çš„çŠ¶æ€ã€‚æ¢å¥è¯è¯´ï¼Œä»£ç  æ¶ˆè´¹ï¼ˆconsumeï¼‰äº†ï¼Œæˆ–ä½¿ç”¨äº†è¿­ä»£å™¨ã€‚æ¯ä¸€ä¸ª next è°ƒç”¨éƒ½ä¼šä»è¿­ä»£å™¨ä¸­æ¶ˆè´¹ä¸€ä¸ªé¡¹ã€‚ä½¿ç”¨ for å¾ªç¯æ—¶æ— éœ€ä½¿ v1_iter å¯å˜å› ä¸º for å¾ªç¯ä¼šè·å– v1_iter çš„æ‰€æœ‰æƒå¹¶åœ¨åå°ä½¿ v1_iter å¯å˜ã€‚

å¦å¤–éœ€è¦æ³¨æ„åˆ°ä» next è°ƒç”¨ä¸­å¾—åˆ°çš„å€¼æ˜¯ vector çš„ä¸å¯å˜å¼•ç”¨ã€‚iter æ–¹æ³•ç”Ÿæˆä¸€ä¸ªä¸å¯å˜å¼•ç”¨çš„è¿­ä»£å™¨ã€‚å¦‚æœéœ€è¦ä¸€ä¸ªè·å– v1 æ‰€æœ‰æƒå¹¶è¿”å›æ‹¥æœ‰æ‰€æœ‰æƒçš„è¿­ä»£å™¨ï¼Œåˆ™å¯ä»¥è°ƒç”¨ into_iter è€Œä¸æ˜¯ iterã€‚ç±»ä¼¼çš„ï¼Œå¦‚æœå¸Œæœ›è¿­ä»£å¯å˜å¼•ç”¨ï¼Œåˆ™å¯ä»¥è°ƒç”¨ iter_mut è€Œä¸æ˜¯ iterã€‚

#### æ¶ˆè´¹è¿­ä»£å™¨çš„æ–¹æ³•

Iterator trait æœ‰ä¸€ç³»åˆ—ä¸åŒçš„ç”±æ ‡å‡†åº“æä¾›é»˜è®¤å®ç°çš„æ–¹æ³•ï¼›å¯ä»¥åœ¨ Iterator trait çš„æ ‡å‡†åº“ API æ–‡æ¡£ä¸­æ‰¾åˆ°æ‰€æœ‰è¿™äº›æ–¹æ³•ã€‚ä¸€äº›æ–¹æ³•åœ¨å…¶å®šä¹‰ä¸­è°ƒç”¨äº† next æ–¹æ³•ï¼Œè¿™ä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆåœ¨å®ç° Iterator trait æ—¶è¦æ±‚å®ç° next æ–¹æ³•çš„åŸå› ã€‚

è¿™äº›è°ƒç”¨ next æ–¹æ³•çš„æ–¹æ³•è¢«ç§°ä¸º æ¶ˆè´¹é€‚é…å™¨ï¼ˆconsuming adaptorsï¼‰ï¼Œå› ä¸ºè°ƒç”¨ä»–ä»¬ä¼šæ¶ˆè€—è¿­ä»£å™¨ã€‚ä¸€ä¸ªæ¶ˆè´¹é€‚é…å™¨çš„ä¾‹å­æ˜¯ sum æ–¹æ³•ã€‚è¿™ä¸ªæ–¹æ³•è·å–è¿­ä»£å™¨çš„æ‰€æœ‰æƒå¹¶åå¤è°ƒç”¨ next æ¥éå†è¿­ä»£å™¨ï¼Œå› è€Œä¼šæ¶ˆè´¹è¿­ä»£å™¨ã€‚å½“å…¶éå†æ¯ä¸€ä¸ªé¡¹æ—¶ï¼Œå®ƒå°†æ¯ä¸€ä¸ªé¡¹åŠ æ€»åˆ°ä¸€ä¸ªæ€»å’Œå¹¶åœ¨è¿­ä»£å®Œæˆæ—¶è¿”å›æ€»å’Œã€‚

```rust

#![allow(unused_variables)]
fn main() {
#[test]
fn iterator_sum() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);
}
}
```

è°ƒç”¨ sum ä¹‹åä¸å†å…è®¸ä½¿ç”¨ v1_iter å› ä¸ºè°ƒç”¨ sum æ—¶å®ƒä¼šè·å–è¿­ä»£å™¨çš„æ‰€æœ‰æƒã€‚

#### äº§ç”Ÿå…¶ä»–è¿­ä»£å™¨çš„æ–¹æ³•

Iterator trait ä¸­å®šä¹‰äº†å¦ä¸€ç±»æ–¹æ³•ï¼Œè¢«ç§°ä¸º è¿­ä»£å™¨é€‚é…å™¨ï¼ˆiterator adaptorsï¼‰ï¼Œä»–ä»¬å…è®¸å°†å½“å‰è¿­ä»£å™¨å˜ä¸ºä¸åŒç±»å‹çš„è¿­ä»£å™¨ã€‚å¯ä»¥é“¾å¼è°ƒç”¨å¤šä¸ªè¿­ä»£å™¨é€‚é…å™¨ã€‚ä¸è¿‡å› ä¸ºæ‰€æœ‰çš„è¿­ä»£å™¨éƒ½æ˜¯æƒ°æ€§çš„ï¼Œå¿…é¡»è°ƒç”¨ä¸€ä¸ªæ¶ˆè´¹é€‚é…å™¨æ–¹æ³•ä»¥ä¾¿è·å–è¿­ä»£å™¨é€‚é…å™¨è°ƒç”¨çš„ç»“æœã€‚

ä¸‹ä¾‹ å±•ç¤ºäº†ä¸€ä¸ªè°ƒç”¨è¿­ä»£å™¨é€‚é…å™¨æ–¹æ³• map çš„ä¾‹å­ï¼Œè¯¥ map æ–¹æ³•ä½¿ç”¨é—­åŒ…æ¥è°ƒç”¨æ¯ä¸ªå…ƒç´ ä»¥ç”Ÿæˆæ–°çš„è¿­ä»£å™¨ã€‚ è¿™é‡Œçš„é—­åŒ…åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„è¿­ä»£å™¨ï¼Œå¯¹å…¶ä¸­ vector ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½è¢«åŠ  1ã€‚ä¸è¿‡è¿™äº›ä»£ç ä¼šäº§ç”Ÿä¸€ä¸ªè­¦å‘Šï¼š

```rust

#![allow(unused_variables)]
fn main() {
let v1: Vec<i32> = vec![1, 2, 3];

v1.iter().map(|x| x + 1);
}
```

å¾—åˆ°çš„è­¦å‘Šæ˜¯ï¼š

```rust
warning: unused `std::iter::Map` which must be used: iterator adaptors are lazy
and do nothing unless consumed
 --> src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: #[warn(unused_must_use)] on by default

```

åœ¨ ä¸‹ä¾‹ ä¸­ï¼Œå°†éå†ç”± map è°ƒç”¨ç”Ÿæˆçš„è¿­ä»£å™¨çš„ç»“æœæ”¶é›†åˆ°ä¸€ä¸ª vector ä¸­ï¼Œå®ƒå°†ä¼šå«æœ‰åŸå§‹ vector ä¸­æ¯ä¸ªå…ƒç´ åŠ  1 çš„ç»“æœï¼š

```rust

#![allow(unused_variables)]
fn main() {
let v1: Vec<i32> = vec![1, 2, 3];

let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
}
```

å› ä¸º map è·å–ä¸€ä¸ªé—­åŒ…ï¼Œå¯ä»¥æŒ‡å®šä»»ä½•å¸Œæœ›åœ¨éå†çš„æ¯ä¸ªå…ƒç´ ä¸Šæ‰§è¡Œçš„æ“ä½œã€‚è¿™æ˜¯ä¸€ä¸ªå±•ç¤ºå¦‚ä½•ä½¿ç”¨é—­åŒ…æ¥è‡ªå®šä¹‰è¡Œä¸ºåŒæ—¶åˆå¤ç”¨ Iterator trait æä¾›çš„è¿­ä»£è¡Œä¸ºçš„ç»ä½³ä¾‹å­ã€‚

#### ä½¿ç”¨é—­åŒ…è·å–ç¯å¢ƒ

ç°åœ¨ä»‹ç»äº†è¿­ä»£å™¨ï¼Œè®©å±•ç¤ºä¸€ä¸ªé€šè¿‡ä½¿ç”¨ filter è¿­ä»£å™¨é€‚é…å™¨å’Œæ•è·ç¯å¢ƒçš„é—­åŒ…çš„å¸¸è§„ç”¨ä¾‹ã€‚è¿­ä»£å™¨çš„ filter æ–¹æ³•è·å–ä¸€ä¸ªä½¿ç”¨è¿­ä»£å™¨çš„æ¯ä¸€ä¸ªé¡¹å¹¶è¿”å›å¸ƒå°”å€¼çš„é—­åŒ…ã€‚å¦‚æœé—­åŒ…è¿”å› trueï¼Œå…¶å€¼å°†ä¼šåŒ…å«åœ¨ filter æä¾›çš„æ–°è¿­ä»£å™¨ä¸­ã€‚å¦‚æœé—­åŒ…è¿”å› falseï¼Œå…¶å€¼ä¸ä¼šåŒ…å«åœ¨ç»“æœè¿­ä»£å™¨ä¸­ã€‚

```rust

#![allow(unused_variables)]
fn main() {
#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_my_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    shoes.into_iter()
        .filter(|s| s.size == shoe_size)
        .collect()
}

#[test]
fn filters_by_size() {
    let shoes = vec![
        Shoe { size: 10, style: String::from("sneaker") },
        Shoe { size: 13, style: String::from("sandal") },
        Shoe { size: 10, style: String::from("boot") },
    ];

    let in_my_size = shoes_in_my_size(shoes, 10);

    assert_eq!(
        in_my_size,
        vec![
            Shoe { size: 10, style: String::from("sneaker") },
            Shoe { size: 10, style: String::from("boot") },
        ]
    );
}
}
```

shoes_in_my_size å‡½æ•°è·å–ä¸€ä¸ªé‹å­ vector çš„æ‰€æœ‰æƒå’Œä¸€ä¸ªé‹å­å¤§å°ä½œä¸ºå‚æ•°ã€‚å®ƒè¿”å›ä¸€ä¸ªåªåŒ…å«æŒ‡å®šå¤§å°é‹å­çš„ vectorã€‚

shoes_in_my_size å‡½æ•°ä½“ä¸­è°ƒç”¨äº† into_iter æ¥åˆ›å»ºä¸€ä¸ªè·å– vector æ‰€æœ‰æƒçš„è¿­ä»£å™¨ã€‚æ¥ç€è°ƒç”¨ filter å°†è¿™ä¸ªè¿­ä»£å™¨é€‚é…æˆä¸€ä¸ªåªå«æœ‰é‚£äº›é—­åŒ…è¿”å› true çš„å…ƒç´ çš„æ–°è¿­ä»£å™¨ã€‚

é—­åŒ…ä»ç¯å¢ƒä¸­æ•è·äº† shoe_size å˜é‡å¹¶ä½¿ç”¨å…¶å€¼ä¸æ¯ä¸€åªé‹çš„å¤§å°ä½œæ¯”è¾ƒï¼Œåªä¿ç•™æŒ‡å®šå¤§å°çš„é‹å­ã€‚æœ€ç»ˆï¼Œè°ƒç”¨ collect å°†è¿­ä»£å™¨é€‚é…å™¨è¿”å›çš„å€¼æ”¶é›†è¿›ä¸€ä¸ª vector å¹¶è¿”å›ã€‚

#### å®ç° Iterator trait æ¥åˆ›å»ºè‡ªå®šä¹‰è¿­ä»£å™¨

å·²ç»å±•ç¤ºäº†å¯ä»¥é€šè¿‡åœ¨ vector ä¸Šè°ƒç”¨ iterã€into_iter æˆ– iter_mut æ¥åˆ›å»ºä¸€ä¸ªè¿­ä»£å™¨ã€‚ä¹Ÿå¯ä»¥ç”¨æ ‡å‡†åº“ä¸­å…¶ä»–çš„é›†åˆç±»å‹åˆ›å»ºè¿­ä»£å™¨ï¼Œæ¯”å¦‚å“ˆå¸Œ mapã€‚å¦å¤–ï¼Œå¯ä»¥å®ç° Iterator trait æ¥åˆ›å»ºä»»ä½•å¸Œæœ›çš„è¿­ä»£å™¨ã€‚æ­£å¦‚ä¹‹å‰æåˆ°çš„ï¼Œå®šä¹‰ä¸­å”¯ä¸€è¦æ±‚æä¾›çš„æ–¹æ³•å°±æ˜¯ next æ–¹æ³•ã€‚ä¸€æ—¦å®šä¹‰äº†å®ƒï¼Œå°±å¯ä»¥ä½¿ç”¨æ‰€æœ‰å…¶ä»–ç”± Iterator trait æä¾›çš„æ‹¥æœ‰é»˜è®¤å®ç°çš„æ–¹æ³•æ¥åˆ›å»ºè‡ªå®šä¹‰è¿­ä»£å™¨äº†ï¼

ä½œä¸ºå±•ç¤ºï¼Œè®©åˆ›å»ºä¸€ä¸ªåªä¼šä» 1 æ•°åˆ° 5 çš„è¿­ä»£å™¨ã€‚é¦–å…ˆï¼Œåˆ›å»ºä¸€ä¸ªç»“æ„ä½“æ¥å­˜æ”¾ä¸€äº›å€¼ï¼Œæ¥ç€å®ç° Iterator trait å°†è¿™ä¸ªç»“æ„ä½“æ”¾å…¥è¿­ä»£å™¨ä¸­å¹¶åœ¨æ­¤å®ç°ä¸­ä½¿ç”¨å…¶å€¼ã€‚

```rust

#![allow(unused_variables)]
fn main() {
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -> Counter {
        Counter { count: 0 }
    }
}
}
```

Counter ç»“æ„ä½“æœ‰ä¸€ä¸ªå­—æ®µ countã€‚è¿™ä¸ªå­—æ®µå­˜æ”¾ä¸€ä¸ª u32 å€¼ï¼Œå®ƒä¼šè®°å½•å¤„ç† 1 åˆ° 5 çš„è¿­ä»£è¿‡ç¨‹ä¸­çš„ä½ç½®ã€‚count æ˜¯ç§æœ‰çš„å› ä¸ºå¸Œæœ› Counter çš„å®ç°æ¥ç®¡ç†è¿™ä¸ªå€¼ã€‚new å‡½æ•°é€šè¿‡æ€»æ˜¯ä»ä¸º 0 çš„ count å­—æ®µå¼€å§‹æ–°å®ä¾‹æ¥ç¡®ä¿éœ€è¦çš„è¡Œä¸ºã€‚

æ¥ä¸‹æ¥å°†ä¸º Counter ç±»å‹å®ç° Iterator traitï¼Œé€šè¿‡å®šä¹‰ next æ–¹æ³•æ¥æŒ‡å®šä½¿ç”¨è¿­ä»£å™¨æ—¶çš„è¡Œä¸ºï¼Œå¦‚ ä¸‹ä¾‹ æ‰€ç¤ºï¼š

```rust

#![allow(unused_variables)]
fn main() {
struct Counter {
    count: u32,
}

impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        self.count += 1;

        if self.count < 6 {
            Some(self.count)
        } else {
            None
        }
    }
}
}
```

è¿™é‡Œå°†è¿­ä»£å™¨çš„å…³è”ç±»å‹ Item è®¾ç½®ä¸º u32ï¼Œæ„å‘³ç€è¿­ä»£å™¨ä¼šè¿”å› u32 å€¼é›†åˆã€‚å†ä¸€æ¬¡ï¼Œè¿™é‡Œä»æ— éœ€æ‹…å¿ƒå…³è”ç±»å‹ï¼Œç¬¬åä¹ç« ä¼šè®²åˆ°ã€‚

å¸Œæœ›è¿­ä»£å™¨å¯¹å…¶å†…éƒ¨çŠ¶æ€åŠ ä¸€ï¼Œè¿™ä¹Ÿå°±æ˜¯ä¸ºä½•å°† count åˆå§‹åŒ–ä¸º 0ï¼šå¸Œæœ›è¿­ä»£å™¨é¦–å…ˆè¿”å› 1ã€‚å¦‚æœ count å€¼å°äº 6ï¼Œnext ä¼šè¿”å›å°è£…åœ¨ Some ä¸­çš„å½“å‰å€¼ï¼Œä¸è¿‡å¦‚æœ count å¤§äºæˆ–ç­‰äº 6ï¼Œè¿­ä»£å™¨ä¼šè¿”å› Noneã€‚

#### ä½¿ç”¨ Counter è¿­ä»£å™¨çš„ next æ–¹æ³•

ä¸€æ—¦å®ç°äº† Iterator traitï¼Œå°±æœ‰äº†ä¸€ä¸ªè¿­ä»£å™¨ï¼ä¸‹ä¾‹ å±•ç¤ºäº†ä¸€ä¸ªæµ‹è¯•ç”¨æ¥æ¼”ç¤ºä½¿ç”¨ Counter ç»“æ„ä½“çš„è¿­ä»£å™¨åŠŸèƒ½ï¼Œé€šè¿‡ç›´æ¥è°ƒç”¨ next æ–¹æ³•ï¼Œ

```rust

#![allow(unused_variables)]
fn main() {
struct Counter {
    count: u32,
}

impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        self.count += 1;

        if self.count < 6 {
            Some(self.count)
        } else {
            None
        }
    }
}

#[test]
fn calling_next_directly() {
    let mut counter = Counter::new();

    assert_eq!(counter.next(), Some(1));
    assert_eq!(counter.next(), Some(2));
    assert_eq!(counter.next(), Some(3));
    assert_eq!(counter.next(), Some(4));
    assert_eq!(counter.next(), Some(5));
    assert_eq!(counter.next(), None);
}
}
```

è¿™ä¸ªæµ‹è¯•åœ¨ counter å˜é‡ä¸­æ–°å»ºäº†ä¸€ä¸ª Counter å®ä¾‹å¹¶æ¥ç€åå¤è°ƒç”¨ next æ–¹æ³•ï¼Œæ¥éªŒè¯å®ç°çš„è¡Œä¸ºç¬¦åˆè¿™ä¸ªè¿­ä»£å™¨è¿”å›ä» 1 åˆ° 5 çš„å€¼çš„é¢„æœŸã€‚

#### ä½¿ç”¨è‡ªå®šä¹‰è¿­ä»£å™¨ä¸­å…¶ä»– Iterator trait æ–¹æ³•

é€šè¿‡å®šä¹‰ next æ–¹æ³•å®ç° Iterator traitï¼Œç°åœ¨å°±å¯ä»¥ä½¿ç”¨ä»»ä½•æ ‡å‡†åº“å®šä¹‰çš„æ‹¥æœ‰é»˜è®¤å®ç°çš„ Iterator trait æ–¹æ³•äº†ï¼Œå› ä¸ºä»–ä»¬éƒ½ä½¿ç”¨äº† next æ–¹æ³•çš„åŠŸèƒ½ã€‚

```rust

#![allow(unused_variables)]
fn main() {
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -> Counter {
        Counter { count: 0 }
    }
}

impl Iterator for Counter {
    // è¿­ä»£å™¨ä¼šäº§ç”Ÿ u32s
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        // count è‡ªå¢ 1ã€‚ä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆä» 0 å¼€å§‹ã€‚
        self.count += 1;

        // æ£€æµ‹æ˜¯å¦ç»“æŸç»“æŸè®¡æ•°ã€‚
        if self.count < 6 {
            Some(self.count)
        } else {
            None
        }
    }
}

#[test]
fn using_other_iterator_trait_methods() {
    let sum: u32 = Counter::new().zip(Counter::new().skip(1))
                                 .map(|(a, b)| a * b)
                                 .filter(|x| x % 3 == 0)
                                 .sum();
    assert_eq!(18, sum);
}
}
```

æ³¨æ„ zip åªäº§ç”Ÿå››å¯¹å€¼ï¼›ç†è®ºä¸Šç¬¬äº”å¯¹å€¼ (5, None) ä»æœªè¢«äº§ç”Ÿï¼Œå› ä¸º zip åœ¨ä»»ä¸€è¾“å…¥è¿­ä»£å™¨è¿”å› None æ—¶ä¹Ÿè¿”å› Noneã€‚

æ‰€æœ‰è¿™äº›æ–¹æ³•è°ƒç”¨éƒ½æ˜¯å¯èƒ½çš„ï¼Œå› ä¸ºæŒ‡å®šäº† next æ–¹æ³•å¦‚ä½•å·¥ä½œï¼Œè€Œæ ‡å‡†åº“åˆ™æä¾›äº†å…¶å®ƒè°ƒç”¨ next çš„æ–¹æ³•çš„é»˜è®¤å®ç°ã€‚

#### æ”¹è¿› I/O é¡¹ç›®

å¢åŠ äº†ä¸€äº›ä»£ç è·å–ä¸€ä¸ª String slice å¹¶åˆ›å»ºä¸€ä¸ª Config ç»“æ„ä½“çš„å®ä¾‹ï¼Œä»–ä»¬ç´¢å¼• slice ä¸­çš„å€¼å¹¶å…‹éš†è¿™äº›å€¼ä»¥ä¾¿ Config ç»“æ„ä½“å¯ä»¥æ‹¥æœ‰è¿™äº›å€¼ã€‚

```rust
impl Config {
    pub fn new(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var("CASE_INSENSITIVE").is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}

```

èµ·åˆè¿™é‡Œéœ€è¦ clone çš„åŸå› æ˜¯å‚æ•° args ä¸­æœ‰ä¸€ä¸ª String å…ƒç´ çš„ sliceï¼Œè€Œ new å‡½æ•°å¹¶ä¸æ‹¥æœ‰ argsã€‚ä¸ºäº†èƒ½å¤Ÿè¿”å› Config å®ä¾‹çš„æ‰€æœ‰æƒï¼Œéœ€è¦å…‹éš† Config ä¸­å­—æ®µ query å’Œ filename çš„å€¼ï¼Œè¿™æ · Config å®ä¾‹å°±èƒ½æ‹¥æœ‰è¿™äº›å€¼ã€‚

åœ¨å­¦ä¹ äº†è¿­ä»£å™¨ä¹‹åï¼Œå¯ä»¥å°† new å‡½æ•°æ”¹ä¸ºè·å–ä¸€ä¸ªæœ‰æ‰€æœ‰æƒçš„è¿­ä»£å™¨ä½œä¸ºå‚æ•°è€Œä¸æ˜¯å€Ÿç”¨ sliceã€‚å°†ä½¿ç”¨è¿­ä»£å™¨åŠŸèƒ½ä¹‹å‰æ£€æŸ¥ slice é•¿åº¦å’Œç´¢å¼•ç‰¹å®šä½ç½®çš„ä»£ç ã€‚è¿™ä¼šæ˜ç¡® Config::new çš„å·¥ä½œå› ä¸ºè¿­ä»£å™¨ä¼šè´Ÿè´£è®¿é—®è¿™äº›å€¼ã€‚

ä¸€æ—¦ Config::new è·å–äº†è¿­ä»£å™¨çš„æ‰€æœ‰æƒå¹¶ä¸å†ä½¿ç”¨å€Ÿç”¨çš„ç´¢å¼•æ“ä½œï¼Œå°±å¯ä»¥å°†è¿­ä»£å™¨ä¸­çš„ String å€¼ç§»åŠ¨åˆ° Config ä¸­ï¼Œè€Œä¸æ˜¯è°ƒç”¨ clone åˆ†é…æ–°çš„ç©ºé—´ã€‚

#### ç›´æ¥ä½¿ç”¨ env::args è¿”å›çš„è¿­ä»£å™¨

```rust
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {}", err);
        process::exit(1);
    });

    // --snip--
}

```

```rust
fn main() {
    let config = Config::new(env::args()).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {}", err);
        process::exit(1);
    });

    // --snip--
}

```

env::args å‡½æ•°è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ä¸åŒäºå°†è¿­ä»£å™¨çš„å€¼æ”¶é›†åˆ°ä¸€ä¸ª vector ä¸­æ¥ç€ä¼ é€’ä¸€ä¸ª slice ç»™ Config::newï¼Œç°åœ¨ç›´æ¥å°† env::args è¿”å›çš„è¿­ä»£å™¨çš„æ‰€æœ‰æƒä¼ é€’ç»™ Config::newã€‚

æ¥ä¸‹æ¥éœ€è¦æ›´æ–° Config::new çš„å®šä¹‰ã€‚åœ¨ I/O é¡¹ç›®çš„ src/lib.rs ä¸­ï¼Œå°† Config::new çš„ç­¾åæ”¹ä¸ºå¦‚ ä¸‹ä¾‹ æ‰€ç¤ºã€‚è¿™ä»ç„¶ä¸èƒ½ç¼–è¯‘å› ä¸ºè¿˜éœ€æ›´æ–°å‡½æ•°ä½“ï¼š

```rust
fn main() {}
use std::env;

struct Config {
    query: String,
    filename: String,
    case_sensitive: bool,
}

impl Config {
    pub fn new(mut args: std::env::Args) -> Result<Config, &'static str> {
        args.next();

        let query = match args.next() {
            Some(arg) => arg,
            None => return Err("Didn't get a query string"),
        };

        let filename = match args.next() {
            Some(arg) => arg,
            None => return Err("Didn't get a file name"),
        };

        let case_sensitive = env::var("CASE_INSENSITIVE").is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}

```

è¯·è®°ä½ env::args è¿”å›å€¼çš„ç¬¬ä¸€ä¸ªå€¼æ˜¯ç¨‹åºçš„åç§°ã€‚å¸Œæœ›å¿½ç•¥å®ƒå¹¶è·å–ä¸‹ä¸€ä¸ªå€¼ï¼Œæ‰€ä»¥é¦–å…ˆè°ƒç”¨ next å¹¶ä¸å¯¹è¿”å›å€¼åšä»»ä½•æ“ä½œã€‚ä¹‹åå¯¹å¸Œæœ›æ”¾å…¥ Config ä¸­å­—æ®µ query è°ƒç”¨ nextã€‚å¦‚æœ next è¿”å› Someï¼Œä½¿ç”¨ match æ¥æå–å…¶å€¼ã€‚å¦‚æœå®ƒè¿”å› Noneï¼Œåˆ™æ„å‘³ç€æ²¡æœ‰æä¾›è¶³å¤Ÿçš„å‚æ•°å¹¶é€šè¿‡ Err å€¼ææ—©è¿”å›ã€‚å¯¹ filename å€¼è¿›è¡ŒåŒæ ·çš„æ“ä½œã€‚

#### ä½¿ç”¨è¿­ä»£å™¨é€‚é…å™¨æ¥ä½¿ä»£ç æ›´ç®€æ˜

```rust
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}

```

å¯ä»¥é€šè¿‡ä½¿ç”¨è¿­ä»£å™¨é€‚é…å™¨æ–¹æ³•æ¥ç¼–å†™æ›´ç®€æ˜çš„ä»£ç ã€‚è¿™ä¹Ÿé¿å…äº†ä¸€ä¸ªå¯å˜çš„ä¸­é—´ results vector çš„ä½¿ç”¨ã€‚å‡½æ•°å¼ç¼–ç¨‹é£æ ¼å€¾å‘äºæœ€å°åŒ–å¯å˜çŠ¶æ€çš„æ•°é‡æ¥ä½¿ä»£ç æ›´ç®€æ´ã€‚å»æ‰å¯å˜çŠ¶æ€å¯èƒ½ä¼šä½¿å¾—å°†æ¥è¿›è¡Œå¹¶è¡Œæœç´¢çš„å¢å¼ºå˜å¾—æ›´å®¹æ˜“ï¼Œå› ä¸ºä¸å¿…ç®¡ç† results vector çš„å¹¶å‘è®¿é—®ã€‚

```rust
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    contents.lines()
        .filter(|line| line.contains(query))
        .collect()
}

```

#### æ€§èƒ½å¯¹æ¯”ï¼šå¾ªç¯ VS è¿­ä»£å™¨

ä¸ºäº†å†³å®šä½¿ç”¨å“ªä¸ªå®ç°ï¼Œéœ€è¦çŸ¥é“å“ªä¸ªç‰ˆæœ¬çš„ search å‡½æ•°æ›´å¿«ä¸€äº›ï¼šæ˜¯ç›´æ¥ä½¿ç”¨ for å¾ªç¯çš„ç‰ˆæœ¬è¿˜æ˜¯ä½¿ç”¨è¿­ä»£å™¨çš„ç‰ˆæœ¬ã€‚

è¿è¡Œäº†ä¸€ä¸ªæ€§èƒ½æµ‹è¯•ï¼Œé€šè¿‡å°†é˜¿ç‘ŸÂ·æŸ¯å—Â·é“å°”çš„â€œç¦å°”æ‘©æ–¯æ¢æ¡ˆé›†â€çš„å…¨éƒ¨å†…å®¹åŠ è½½è¿› String å¹¶å¯»æ‰¾å…¶ä¸­çš„å•è¯ â€œtheâ€ã€‚å¦‚ä¸‹æ˜¯ for å¾ªç¯ç‰ˆæœ¬å’Œè¿­ä»£å™¨ç‰ˆæœ¬çš„ search å‡½æ•°çš„æ€§èƒ½æµ‹è¯•ç»“æœï¼š

ç»“æœè¿­ä»£å™¨ç‰ˆæœ¬è¿˜è¦ç¨å¾®å¿«ä¸€ç‚¹ï¼è¿™é‡Œå°†ä¸ä¼šæŸ¥çœ‹æ€§èƒ½æµ‹è¯•çš„ä»£ç ï¼Œçš„ç›®çš„å¹¶ä¸æ˜¯ä¸ºäº†è¯æ˜ä»–ä»¬æ˜¯å®Œå…¨ç­‰åŒçš„ï¼Œè€Œæ˜¯å¾—å‡ºä¸€ä¸ªæ€æ ·æ¯”è¾ƒè¿™ä¸¤ç§å®ç°æ–¹å¼æ€§èƒ½çš„åŸºæœ¬æ€è·¯ã€‚

å¯¹äºä¸€ä¸ªæ›´å…¨é¢çš„æ€§èƒ½æµ‹è¯•ï¼Œå°†ä¼šæ£€æŸ¥ä¸åŒé•¿åº¦çš„æ–‡æœ¬ã€ä¸åŒçš„æœç´¢å•è¯ã€ä¸åŒé•¿åº¦çš„å•è¯å’Œæ‰€æœ‰å…¶ä»–çš„å¯å˜æƒ…å†µã€‚è¿™é‡Œæ‰€è¦è¡¨è¾¾çš„æ˜¯ï¼šè¿­ä»£å™¨ï¼Œä½œä¸ºä¸€ä¸ªé«˜çº§çš„æŠ½è±¡ï¼Œè¢«ç¼–è¯‘æˆäº†ä¸æ‰‹å†™çš„åº•å±‚ä»£ç å¤§ä½“ä¸€è‡´æ€§èƒ½ä»£ç ã€‚è¿­ä»£å™¨æ˜¯ Rust çš„ é›¶æˆæœ¬æŠ½è±¡ï¼ˆzero-cost abstractionsï¼‰ä¹‹ä¸€ï¼Œå®ƒæ„å‘³ç€æŠ½è±¡å¹¶ä¸ä¼šå¼•å…¥è¿è¡Œæ—¶å¼€é”€ï¼Œå®ƒä¸æœ¬è´¾å°¼Â·æ–¯ç‰¹åŠ³æ–¯ç‰¹å¢æ™®ï¼ˆC++ çš„è®¾è®¡å’Œå®ç°è€…ï¼‰åœ¨ â€œFoundations of C++â€ï¼ˆ2012ï¼‰ ä¸­æ‰€å®šä¹‰çš„ é›¶å¼€é”€ï¼ˆzero-overheadï¼‰å¦‚å‡ºä¸€è¾™ï¼š

ä½œä¸ºå¦ä¸€ä¸ªä¾‹å­ï¼Œè¿™é‡Œæœ‰ä¸€äº›å–è‡ªäºéŸ³é¢‘è§£ç å™¨çš„ä»£ç ã€‚è§£ç ç®—æ³•ä½¿ç”¨çº¿æ€§é¢„æµ‹æ•°å­¦è¿ç®—ï¼ˆlinear prediction mathematical operationï¼‰æ¥æ ¹æ®ä¹‹å‰æ ·æœ¬çš„çº¿æ€§å‡½æ•°é¢„æµ‹å°†æ¥çš„å€¼ã€‚è¿™äº›ä»£ç ä½¿ç”¨è¿­ä»£å™¨é“¾æ¥å¯¹ä½œç”¨åŸŸä¸­çš„ä¸‰ä¸ªå˜é‡è¿›è¡Œäº†æŸç§æ•°å­¦è®¡ç®—ï¼šä¸€ä¸ªå« buffer çš„æ•°æ® sliceã€ä¸€ä¸ªæœ‰ 12 ä¸ªå…ƒç´ çš„æ•°ç»„ coefficientsã€å’Œä¸€ä¸ªä»£è¡¨ä½ç§»ä½æ•°çš„ qlp_shiftã€‚ä¾‹å­ä¸­å£°æ˜äº†è¿™äº›å˜é‡ä½†å¹¶æ²¡æœ‰æä¾›ä»»ä½•å€¼ï¼›è™½ç„¶è¿™äº›ä»£ç åœ¨å…¶ä¸Šä¸‹æ–‡ä¹‹å¤–æ²¡æœ‰ä»€ä¹ˆæ„ä¹‰ï¼Œä¸è¿‡ä»æ˜¯ä¸€ä¸ªç®€æ˜çš„ç°å®ä¸­çš„ä¾‹å­ï¼Œæ¥å±•ç¤º Rust å¦‚ä½•å°†é«˜çº§æ¦‚å¿µè½¬æ¢ä¸ºåº•å±‚ä»£ç ï¼š

```rust
let buffer: &mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&buffer[i - 12..i])
                                 .map(|(&c, &s)| c * s as i64)
                                 .sum::<i64>() >> qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}

```

ä¸ºäº†è®¡ç®— prediction çš„å€¼ï¼Œè¿™äº›ä»£ç éå†äº† coefficients ä¸­çš„ 12 ä¸ªå€¼ï¼Œä½¿ç”¨ zip æ–¹æ³•å°†ç³»æ•°ä¸ buffer çš„å‰ 12 ä¸ªå€¼ç»„åˆåœ¨ä¸€èµ·ã€‚æ¥ç€å°†æ¯ä¸€å¯¹å€¼ç›¸ä¹˜ï¼Œå†å°†æ‰€æœ‰ç»“æœç›¸åŠ ï¼Œç„¶åå°†æ€»å’Œå³ç§» qlp_shift ä½ã€‚

åƒéŸ³é¢‘è§£ç å™¨è¿™æ ·çš„ç¨‹åºé€šå¸¸æœ€çœ‹é‡è®¡ç®—çš„æ€§èƒ½ã€‚è¿™é‡Œï¼Œåˆ›å»ºäº†ä¸€ä¸ªè¿­ä»£å™¨ï¼Œä½¿ç”¨äº†ä¸¤ä¸ªé€‚é…å™¨ï¼Œæ¥ç€æ¶ˆè´¹äº†å…¶å€¼ã€‚Rust ä»£ç å°†ä¼šè¢«ç¼–è¯‘ä¸ºä»€ä¹ˆæ ·çš„æ±‡ç¼–ä»£ç å‘¢ï¼Ÿå¥½å§ï¼Œåœ¨ç¼–å†™æœ¬ä¹¦çš„è¿™ä¸ªæ—¶å€™ï¼Œå®ƒè¢«ç¼–è¯‘æˆä¸æ‰‹å†™çš„ç›¸åŒçš„æ±‡ç¼–ä»£ç ã€‚éå† coefficients çš„å€¼å®Œå…¨ç”¨ä¸åˆ°å¾ªç¯ï¼šRust çŸ¥é“è¿™é‡Œä¼šè¿­ä»£ 12 æ¬¡ï¼Œæ‰€ä»¥å®ƒâ€œå±•å¼€â€ï¼ˆunrollï¼‰äº†å¾ªç¯ã€‚å±•å¼€æ˜¯ä¸€ç§ç§»é™¤å¾ªç¯æ§åˆ¶ä»£ç çš„å¼€é”€å¹¶æ›¿æ¢ä¸ºæ¯ä¸ªè¿­ä»£ä¸­çš„é‡å¤ä»£ç çš„ä¼˜åŒ–ã€‚

æ‰€æœ‰çš„ç³»æ•°éƒ½è¢«å‚¨å­˜åœ¨äº†å¯„å­˜å™¨ä¸­ï¼Œè¿™æ„å‘³ç€è®¿é—®ä»–ä»¬éå¸¸å¿«ã€‚è¿™é‡Œä¹Ÿæ²¡æœ‰è¿è¡Œæ—¶æ•°ç»„è®¿é—®è¾¹ç•Œæ£€æŸ¥ã€‚æ‰€æœ‰è¿™äº› Rust èƒ½å¤Ÿæä¾›çš„ä¼˜åŒ–ä½¿å¾—ç»“æœä»£ç æä¸ºé«˜æ•ˆã€‚ç°åœ¨çŸ¥é“è¿™äº›äº†ï¼Œè¯·æ”¾å¿ƒå¤§èƒ†çš„ä½¿ç”¨è¿­ä»£å™¨å’Œé—­åŒ…å§ï¼ä»–ä»¬ä½¿å¾—ä»£ç çœ‹èµ·æ¥æ›´é«˜çº§ï¼Œä½†å¹¶ä¸ä¸ºæ­¤å¼•å…¥è¿è¡Œæ—¶æ€§èƒ½æŸå¤±ã€‚

### åªèƒ½æŒ‡é’ˆ

æŒ‡é’ˆ ï¼ˆpointerï¼‰æ˜¯ä¸€ä¸ªåŒ…å«å†…å­˜åœ°å€çš„å˜é‡çš„é€šç”¨æ¦‚å¿µã€‚è¿™ä¸ªåœ°å€å¼•ç”¨ï¼Œæˆ– â€œæŒ‡å‘â€ï¼ˆpoints atï¼‰ä¸€äº›å…¶ä»–æ•°æ®ã€‚Rust ä¸­æœ€å¸¸è§çš„æŒ‡é’ˆæ˜¯ç¬¬å››ç« ä»‹ç»çš„ å¼•ç”¨ï¼ˆreferenceï¼‰ã€‚å¼•ç”¨ä»¥ & ç¬¦å·ä¸ºæ ‡å¿—å¹¶å€Ÿç”¨äº†ä»–ä»¬æ‰€æŒ‡å‘çš„å€¼ã€‚é™¤äº†å¼•ç”¨æ•°æ®æ²¡æœ‰ä»»ä½•å…¶ä»–ç‰¹æ®ŠåŠŸèƒ½ã€‚å®ƒä»¬ä¹Ÿæ²¡æœ‰ä»»ä½•é¢å¤–å¼€é”€ï¼Œæ‰€ä»¥åº”ç”¨çš„æœ€å¤šã€‚

å¦ä¸€æ–¹é¢ï¼Œæ™ºèƒ½æŒ‡é’ˆï¼ˆsmart pointersï¼‰æ˜¯ä¸€ç±»æ•°æ®ç»“æ„ï¼Œä»–ä»¬çš„è¡¨ç°ç±»ä¼¼æŒ‡é’ˆï¼Œä½†æ˜¯ä¹Ÿæ‹¥æœ‰é¢å¤–çš„å…ƒæ•°æ®å’ŒåŠŸèƒ½ã€‚æ™ºèƒ½æŒ‡é’ˆçš„æ¦‚å¿µå¹¶ä¸ä¸º Rust æ‰€ç‹¬æœ‰ï¼›å…¶èµ·æºäº C++ å¹¶å­˜åœ¨äºå…¶ä»–è¯­è¨€ä¸­ã€‚Rust æ ‡å‡†åº“ä¸­ä¸åŒçš„æ™ºèƒ½æŒ‡é’ˆæä¾›äº†å¤šäºå¼•ç”¨çš„é¢å¤–åŠŸèƒ½ã€‚æœ¬ç« å°†ä¼šæ¢ç´¢çš„ä¸€ä¸ªä¾‹å­ä¾¿æ˜¯ å¼•ç”¨è®¡æ•° ï¼ˆreference countingï¼‰æ™ºèƒ½æŒ‡é’ˆç±»å‹ï¼Œå…¶å…è®¸æ•°æ®æœ‰å¤šä¸ªæ‰€æœ‰è€…ã€‚å¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆè®°å½•æ€»å…±æœ‰å¤šå°‘ä¸ªæ‰€æœ‰è€…ï¼Œå¹¶å½“æ²¡æœ‰ä»»ä½•æ‰€æœ‰è€…æ—¶è´Ÿè´£æ¸…ç†æ•°æ®ã€‚

åœ¨ Rust ä¸­ï¼Œæ™®é€šå¼•ç”¨å’Œæ™ºèƒ½æŒ‡é’ˆçš„ä¸€ä¸ªé¢å¤–çš„åŒºåˆ«æ˜¯å¼•ç”¨æ˜¯ä¸€ç±»åªå€Ÿç”¨æ•°æ®çš„æŒ‡é’ˆï¼›ç›¸åï¼Œåœ¨å¤§éƒ¨åˆ†æƒ…å†µä¸‹ï¼Œæ™ºèƒ½æŒ‡é’ˆ æ‹¥æœ‰ ä»–ä»¬æŒ‡å‘çš„æ•°æ®ã€‚

å®é™…ä¸Šæœ¬ä¹¦ä¸­å·²ç»å‡ºç°è¿‡ä¸€äº›æ™ºèƒ½æŒ‡é’ˆï¼Œæ¯”å¦‚ç¬¬å…«ç« çš„ String å’Œ Vec<T>ï¼Œè™½ç„¶å½“æ—¶å¹¶ä¸è¿™ä¹ˆç§°å‘¼å®ƒä»¬ã€‚è¿™äº›ç±»å‹éƒ½å±äºæ™ºèƒ½æŒ‡é’ˆå› ä¸ºå®ƒä»¬æ‹¥æœ‰ä¸€äº›æ•°æ®å¹¶å…è®¸ä¿®æ”¹å®ƒä»¬ã€‚å®ƒä»¬ä¹Ÿå¸¦æœ‰å…ƒæ•°æ®ï¼ˆæ¯”å¦‚ä»–ä»¬çš„å®¹é‡ï¼‰å’Œé¢å¤–çš„åŠŸèƒ½æˆ–ä¿è¯ï¼ˆString çš„æ•°æ®æ€»æ˜¯æœ‰æ•ˆçš„ UTF-8 ç¼–ç ï¼‰ã€‚

æ™ºèƒ½æŒ‡é’ˆé€šå¸¸ä½¿ç”¨ç»“æ„ä½“å®ç°ã€‚æ™ºèƒ½æŒ‡é’ˆåŒºåˆ«äºå¸¸è§„ç»“æ„ä½“çš„æ˜¾è‘—ç‰¹æ€§åœ¨äºå…¶å®ç°äº† Deref å’Œ Drop traitã€‚Deref trait å…è®¸æ™ºèƒ½æŒ‡é’ˆç»“æ„ä½“å®ä¾‹è¡¨ç°çš„åƒå¼•ç”¨ä¸€æ ·ï¼Œè¿™æ ·å°±å¯ä»¥ç¼–å†™æ—¢ç”¨äºå¼•ç”¨ã€åˆç”¨äºæ™ºèƒ½æŒ‡é’ˆçš„ä»£ç ã€‚Drop trait å…è®¸è‡ªå®šä¹‰å½“æ™ºèƒ½æŒ‡é’ˆç¦»å¼€ä½œç”¨åŸŸæ—¶è¿è¡Œçš„ä»£ç ã€‚æœ¬ç« ä¼šè®¨è®ºè¿™äº› trait ä»¥åŠä¸ºä»€ä¹ˆå¯¹äºæ™ºèƒ½æŒ‡é’ˆæ¥è¯´ä»–ä»¬å¾ˆé‡è¦ã€‚

è€ƒè™‘åˆ°æ™ºèƒ½æŒ‡é’ˆæ˜¯ä¸€ä¸ªåœ¨ Rust ç»å¸¸è¢«ä½¿ç”¨çš„é€šç”¨è®¾è®¡æ¨¡å¼ï¼Œæœ¬ç« å¹¶ä¸ä¼šè¦†ç›–æ‰€æœ‰ç°å­˜çš„æ™ºèƒ½æŒ‡é’ˆã€‚å¾ˆå¤šåº“éƒ½æœ‰è‡ªå·±çš„æ™ºèƒ½æŒ‡é’ˆè€Œä¹Ÿå¯ä»¥ç¼–å†™å±äºè‡ªå·±çš„æ™ºèƒ½æŒ‡é’ˆã€‚è¿™é‡Œå°†ä¼šè®²åˆ°çš„æ˜¯æ¥è‡ªæ ‡å‡†åº“ä¸­æœ€å¸¸ç”¨çš„ä¸€äº›ï¼š

* `Box<T>`ï¼Œç”¨äºåœ¨å †ä¸Šåˆ†é…å€¼
* `Rc<T>`ï¼Œä¸€ä¸ªå¼•ç”¨è®¡æ•°ç±»å‹ï¼Œå…¶æ•°æ®å¯ä»¥æœ‰å¤šä¸ªæ‰€æœ‰è€…
* `Ref<T>` å’Œ `RefMut<T>`ï¼Œé€šè¿‡ `RefCell<T>` è®¿é—®ï¼Œä¸€ä¸ªåœ¨è¿è¡Œæ—¶è€Œä¸æ˜¯åœ¨ç¼–è¯‘æ—¶æ‰§è¡Œå€Ÿç”¨è§„åˆ™çš„ç±»å‹ã€‚

#### ä½¿ç”¨Box <T>æŒ‡å‘å †ä¸Šçš„æ•°æ®

æœ€ç®€å•ç›´æ¥çš„æ™ºèƒ½æŒ‡é’ˆæ˜¯ boxï¼Œå…¶ç±»å‹æ˜¯ `Box<T>`ã€‚ box å…è®¸å°†ä¸€ä¸ªå€¼æ”¾åœ¨å †ä¸Šè€Œä¸æ˜¯æ ˆä¸Šã€‚ç•™åœ¨æ ˆä¸Šçš„åˆ™æ˜¯æŒ‡å‘å †æ•°æ®çš„æŒ‡é’ˆã€‚å¦‚æœæƒ³å›é¡¾ä¸€ä¸‹æ ˆä¸å †çš„åŒºåˆ«è¯·å‚è€ƒç¬¬å››ç« ã€‚

é™¤äº†æ•°æ®è¢«å‚¨å­˜åœ¨å †ä¸Šè€Œä¸æ˜¯æ ˆä¸Šä¹‹å¤–ï¼Œbox æ²¡æœ‰æ€§èƒ½æŸå¤±ã€‚ä¸è¿‡ä¹Ÿæ²¡æœ‰å¾ˆå¤šé¢å¤–çš„åŠŸèƒ½ã€‚å®ƒä»¬å¤šç”¨äºå¦‚ä¸‹åœºæ™¯ï¼š

* å½“æœ‰ä¸€ä¸ªåœ¨ç¼–è¯‘æ—¶æœªçŸ¥å¤§å°çš„ç±»å‹ï¼Œè€Œåˆæƒ³è¦åœ¨éœ€è¦ç¡®åˆ‡å¤§å°çš„ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨è¿™ä¸ªç±»å‹å€¼çš„æ—¶å€™
* å½“æœ‰å¤§é‡æ•°æ®å¹¶å¸Œæœ›åœ¨ç¡®ä¿æ•°æ®ä¸è¢«æ‹·è´çš„æƒ…å†µä¸‹è½¬ç§»æ‰€æœ‰æƒçš„æ—¶å€™
* å½“å¸Œæœ›æ‹¥æœ‰ä¸€ä¸ªå€¼å¹¶åªå…³å¿ƒå®ƒçš„ç±»å‹æ˜¯å¦å®ç°äº†ç‰¹å®š trait è€Œä¸æ˜¯å…¶å…·ä½“ç±»å‹çš„æ—¶å€™

ä¸‹ä¾‹å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ box åœ¨å †ä¸Šå‚¨å­˜ä¸€ä¸ª i32ï¼š

```rust
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}

```

è¿™é‡Œå®šä¹‰äº†å˜é‡ bï¼Œå…¶å€¼æ˜¯ä¸€ä¸ªæŒ‡å‘è¢«åˆ†é…åœ¨å †ä¸Šçš„å€¼ 5 çš„ Boxã€‚è¿™ä¸ªç¨‹åºä¼šæ‰“å°å‡º b = 5ï¼›åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå¯ä»¥åƒæ•°æ®æ˜¯å‚¨å­˜åœ¨æ ˆä¸Šçš„é‚£æ ·è®¿é—® box ä¸­çš„æ•°æ®ã€‚æ­£å¦‚ä»»ä½•æ‹¥æœ‰æ•°æ®æ‰€æœ‰æƒçš„å€¼é‚£æ ·ï¼Œå½“åƒ b è¿™æ ·çš„ box åœ¨ main çš„æœ«å°¾ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå®ƒå°†è¢«é‡Šæ”¾ã€‚è¿™ä¸ªé‡Šæ”¾è¿‡ç¨‹ä½œç”¨äº box æœ¬èº«ï¼ˆä½äºæ ˆä¸Šï¼‰å’Œå®ƒæ‰€æŒ‡å‘çš„æ•°æ®ï¼ˆä½äºå †ä¸Šï¼‰ã€‚

å°†ä¸€ä¸ªå•ç‹¬çš„å€¼å­˜æ”¾åœ¨å †ä¸Šå¹¶ä¸æ˜¯å¾ˆæœ‰æ„ä¹‰ï¼Œæ‰€ä»¥åƒç¤ºä¾‹ 15-1 è¿™æ ·å•ç‹¬ä½¿ç”¨ box å¹¶ä¸å¸¸è§ã€‚å°†åƒå•ä¸ª i32 è¿™æ ·çš„å€¼å‚¨å­˜åœ¨æ ˆä¸Šï¼Œä¹Ÿå°±æ˜¯å…¶é»˜è®¤å­˜æ”¾çš„åœ°æ–¹åœ¨å¤§éƒ¨åˆ†ä½¿ç”¨åœºæ™¯ä¸­æ›´ä¸ºåˆé€‚ã€‚è®©çœ‹çœ‹ä¸€ä¸ªä¸ä½¿ç”¨ box æ—¶æ— æ³•å®šä¹‰çš„ç±»å‹çš„ä¾‹å­ã€‚

#### Box å…è®¸åˆ›å»ºé€’å½’ç±»å‹

Rust éœ€è¦åœ¨ç¼–è¯‘æ—¶çŸ¥é“ç±»å‹å ç”¨å¤šå°‘ç©ºé—´ã€‚ä¸€ç§æ— æ³•åœ¨ç¼–è¯‘æ—¶çŸ¥é“å¤§å°çš„ç±»å‹æ˜¯ é€’å½’ç±»å‹ï¼ˆrecursive typeï¼‰ï¼Œå…¶å€¼çš„ä¸€éƒ¨åˆ†å¯ä»¥æ˜¯ç›¸åŒç±»å‹çš„å¦ä¸€ä¸ªå€¼ã€‚è¿™ç§å€¼çš„åµŒå¥—ç†è®ºä¸Šå¯ä»¥æ— é™çš„è¿›è¡Œä¸‹å»ï¼Œæ‰€ä»¥ Rust ä¸çŸ¥é“é€’å½’ç±»å‹éœ€è¦å¤šå°‘ç©ºé—´ã€‚ä¸è¿‡ box æœ‰ä¸€ä¸ªå·²çŸ¥çš„å¤§å°ï¼Œæ‰€ä»¥é€šè¿‡åœ¨å¾ªç¯ç±»å‹å®šä¹‰ä¸­æ’å…¥ boxï¼Œå°±å¯ä»¥åˆ›å»ºé€’å½’ç±»å‹äº†ã€‚

##### cons list çš„æ›´å¤šå†…å®¹

cons list æ˜¯ä¸€ä¸ªæ¥æºäº Lisp ç¼–ç¨‹è¯­è¨€åŠå…¶æ–¹è¨€çš„æ•°æ®ç»“æ„ã€‚åœ¨ Lisp ä¸­ï¼Œcons å‡½æ•°ï¼ˆâ€œconstruct function" çš„ç¼©å†™ï¼‰åˆ©ç”¨ä¸¤ä¸ªå‚æ•°æ¥æ„é€ ä¸€ä¸ªæ–°çš„åˆ—è¡¨ï¼Œä»–ä»¬é€šå¸¸æ˜¯ä¸€ä¸ªå•ç‹¬çš„å€¼å’Œå¦ä¸€ä¸ªåˆ—è¡¨ã€‚

cons å‡½æ•°çš„æ¦‚å¿µæ¶‰åŠåˆ°æ›´å¸¸è§çš„å‡½æ•°å¼ç¼–ç¨‹æœ¯è¯­ï¼›â€œå°† x ä¸ y è¿æ¥â€ é€šå¸¸æ„å‘³ç€æ„å»ºä¸€ä¸ªæ–°çš„å®¹å™¨è€Œå°† x çš„å…ƒç´ æ”¾åœ¨æ–°å®¹å™¨çš„å¼€å¤´ï¼Œå…¶ååˆ™æ˜¯å®¹å™¨ y çš„å…ƒç´ ã€‚

cons list çš„æ¯ä¸€é¡¹éƒ½åŒ…å«ä¸¤ä¸ªå…ƒç´ ï¼šå½“å‰é¡¹çš„å€¼å’Œä¸‹ä¸€é¡¹ã€‚å…¶æœ€åä¸€é¡¹å€¼åŒ…å«ä¸€ä¸ªå«åš Nil çš„å€¼ä¸”æ²¡æœ‰ä¸‹ä¸€é¡¹ã€‚cons list é€šè¿‡é€’å½’è°ƒç”¨ cons å‡½æ•°äº§ç”Ÿã€‚ä»£è¡¨é€’å½’çš„ç»ˆæ­¢æ¡ä»¶ï¼ˆbase caseï¼‰çš„è§„èŒƒåç§°æ˜¯ Nilï¼Œå®ƒå®£å¸ƒåˆ—è¡¨çš„ç»ˆæ­¢ã€‚æ³¨æ„è¿™ä¸åŒäºç¬¬å…­ç« ä¸­çš„ â€œnullâ€ æˆ– â€œnilâ€ çš„æ¦‚å¿µï¼Œä»–ä»¬ä»£è¡¨æ— æ•ˆæˆ–ç¼ºå¤±çš„å€¼ã€‚ 

æ³¨æ„è™½ç„¶å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ç»å¸¸ä½¿ç”¨ cons listï¼Œä½†æ˜¯å®ƒå¹¶ä¸æ˜¯ä¸€ä¸ª Rust ä¸­å¸¸è§çš„ç±»å‹ã€‚å¤§éƒ¨åˆ†åœ¨ Rust ä¸­éœ€è¦åˆ—è¡¨çš„æ—¶å€™ï¼Œ`Vec<T>` æ˜¯ä¸€ä¸ªæ›´å¥½çš„é€‰æ‹©ã€‚å…¶ä»–æ›´ä¸ºå¤æ‚çš„é€’å½’æ•°æ®ç±»å‹ ç¡®å® åœ¨ Rust çš„å¾ˆå¤šåœºæ™¯ä¸­å¾ˆæœ‰ç”¨ï¼Œä¸è¿‡é€šè¿‡ä»¥ cons list ä½œä¸ºå¼€å§‹ï¼Œå¯ä»¥æ¢ç´¢å¦‚ä½•ä½¿ç”¨ box æ¯«ä¸è´¹åŠ›çš„å®šä¹‰ä¸€ä¸ªé€’å½’æ•°æ®ç±»å‹ã€‚

ä¸‹ä¾‹ åŒ…å«ä¸€ä¸ª cons list çš„æšä¸¾å®šä¹‰ã€‚æ³¨æ„è¿™è¿˜ä¸èƒ½ç¼–è¯‘å› ä¸ºè¿™ä¸ªç±»å‹æ²¡æœ‰å·²çŸ¥çš„å¤§å°ï¼š

```rust
enum List {
    Cons(i32, List),
    Nil,
}

```

ä½¿ç”¨è¿™ä¸ª cons list æ¥å‚¨å­˜åˆ—è¡¨ 1, 2, 3 å°†çœ‹èµ·æ¥å¦‚ä¸‹ä¾‹æ‰€ç¤ºï¼š

```rust
use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}

```

ç¬¬ä¸€ä¸ª Cons å‚¨å­˜äº† 1 å’Œå¦ä¸€ä¸ª List å€¼ã€‚è¿™ä¸ª List æ˜¯å¦ä¸€ä¸ªåŒ…å« 2 çš„ Cons å€¼å’Œä¸‹ä¸€ä¸ª List å€¼ã€‚æ¥ç€åˆæœ‰å¦ä¸€ä¸ªå­˜æ”¾äº† 3 çš„ Cons å€¼å’Œæœ€åä¸€ä¸ªå€¼ä¸º Nil çš„ Listï¼Œéé€’å½’æˆå‘˜ä»£è¡¨äº†åˆ—è¡¨çš„ç»“å°¾ã€‚

å¦‚æœå°è¯•ç¼–è¯‘ä¸‹ä¾‹çš„ä»£ç ï¼Œä¼šå¾—åˆ°å¦‚ä¸‹æ‰€ç¤ºçš„é”™è¯¯ï¼š

```rust
error[E0072]: recursive type `List` has infinite size
 --> src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ----- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to
  make `List` representable

```

è¿™ä¸ªé”™è¯¯è¡¨æ˜è¿™ä¸ªç±»å‹ â€œæœ‰æ— é™çš„å¤§å°â€ã€‚å…¶åŸå› æ˜¯ List çš„ä¸€ä¸ªæˆå‘˜è¢«å®šä¹‰ä¸ºæ˜¯é€’å½’çš„ï¼šå®ƒç›´æ¥å­˜æ”¾äº†å¦ä¸€ä¸ªç›¸åŒç±»å‹çš„å€¼ã€‚è¿™æ„å‘³ç€ Rust æ— æ³•è®¡ç®—ä¸ºäº†å­˜æ”¾ List å€¼åˆ°åº•éœ€è¦å¤šå°‘ç©ºé—´ã€‚è®©ä¸€ç‚¹ä¸€ç‚¹æ¥çœ‹ï¼šé¦–å…ˆäº†è§£ä¸€ä¸‹ Rust å¦‚ä½•å†³å®šéœ€è¦å¤šå°‘ç©ºé—´æ¥å­˜æ”¾ä¸€ä¸ªéé€’å½’ç±»å‹ã€‚

#### è®¡ç®—éé€’å½’ç±»å‹çš„å¤§å°

```rust

#![allow(unused_variables)]
fn main() {
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
}
```

å½“ Rust éœ€è¦çŸ¥é“è¦ä¸º Message å€¼åˆ†é…å¤šå°‘ç©ºé—´æ—¶ï¼Œå®ƒå¯ä»¥æ£€æŸ¥æ¯ä¸€ä¸ªæˆå‘˜å¹¶å‘ç° Message::Quit å¹¶ä¸éœ€è¦ä»»ä½•ç©ºé—´ï¼ŒMessage::Move éœ€è¦è¶³å¤Ÿå‚¨å­˜ä¸¤ä¸ª i32 å€¼çš„ç©ºé—´ï¼Œä¾æ­¤ç±»æ¨ã€‚å› æ­¤ï¼ŒMessage å€¼æ‰€éœ€çš„ç©ºé—´ç­‰äºå‚¨å­˜å…¶æœ€å¤§æˆå‘˜çš„ç©ºé—´å¤§å°ã€‚

ä¸æ­¤ç›¸å¯¹å½“ Rust ç¼–è¯‘å™¨æ£€æŸ¥åƒç¤ºä¾‹ 15-2 ä¸­çš„ List è¿™æ ·çš„é€’å½’ç±»å‹æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆå‘¢ã€‚ç¼–è¯‘å™¨å°è¯•è®¡ç®—å‡ºå‚¨å­˜ä¸€ä¸ª List æšä¸¾éœ€è¦å¤šå°‘å†…å­˜ï¼Œå¹¶å¼€å§‹æ£€æŸ¥ Cons æˆå‘˜ï¼Œé‚£ä¹ˆ Cons éœ€è¦çš„ç©ºé—´ç­‰äº i32 çš„å¤§å°åŠ ä¸Š List çš„å¤§å°ã€‚ä¸ºäº†è®¡ç®— List éœ€è¦å¤šå°‘å†…å­˜ï¼Œå®ƒæ£€æŸ¥å…¶æˆå‘˜ï¼Œä» Cons æˆå‘˜å¼€å§‹ã€‚Consæˆå‘˜å‚¨å­˜äº†ä¸€ä¸ª i32 å€¼å’Œä¸€ä¸ªListå€¼ï¼Œè¿™æ ·çš„è®¡ç®—å°†æ— é™è¿›è¡Œä¸‹å».

#### ä½¿ç”¨ Box<T> ç»™é€’å½’ç±»å‹ä¸€ä¸ªå·²çŸ¥çš„å¤§å°

Rust æ— æ³•è®¡ç®—å‡ºè¦ä¸ºå®šä¹‰ä¸ºé€’å½’çš„ç±»å‹åˆ†é…å¤šå°‘ç©ºé—´ï¼Œæ‰€ä»¥ç¼–è¯‘å™¨ç»™å‡ºäº†ä¸‹ä¾‹ä¸­çš„é”™è¯¯ã€‚è¿™ä¸ªé”™è¯¯ä¹ŸåŒ…æ‹¬äº†æœ‰ç”¨çš„å»ºè®®ï¼š

```rust
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to
  make `List` representable

```

å› ä¸º `Box<T>` æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œæ€»æ˜¯çŸ¥é“å®ƒéœ€è¦å¤šå°‘ç©ºé—´ï¼šæŒ‡é’ˆçš„å¤§å°å¹¶ä¸ä¼šæ ¹æ®å…¶æŒ‡å‘çš„æ•°æ®é‡è€Œæ”¹å˜ã€‚è¿™æ„å‘³ç€å¯ä»¥å°† Box æ”¾å…¥ Cons æˆå‘˜ä¸­è€Œä¸æ˜¯ç›´æ¥å­˜æ”¾å¦ä¸€ä¸ª List å€¼ã€‚Box ä¼šæŒ‡å‘å¦ä¸€ä¸ªä½äºå †ä¸Šçš„ List å€¼ï¼Œè€Œä¸æ˜¯å­˜æ”¾åœ¨ Cons æˆå‘˜ä¸­ã€‚ä»æ¦‚å¿µä¸Šè®²ï¼Œä»ç„¶æœ‰ä¸€ä¸ªé€šè¿‡åœ¨å…¶ä¸­ â€œå­˜æ”¾â€ å…¶ä»–åˆ—è¡¨åˆ›å»ºçš„åˆ—è¡¨ï¼Œä¸è¿‡ç°åœ¨å®ç°è¿™ä¸ªæ¦‚å¿µçš„æ–¹å¼æ›´åƒæ˜¯ä¸€ä¸ªé¡¹æŒ¨ç€å¦ä¸€é¡¹ï¼Œè€Œä¸æ˜¯ä¸€é¡¹åŒ…å«å¦ä¸€é¡¹ã€‚

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}

```

Cons æˆå‘˜å°†ä¼šéœ€è¦ä¸€ä¸ª i32 çš„å¤§å°åŠ ä¸Šå‚¨å­˜ box æŒ‡é’ˆæ•°æ®çš„ç©ºé—´ã€‚Nil æˆå‘˜ä¸å‚¨å­˜å€¼ï¼Œæ‰€ä»¥å®ƒæ¯” Cons æˆå‘˜éœ€è¦æ›´å°‘çš„ç©ºé—´ã€‚ç°åœ¨çŸ¥é“äº†ä»»ä½• List å€¼æœ€å¤šéœ€è¦ä¸€ä¸ª i32 åŠ ä¸Š box æŒ‡é’ˆæ•°æ®çš„å¤§å°ã€‚é€šè¿‡ä½¿ç”¨ box ï¼Œæ‰“ç ´äº†è¿™æ— é™é€’å½’çš„è¿é”ï¼Œè¿™æ ·ç¼–è¯‘å™¨å°±èƒ½å¤Ÿè®¡ç®—å‡ºå‚¨å­˜ List å€¼éœ€è¦çš„å¤§å°äº†ã€‚

box åªæä¾›äº†é—´æ¥å­˜å‚¨å’Œå †åˆ†é…ï¼›ä»–ä»¬å¹¶æ²¡æœ‰ä»»ä½•å…¶ä»–ç‰¹æ®Šçš„åŠŸèƒ½ï¼Œæ¯”å¦‚å°†ä¼šè§åˆ°çš„å…¶ä»–æ™ºèƒ½æŒ‡é’ˆã€‚å®ƒä»¬ä¹Ÿæ²¡æœ‰è¿™äº›ç‰¹æ®ŠåŠŸèƒ½å¸¦æ¥çš„æ€§èƒ½æŸå¤±ï¼Œæ‰€ä»¥ä»–ä»¬å¯ä»¥ç”¨äºåƒ cons list è¿™æ ·é—´æ¥å­˜å‚¨æ˜¯å”¯ä¸€æ‰€éœ€åŠŸèƒ½çš„åœºæ™¯ã€‚

`Box<T>` ç±»å‹æ˜¯ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆï¼Œå› ä¸ºå®ƒå®ç°äº† Deref traitï¼Œå®ƒå…è®¸ `Box<T>` å€¼è¢«å½“ä½œå¼•ç”¨å¯¹å¾…ã€‚å½“ `Box<T>` å€¼ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œç”±äº `Box<T>` ç±»å‹ Drop trait çš„å®ç°ï¼Œbox æ‰€æŒ‡å‘çš„å †æ•°æ®ä¹Ÿä¼šè¢«æ¸…é™¤ã€‚è®©æ›´è¯¦ç»†çš„æ¢ç´¢ä¸€ä¸‹è¿™ä¸¤ä¸ª traitã€‚è¿™ä¸¤ä¸ª trait å¯¹äºåœ¨æœ¬ç« ä½™ä¸‹è®¨è®ºçš„å…¶ä»–æ™ºèƒ½æŒ‡é’ˆæ‰€æä¾›çš„åŠŸèƒ½ä¸­ï¼Œå°†ä¼šæ›´ä¸ºé‡è¦ã€‚

#### é€šè¿‡ Deref trait å°†æ™ºèƒ½æŒ‡é’ˆå½“ä½œå¸¸è§„å¼•ç”¨å¤„ç†

å®ç° Deref trait å…è®¸é‡è½½ è§£å¼•ç”¨è¿ç®—ç¬¦ï¼ˆdereference operatorï¼‰*ï¼ˆä¸ä¹˜æ³•è¿ç®—ç¬¦æˆ– glob è¿ç®—ç¬¦ç›¸åŒºåˆ«ï¼‰ã€‚é€šè¿‡è¿™ç§æ–¹å¼å®ç° Deref trait çš„æ™ºèƒ½æŒ‡é’ˆå¯ä»¥è¢«å½“ä½œå¸¸è§„å¼•ç”¨æ¥å¯¹å¾…ï¼Œå¯ä»¥ç¼–å†™æ“ä½œå¼•ç”¨çš„ä»£ç å¹¶ç”¨äºæ™ºèƒ½æŒ‡é’ˆã€‚

è®©é¦–å…ˆçœ‹çœ‹è§£å¼•ç”¨è¿ç®—ç¬¦å¦‚ä½•å¤„ç†å¸¸è§„å¼•ç”¨ï¼Œæ¥ç€å°è¯•å®šä¹‰è‡ªå·±çš„ç±»ä¼¼ `Box<T>` çš„ç±»å‹å¹¶çœ‹çœ‹ä¸ºä½•è§£å¼•ç”¨è¿ç®—ç¬¦ä¸èƒ½åƒå¼•ç”¨ä¸€æ ·å·¥ä½œã€‚ä¼šæ¢ç´¢å¦‚ä½•å®ç° Deref trait ä½¿å¾—æ™ºèƒ½æŒ‡é’ˆä»¥ç±»ä¼¼å¼•ç”¨çš„æ–¹å¼å·¥ä½œå˜ä¸ºå¯èƒ½ã€‚æœ€åï¼Œä¼šè®¨è®º Rust çš„ è§£å¼•ç”¨å¼ºåˆ¶å¤šæ€ï¼ˆderef coercionsï¼‰åŠŸèƒ½å’Œå®ƒæ˜¯å¦‚ä½•ä¸€åŒå¤„ç†å¼•ç”¨æˆ–æ™ºèƒ½æŒ‡é’ˆçš„ã€‚

#### é€šè¿‡è§£å¼•ç”¨è¿ç®—ç¬¦è¿½è¸ªæŒ‡é’ˆçš„å€¼

å¸¸è§„å¼•ç”¨æ˜¯ä¸€ä¸ªæŒ‡é’ˆç±»å‹ï¼Œä¸€ç§ç†è§£æŒ‡é’ˆçš„æ–¹å¼æ˜¯å°†å…¶çœ‹æˆæŒ‡å‘å‚¨å­˜åœ¨å…¶ä»–æŸå¤„å€¼çš„ç®­å¤´ã€‚

```rust
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}

```

å˜é‡ x å­˜æ”¾äº†ä¸€ä¸ª i32 å€¼ 5ã€‚y ç­‰äº x çš„ä¸€ä¸ªå¼•ç”¨ã€‚å¯ä»¥æ–­è¨€ x ç­‰äº 5ã€‚ç„¶è€Œï¼Œå¦‚æœå¸Œæœ›å¯¹ y çš„å€¼åšå‡ºæ–­è¨€ï¼Œå¿…é¡»ä½¿ç”¨ *y æ¥è¿½è¸ªå¼•ç”¨æ‰€æŒ‡å‘çš„å€¼ï¼ˆä¹Ÿå°±æ˜¯ è§£å¼•ç”¨ï¼‰ã€‚ä¸€æ—¦è§£å¼•ç”¨äº† yï¼Œå°±å¯ä»¥è®¿é—® y æ‰€æŒ‡å‘çš„æ•´å‹å€¼å¹¶å¯ä»¥ä¸ 5 åšæ¯”è¾ƒã€‚

ç›¸åå¦‚æœå°è¯•ç¼–å†™ assert_eq!(5, y);ï¼Œåˆ™ä¼šå¾—åˆ°å¦‚ä¸‹ç¼–è¯‘é”™è¯¯ï¼š

```rust
error[E0277]: can't compare `{integer}` with `&{integer}`
 --> src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &{integer}`
  |
  = help: the trait `std::cmp::PartialEq<&{integer}>` is not implemented for
  `{integer}`

```

ä¸å…è®¸æ¯”è¾ƒæ•°å­—çš„å¼•ç”¨ä¸æ•°å­—ï¼Œå› ä¸ºå®ƒä»¬æ˜¯ä¸åŒçš„ç±»å‹ã€‚å¿…é¡»ä½¿ç”¨è§£å¼•ç”¨è¿ç®—ç¬¦è¿½è¸ªå¼•ç”¨æ‰€æŒ‡å‘çš„å€¼ã€‚

#### åƒå¼•ç”¨ä¸€æ ·ä½¿ç”¨ Box<T>

å¯ä»¥ä½¿ç”¨ `Box<T>` ä»£æ›¿å¼•ç”¨æ¥é‡å†™ä¸Šä¾‹ä¸­çš„ä»£ç ï¼Œè§£å¼•ç”¨è¿ç®—ç¬¦ä¹Ÿä¸€æ ·èƒ½å·¥ä½œï¼Œå¦‚ä¸‹ä¾‹æ‰€ç¤ºï¼š

```rust
fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}

```

#### è‡ªå®šä¹‰æ™ºèƒ½æŒ‡é’ˆ

ä¸ºäº†ä½“ä¼šé»˜è®¤æ™ºèƒ½æŒ‡é’ˆçš„è¡Œä¸ºä¸åŒäºå¼•ç”¨ï¼Œè®©åˆ›å»ºä¸€ä¸ªç±»ä¼¼äºæ ‡å‡†åº“æä¾›çš„ `Box<T>` ç±»å‹çš„æ™ºèƒ½æŒ‡é’ˆã€‚æ¥ç€ä¼šå­¦ä¹ å¦‚ä½•å¢åŠ ä½¿ç”¨è§£å¼•ç”¨è¿ç®—ç¬¦çš„åŠŸèƒ½ã€‚

ä»æ ¹æœ¬ä¸Šè¯´ï¼Œ`Box<T>` è¢«å®šä¹‰ä¸ºåŒ…å«ä¸€ä¸ªå…ƒç´ çš„å…ƒç»„ç»“æ„ä½“ï¼Œæ‰€ä»¥ä¸‹ä¾‹ä»¥ç›¸åŒçš„æ–¹å¼å®šä¹‰äº† `MyBox<T>` ç±»å‹ã€‚è¿˜å®šä¹‰äº† new å‡½æ•°æ¥å¯¹åº”å®šä¹‰äº `Box<T>` çš„ new å‡½æ•°ï¼š

```rust

#![allow(unused_variables)]
fn main() {
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}
}
```

è¿™é‡Œå®šä¹‰äº†ä¸€ä¸ªç»“æ„ä½“ MyBox å¹¶å£°æ˜äº†ä¸€ä¸ªæ³›å‹å‚æ•° Tï¼Œå› ä¸ºå¸Œæœ›å…¶å¯ä»¥å­˜æ”¾ä»»ä½•ç±»å‹çš„å€¼ã€‚MyBox æ˜¯ä¸€ä¸ªåŒ…å« T ç±»å‹å…ƒç´ çš„å…ƒç»„ç»“æ„ä½“ã€‚MyBox::new å‡½æ•°è·å–ä¸€ä¸ª T ç±»å‹çš„å‚æ•°å¹¶è¿”å›ä¸€ä¸ªå­˜æ”¾ä¼ å…¥å€¼çš„ MyBox å®ä¾‹ã€‚

å°è¯•å°†ä¸‹ä¾‹ä¸­çš„ä»£ç åŠ å…¥ç¤ºä¾‹ 15-8 ä¸­å¹¶ä¿®æ”¹ main ä½¿ç”¨å®šä¹‰çš„ `MyBox<T>` ç±»å‹ä»£æ›¿ `Box<T>`ã€‚ç¤ºä¾‹ 15-9 ä¸­çš„ä»£ç ä¸èƒ½ç¼–è¯‘ï¼Œå› ä¸º Rust ä¸çŸ¥é“å¦‚ä½•è§£å¼•ç”¨ MyBoxï¼š

```rust
fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}

```

å°è¯•ä»¥ä½¿ç”¨å¼•ç”¨å’Œ `Box<T>` ç›¸åŒçš„æ–¹å¼ä½¿ç”¨ `MyBox<T>`

å¾—åˆ°çš„ç¼–è¯‘é”™è¯¯æ˜¯ï¼š

```rust
error[E0614]: type `MyBox<{integer}>` cannot be dereferenced
  --> src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

```

`MyBox<T>` ç±»å‹ä¸èƒ½è§£å¼•ç”¨å¹¶æ²¡æœ‰ä¸ºå…¶å®ç°è¿™ä¸ªåŠŸèƒ½ã€‚ä¸ºäº†å¯ç”¨ * è¿ç®—ç¬¦çš„è§£å¼•ç”¨åŠŸèƒ½ï¼Œéœ€è¦å®ç° Deref traitã€‚

#### é€šè¿‡å®ç° Deref trait å°†æŸç±»å‹åƒå¼•ç”¨ä¸€æ ·å¤„ç†

ä¸ºäº†å®ç° traitï¼Œéœ€è¦æä¾› trait æ‰€éœ€çš„æ–¹æ³•å®ç°ã€‚Deref traitï¼Œç”±æ ‡å‡†åº“æä¾›ï¼Œè¦æ±‚å®ç°åä¸º deref çš„æ–¹æ³•ï¼Œå…¶å€Ÿç”¨ self å¹¶è¿”å›ä¸€ä¸ªå†…éƒ¨æ•°æ®çš„å¼•ç”¨ã€‚ä¸‹ä¾‹åŒ…å«å®šä¹‰äº MyBox ä¹‹ä¸Šçš„ Deref å®ç°ï¼š

```rust

#![allow(unused_variables)]
fn main() {
use std::ops::Deref;

struct MyBox<T>(T);
impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &T {
        &self.0
    }
}
}
```

type Target = T; è¯­æ³•å®šä¹‰äº†ç”¨äºæ­¤ trait çš„å…³è”ç±»å‹ã€‚å…³è”ç±»å‹æ˜¯ä¸€ä¸ªç¨æœ‰ä¸åŒçš„å®šä¹‰æ³›å‹å‚æ•°çš„æ–¹å¼ï¼Œç°åœ¨è¿˜æ— éœ€è¿‡å¤šçš„æ‹…å¿ƒå®ƒï¼›ç¬¬åä¹ç« ä¼šè¯¦ç»†ä»‹ç»ã€‚

deref æ–¹æ³•ä½“ä¸­å†™å…¥äº† &self.0ï¼Œè¿™æ · deref è¿”å›äº†æˆ‘å¸Œæœ›é€šè¿‡ * è¿ç®—ç¬¦è®¿é—®çš„å€¼çš„å¼•ç”¨ã€‚ç¤ºä¾‹ 15-9 ä¸­çš„ main å‡½æ•°ä¸­å¯¹ `MyBox<T>` å€¼çš„ * è°ƒç”¨ç°åœ¨å¯ä»¥ç¼–è¯‘å¹¶èƒ½é€šè¿‡æ–­è¨€äº†ï¼

æ²¡æœ‰ Deref trait çš„è¯ï¼Œç¼–è¯‘å™¨åªä¼šè§£å¼•ç”¨ & å¼•ç”¨ç±»å‹ã€‚deref æ–¹æ³•å‘ç¼–è¯‘å™¨æä¾›äº†è·å–ä»»ä½•å®ç°äº† Deref trait çš„ç±»å‹çš„å€¼å¹¶è°ƒç”¨è¿™ä¸ªç±»å‹çš„ deref æ–¹æ³•æ¥è·å–ä¸€ä¸ªå®ƒçŸ¥é“å¦‚ä½•è§£å¼•ç”¨çš„ & å¼•ç”¨çš„èƒ½åŠ›ã€‚

```rust
*(y.deref())

```

Rust å°† * è¿ç®—ç¬¦æ›¿æ¢ä¸ºå…ˆè°ƒç”¨ deref æ–¹æ³•å†è¿›è¡Œç›´æ¥å¼•ç”¨çš„æ“ä½œï¼Œå¦‚æ­¤ä¾¿ä¸ç”¨æ‹…å¿ƒæ˜¯ä¸æ˜¯è¿˜éœ€è¦æ‰‹åŠ¨è°ƒç”¨ deref æ–¹æ³•äº†ã€‚Rust çš„è¿™ä¸ªç‰¹æ€§å¯ä»¥è®©å†™å‡ºè¡Œä¸ºä¸€è‡´çš„ä»£ç ï¼Œæ— è®ºæ˜¯é¢å¯¹çš„æ˜¯å¸¸è§„å¼•ç”¨è¿˜æ˜¯å®ç°äº† Deref çš„ç±»å‹ã€‚

deref æ–¹æ³•è¿”å›å€¼çš„å¼•ç”¨ï¼Œä»¥åŠ *(y.deref()) æ‹¬å·å¤–è¾¹çš„æ™®é€šè§£å¼•ç”¨ä»ä¸ºå¿…é¡»çš„åŸå› åœ¨äºæ‰€æœ‰æƒã€‚å¦‚æœ deref æ–¹æ³•ç›´æ¥è¿”å›å€¼è€Œä¸æ˜¯å€¼çš„å¼•ç”¨ï¼Œå…¶å€¼ï¼ˆçš„æ‰€æœ‰æƒï¼‰å°†è¢«ç§»å‡º selfã€‚åœ¨è¿™é‡Œä»¥åŠå¤§éƒ¨åˆ†ä½¿ç”¨è§£å¼•ç”¨è¿ç®—ç¬¦çš„æƒ…å†µä¸‹å¹¶ä¸å¸Œæœ›è·å– `MyBox<T>` å†…éƒ¨å€¼çš„æ‰€æœ‰æƒã€‚

æ³¨æ„ï¼Œæ¯æ¬¡å½“åœ¨ä»£ç ä¸­ä½¿ç”¨ * æ—¶ï¼Œ * è¿ç®—ç¬¦éƒ½è¢«æ›¿æ¢æˆäº†å…ˆè°ƒç”¨ deref æ–¹æ³•å†æ¥ç€ä½¿ç”¨ * è§£å¼•ç”¨çš„æ“ä½œï¼Œä¸”åªä¼šå‘ç”Ÿä¸€æ¬¡ï¼Œä¸ä¼šå¯¹ * æ“ä½œç¬¦æ— é™é€’å½’æ›¿æ¢ï¼Œè§£å¼•ç”¨å‡ºä¸Šé¢ i32 ç±»å‹çš„å€¼å°±åœæ­¢äº†ï¼Œè¿™ä¸ªå€¼ä¸ ä¸‹ä¾‹ ä¸­ assert_eq! çš„ 5 ç›¸åŒ¹é…ã€‚

#### å‡½æ•°å’Œæ–¹æ³•çš„éšå¼è§£å¼•ç”¨å¼ºåˆ¶å¤šæ€

è§£å¼•ç”¨å¼ºåˆ¶å¤šæ€ï¼ˆderef coercionsï¼‰æ˜¯ Rust è¡¨ç°åœ¨å‡½æ•°æˆ–æ–¹æ³•ä¼ å‚ä¸Šçš„ä¸€ç§ä¾¿åˆ©ã€‚å…¶å°†å®ç°äº† Deref çš„ç±»å‹çš„å¼•ç”¨è½¬æ¢ä¸ºåŸå§‹ç±»å‹é€šè¿‡ Deref æ‰€èƒ½å¤Ÿè½¬æ¢çš„ç±»å‹çš„å¼•ç”¨ã€‚å½“è¿™ç§ç‰¹å®šç±»å‹çš„å¼•ç”¨ä½œä¸ºå®å‚ä¼ é€’ç»™å’Œå½¢å‚ç±»å‹ä¸åŒçš„å‡½æ•°æˆ–æ–¹æ³•æ—¶ï¼Œè§£å¼•ç”¨å¼ºåˆ¶å¤šæ€å°†è‡ªåŠ¨å‘ç”Ÿã€‚è¿™æ—¶ä¼šæœ‰ä¸€ç³»åˆ—çš„ deref æ–¹æ³•è¢«è°ƒç”¨ï¼ŒæŠŠæä¾›çš„ç±»å‹è½¬æ¢æˆäº†å‚æ•°æ‰€éœ€çš„ç±»å‹ã€‚

è§£å¼•ç”¨å¼ºåˆ¶å¤šæ€çš„åŠ å…¥ä½¿å¾— Rust ç¨‹åºå‘˜ç¼–å†™å‡½æ•°å’Œæ–¹æ³•è°ƒç”¨æ—¶æ— éœ€å¢åŠ è¿‡å¤šæ˜¾å¼ä½¿ç”¨ & å’Œ * çš„å¼•ç”¨å’Œè§£å¼•ç”¨ã€‚è¿™ä¸ªåŠŸèƒ½ä¹Ÿä½¿å¾—å¯ä»¥ç¼–å†™æ›´å¤šåŒæ—¶ä½œç”¨äºå¼•ç”¨æˆ–æ™ºèƒ½æŒ‡é’ˆçš„ä»£ç ã€‚

ä½œä¸ºå±•ç¤ºè§£å¼•ç”¨å¼ºåˆ¶å¤šæ€çš„å®ä¾‹ï¼Œè®©ä½¿ç”¨ä¸Šä¾‹ä¸­å®šä¹‰çš„ `MyBox<T>`ï¼Œä»¥åŠä¸‹ä¾‹ä¸­å¢åŠ çš„ Deref å®ç°ã€‚ä¸‹ä¾‹å±•ç¤ºäº†ä¸€ä¸ªæœ‰ç€å­—ç¬¦ä¸² slice å‚æ•°çš„å‡½æ•°å®šä¹‰ï¼š

```rust

#![allow(unused_variables)]
fn main() {
fn hello(name: &str) {
    println!("Hello, {}!", name);
}
}
```

å¯ä»¥ä½¿ç”¨å­—ç¬¦ä¸² slice ä½œä¸ºå‚æ•°è°ƒç”¨ hello å‡½æ•°ï¼Œæ¯”å¦‚ hello("Rust");ã€‚è§£å¼•ç”¨å¼ºåˆ¶å¤šæ€ä½¿å¾—ç”¨ `MyBox<String>` ç±»å‹å€¼çš„å¼•ç”¨è°ƒç”¨ hello æˆä¸ºå¯èƒ½ï¼Œå¦‚ä¸‹ä¾‹ æ‰€ç¤ºï¼š

```rust
use std::ops::Deref;

struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &T {
        &self.0
    }
}

fn hello(name: &str) {
    println!("Hello, {}!", name);
}

fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&m);
}

```

```rust
use std::ops::Deref;

struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &T {
        &self.0
    }
}

fn hello(name: &str) {
    println!("Hello, {}!", name);
}

fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&(*m)[..]);
}

```

(*m) å°† `MyBox<String>` è§£å¼•ç”¨ä¸º Stringã€‚æ¥ç€ `&` å’Œ `[..]` è·å–äº†æ•´ä¸ª String çš„å­—ç¬¦ä¸² slice æ¥åŒ¹é… hello çš„ç­¾åã€‚æ²¡æœ‰è§£å¼•ç”¨å¼ºåˆ¶å¤šæ€æ‰€æœ‰è¿™äº›ç¬¦å·æ··åœ¨ä¸€èµ·å°†æ›´éš¾ä»¥è¯»å†™å’Œç†è§£ã€‚è§£å¼•ç”¨å¼ºåˆ¶å¤šæ€ä½¿å¾— Rust è‡ªåŠ¨çš„å¸®å¤„ç†è¿™äº›è½¬æ¢ã€‚

å½“æ‰€æ¶‰åŠåˆ°çš„ç±»å‹å®šä¹‰äº† Deref traitï¼ŒRust ä¼šåˆ†æè¿™äº›ç±»å‹å¹¶ä½¿ç”¨ä»»æ„å¤šæ¬¡ Deref::deref è°ƒç”¨ä»¥è·å¾—åŒ¹é…å‚æ•°çš„ç±»å‹ã€‚è¿™äº›è§£æéƒ½å‘ç”Ÿåœ¨ç¼–è¯‘æ—¶ï¼Œæ‰€ä»¥åˆ©ç”¨è§£å¼•ç”¨å¼ºåˆ¶å¤šæ€å¹¶æ²¡æœ‰è¿è¡Œæ—¶æƒ©ç½šï¼

#### è§£å¼•ç”¨å¼ºåˆ¶å¤šæ€å¦‚ä½•ä¸å¯å˜æ€§äº¤äº’

ç±»ä¼¼äºå¦‚ä½•ä½¿ç”¨ Deref trait é‡è½½ä¸å¯å˜å¼•ç”¨çš„ * è¿ç®—ç¬¦ï¼ŒRust æä¾›äº† DerefMut trait ç”¨äºé‡è½½å¯å˜å¼•ç”¨çš„ * è¿ç®—ç¬¦ã€‚

Rust åœ¨å‘ç°ç±»å‹å’Œ trait å®ç°æ»¡è¶³ä¸‰ç§æƒ…å†µæ—¶ä¼šè¿›è¡Œè§£å¼•ç”¨å¼ºåˆ¶å¤šæ€ï¼š

* å½“ `T: Deref<Target=U>` æ—¶ä» &T åˆ° &Uã€‚
* å½“ `T: DerefMut<Target=U>` æ—¶ä» &mut T åˆ° &mut Uã€‚
* å½“ `T: Deref<Target=U>` æ—¶ä» &mut T åˆ° &Uã€‚

å¤´ä¸¤ä¸ªæƒ…å†µé™¤äº†å¯å˜æ€§ä¹‹å¤–æ˜¯ç›¸åŒçš„ï¼šç¬¬ä¸€ç§æƒ…å†µè¡¨æ˜å¦‚æœæœ‰ä¸€ä¸ª &Tï¼Œè€Œ T å®ç°äº†è¿”å› U ç±»å‹çš„ Derefï¼Œåˆ™å¯ä»¥ç›´æ¥å¾—åˆ° &Uã€‚ç¬¬äºŒç§æƒ…å†µè¡¨æ˜å¯¹äºå¯å˜å¼•ç”¨ä¹Ÿæœ‰ç€ç›¸åŒçš„è¡Œä¸ºã€‚

ç¬¬ä¸‰ä¸ªæƒ…å†µæœ‰äº›å¾®å¦™ï¼šRust ä¹Ÿä¼šå°†å¯å˜å¼•ç”¨å¼ºè½¬ä¸ºä¸å¯å˜å¼•ç”¨ã€‚ä½†æ˜¯åä¹‹æ˜¯ ä¸å¯èƒ½ çš„ï¼šä¸å¯å˜å¼•ç”¨æ°¸è¿œä¹Ÿä¸èƒ½å¼ºè½¬ä¸ºå¯å˜å¼•ç”¨ã€‚å› ä¸ºæ ¹æ®å€Ÿç”¨è§„åˆ™ï¼Œå¦‚æœæœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œå…¶å¿…é¡»æ˜¯è¿™äº›æ•°æ®çš„å”¯ä¸€å¼•ç”¨ï¼ˆå¦åˆ™ç¨‹åºå°†æ— æ³•ç¼–è¯‘ï¼‰ã€‚å°†ä¸€ä¸ªå¯å˜å¼•ç”¨è½¬æ¢ä¸ºä¸å¯å˜å¼•ç”¨æ°¸è¿œä¹Ÿä¸ä¼šæ‰“ç ´å€Ÿç”¨è§„åˆ™ã€‚å°†ä¸å¯å˜å¼•ç”¨è½¬æ¢ä¸ºå¯å˜å¼•ç”¨åˆ™éœ€è¦æ•°æ®åªèƒ½æœ‰ä¸€ä¸ªä¸å¯å˜å¼•ç”¨ï¼Œè€Œå€Ÿç”¨è§„åˆ™æ— æ³•ä¿è¯è¿™ä¸€ç‚¹ã€‚å› æ­¤ï¼ŒRust æ— æ³•å‡è®¾å°†ä¸å¯å˜å¼•ç”¨è½¬æ¢ä¸ºå¯å˜å¼•ç”¨æ˜¯å¯èƒ½çš„ã€‚

#### ä½¿ç”¨ Drop Trait è¿è¡Œæ¸…ç†ä»£ç 

å¯¹äºæ™ºèƒ½æŒ‡é’ˆæ¨¡å¼æ¥è¯´ç¬¬äºŒä¸ªé‡è¦çš„ trait æ˜¯ Dropï¼Œå…¶å…è®¸åœ¨å€¼è¦ç¦»å¼€ä½œç”¨åŸŸæ—¶æ‰§è¡Œä¸€äº›ä»£ç ã€‚å¯ä»¥ä¸ºä»»ä½•ç±»å‹æä¾› Drop trait çš„å®ç°ï¼ŒåŒæ—¶æ‰€æŒ‡å®šçš„ä»£ç è¢«ç”¨äºé‡Šæ”¾ç±»ä¼¼äºæ–‡ä»¶æˆ–ç½‘ç»œè¿æ¥çš„èµ„æºã€‚åœ¨æ™ºèƒ½æŒ‡é’ˆä¸Šä¸‹æ–‡ä¸­è®¨è®º Drop æ˜¯å› ä¸ºå…¶åŠŸèƒ½å‡ ä¹æ€»æ˜¯ç”¨äºå®ç°æ™ºèƒ½æŒ‡é’ˆã€‚ä¾‹å¦‚ï¼ŒBox<T> è‡ªå®šä¹‰äº† Drop ç”¨æ¥é‡Šæ”¾ box æ‰€æŒ‡å‘çš„å †ç©ºé—´ã€‚

åœ¨å…¶ä»–ä¸€äº›è¯­è¨€ä¸­ï¼Œä¸å¾—ä¸è®°ä½åœ¨æ¯æ¬¡ä½¿ç”¨å®Œæ™ºèƒ½æŒ‡é’ˆå®ä¾‹åè°ƒç”¨æ¸…ç†å†…å­˜æˆ–èµ„æºçš„ä»£ç ã€‚å¦‚æœå¿˜è®°çš„è¯ï¼Œè¿è¡Œä»£ç çš„ç³»ç»Ÿå¯èƒ½ä¼šå› ä¸ºè´Ÿè·è¿‡é‡è€Œå´©æºƒã€‚åœ¨ Rust ä¸­ï¼Œå¯ä»¥æŒ‡å®šä¸€äº›ä»£ç åº”è¯¥åœ¨å€¼ç¦»å¼€ä½œç”¨åŸŸæ—¶è¢«æ‰§è¡Œï¼Œè€Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨æ’å…¥è¿™äº›ä»£ç ã€‚äºæ˜¯å°±ä¸éœ€è¦åœ¨ç¨‹åºä¸­åˆ°å¤„ç¼–å†™åœ¨å®ä¾‹ç»“æŸæ—¶æ¸…ç†è¿™äº›å˜é‡çš„ä»£ç  â€”â€” è€Œä¸”è¿˜ä¸ä¼šæ³„éœ²èµ„æºã€‚

æŒ‡å®šåœ¨å€¼ç¦»å¼€ä½œç”¨åŸŸæ—¶åº”è¯¥æ‰§è¡Œçš„ä»£ç çš„æ–¹å¼æ˜¯å®ç° Drop traitã€‚Drop trait è¦æ±‚å®ç°ä¸€ä¸ªå«åš drop çš„æ–¹æ³•ï¼Œå®ƒè·å–ä¸€ä¸ª self çš„å¯å˜å¼•ç”¨ã€‚ä¸ºäº†èƒ½å¤Ÿçœ‹å‡º Rust ä½•æ—¶è°ƒç”¨ dropï¼Œè®©æš‚æ—¶ä½¿ç”¨ println! è¯­å¥å®ç° dropã€‚

```rust
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer { data: String::from("my stuff") };
    let d = CustomSmartPointer { data: String::from("other stuff") };
    println!("CustomSmartPointers created.");
}

```

Drop trait åŒ…å«åœ¨ prelude ä¸­ï¼Œæ‰€ä»¥æ— éœ€å¯¼å…¥å®ƒã€‚åœ¨ CustomSmartPointer ä¸Šå®ç°äº† Drop traitï¼Œå¹¶æä¾›äº†ä¸€ä¸ªè°ƒç”¨ println! çš„ drop æ–¹æ³•å®ç°ã€‚drop å‡½æ•°ä½“æ˜¯æ”¾ç½®ä»»ä½•å½“ç±»å‹å®ä¾‹ç¦»å¼€ä½œç”¨åŸŸæ—¶æœŸæœ›è¿è¡Œçš„é€»è¾‘çš„åœ°æ–¹ã€‚è¿™é‡Œé€‰æ‹©æ‰“å°ä¸€äº›æ–‡æœ¬ä»¥å±•ç¤º Rust ä½•æ—¶è°ƒç”¨ dropã€‚

åœ¨ main ä¸­ï¼Œæ–°å»ºäº†ä¸¤ä¸ª CustomSmartPointer å®ä¾‹å¹¶æ‰“å°å‡ºäº† CustomSmartPointer created.ã€‚åœ¨ main çš„ç»“å°¾ï¼ŒCustomSmartPointer çš„å®ä¾‹ä¼šç¦»å¼€ä½œç”¨åŸŸï¼Œè€Œ Rust ä¼šè°ƒç”¨æ”¾ç½®äº drop æ–¹æ³•ä¸­çš„ä»£ç ï¼Œæ‰“å°å‡ºæœ€åçš„ä¿¡æ¯ã€‚æ³¨æ„æ— éœ€æ˜¾ç¤ºè°ƒç”¨ drop æ–¹æ³•ï¼š

#### é€šè¿‡ std::mem::drop ææ—©ä¸¢å¼ƒå€¼

ä¸å¹¸çš„æ˜¯ï¼Œå¹¶ä¸èƒ½ç›´æˆªäº†å½“çš„ç¦ç”¨ drop è¿™ä¸ªåŠŸèƒ½ã€‚é€šå¸¸ä¹Ÿä¸éœ€è¦ç¦ç”¨ drop ï¼›æ•´ä¸ª Drop trait å­˜åœ¨çš„æ„ä¹‰åœ¨äºå…¶æ˜¯è‡ªåŠ¨å¤„ç†çš„ã€‚ç„¶è€Œï¼Œæœ‰æ—¶å¯èƒ½éœ€è¦ææ—©æ¸…ç†æŸä¸ªå€¼ã€‚ä¸€ä¸ªä¾‹å­æ˜¯å½“ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆç®¡ç†é”æ—¶ï¼›å¯èƒ½å¸Œæœ›å¼ºåˆ¶è¿è¡Œ drop æ–¹æ³•æ¥é‡Šæ”¾é”ä»¥ä¾¿ä½œç”¨åŸŸä¸­çš„å…¶ä»–ä»£ç å¯ä»¥è·å–é”ã€‚Rust å¹¶ä¸å…è®¸ä¸»åŠ¨è°ƒç”¨ Drop trait çš„ drop æ–¹æ³•ï¼›å½“å¸Œæœ›åœ¨ä½œç”¨åŸŸç»“æŸä¹‹å‰å°±å¼ºåˆ¶é‡Šæ”¾å˜é‡çš„è¯ï¼Œåº”è¯¥ä½¿ç”¨çš„æ˜¯ç”±æ ‡å‡†åº“æä¾›çš„ std::mem::dropã€‚

Rust ä¸å…è®¸æ˜¾å¼è°ƒç”¨ drop å› ä¸º Rust ä»ç„¶ä¼šåœ¨ main çš„ç»“å°¾å¯¹å€¼è‡ªåŠ¨è°ƒç”¨ dropï¼Œè¿™ä¼šå¯¼è‡´ä¸€ä¸ª double free é”™è¯¯ï¼Œå› ä¸º Rust ä¼šå°è¯•æ¸…ç†ç›¸åŒçš„å€¼ä¸¤æ¬¡ã€‚

å› ä¸ºä¸èƒ½ç¦ç”¨å½“å€¼ç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨æ’å…¥çš„ dropï¼Œå¹¶ä¸”ä¸èƒ½æ˜¾ç¤ºè°ƒç”¨ dropï¼Œå¦‚æœéœ€è¦å¼ºåˆ¶ææ—©æ¸…ç†å€¼ï¼Œå¯ä»¥ä½¿ç”¨ std::mem::drop å‡½æ•°ã€‚

std::mem::drop å‡½æ•°ä¸åŒäº Drop trait ä¸­çš„ drop æ–¹æ³•ã€‚å¯ä»¥é€šè¿‡ä¼ é€’å¸Œæœ›ææ—©å¼ºåˆ¶ä¸¢å¼ƒçš„å€¼ä½œä¸ºå‚æ•°ã€‚std::mem::drop ä½äº preludeï¼Œ

```rust
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer { data: String::from("some data") };
    println!("CustomSmartPointer created.");
    drop(c);
    println!("CustomSmartPointer dropped before the end of main.");
}

```

#### Rc<T> å¼•ç”¨è®¡æ•°æ™ºèƒ½æŒ‡é’ˆ

å¤§éƒ¨åˆ†æƒ…å†µä¸‹æ‰€æœ‰æƒæ˜¯éå¸¸æ˜ç¡®çš„ï¼šå¯ä»¥å‡†ç¡®åœ°çŸ¥é“å“ªä¸ªå˜é‡æ‹¥æœ‰æŸä¸ªå€¼ã€‚ç„¶è€Œï¼Œæœ‰äº›æƒ…å†µå•ä¸ªå€¼å¯èƒ½ä¼šæœ‰å¤šä¸ªæ‰€æœ‰è€…ã€‚ä¾‹å¦‚ï¼Œåœ¨å›¾æ•°æ®ç»“æ„ä¸­ï¼Œå¤šä¸ªè¾¹å¯èƒ½æŒ‡å‘ç›¸åŒçš„ç»“ç‚¹ï¼Œè€Œè¿™ä¸ªç»“ç‚¹ä»æ¦‚å¿µä¸Šè®²ä¸ºæ‰€æœ‰æŒ‡å‘å®ƒçš„è¾¹æ‰€æ‹¥æœ‰ã€‚ç»“ç‚¹ç›´åˆ°æ²¡æœ‰ä»»ä½•è¾¹æŒ‡å‘å®ƒä¹‹å‰éƒ½ä¸åº”è¯¥è¢«æ¸…ç†ã€‚

ä¸ºäº†å¯ç”¨å¤šæ‰€æœ‰æƒï¼ŒRust æœ‰ä¸€ä¸ªå«åš `Rc<T>` çš„ç±»å‹ã€‚å…¶åç§°ä¸º å¼•ç”¨è®¡æ•°ï¼ˆreference countingï¼‰çš„ç¼©å†™ã€‚å¼•ç”¨è®¡æ•°æ„å‘³ç€è®°å½•ä¸€ä¸ªå€¼å¼•ç”¨çš„æ•°é‡æ¥çŸ¥æ™“è¿™ä¸ªå€¼æ˜¯å¦ä»åœ¨è¢«ä½¿ç”¨ã€‚å¦‚æœæŸä¸ªå€¼æœ‰é›¶ä¸ªå¼•ç”¨ï¼Œå°±ä»£è¡¨æ²¡æœ‰ä»»ä½•æœ‰æ•ˆå¼•ç”¨å¹¶å¯ä»¥è¢«æ¸…ç†ã€‚

å¯ä»¥å°†å…¶æƒ³è±¡ä¸ºå®¢å…ä¸­çš„ç”µè§†ã€‚å½“ä¸€ä¸ªäººè¿›æ¥çœ‹ç”µè§†æ—¶ï¼Œä»–æ‰“å¼€ç”µè§†ã€‚å…¶ä»–äººä¹Ÿå¯ä»¥è¿›æ¥çœ‹ç”µè§†ã€‚å½“æœ€åä¸€ä¸ªäººç¦»å¼€æˆ¿é—´æ—¶ï¼Œä»–å…³æ‰ç”µè§†å› ä¸ºå®ƒä¸å†è¢«ä½¿ç”¨äº†ã€‚å¦‚æœæŸäººåœ¨å…¶ä»–äººè¿˜åœ¨çœ‹çš„æ—¶å€™å°±å…³æ‰äº†ç”µè§†ï¼Œæ­£åœ¨çœ‹ç”µè§†çš„äººè‚¯å®šä¼šæŠ“ç‹‚çš„ï¼

`Rc<T>` ç”¨äºå½“å¸Œæœ›åœ¨å †ä¸Šåˆ†é…ä¸€äº›å†…å­˜ä¾›ç¨‹åºçš„å¤šä¸ªéƒ¨åˆ†è¯»å–ï¼Œè€Œä¸”æ— æ³•åœ¨ç¼–è¯‘æ—¶ç¡®å®šç¨‹åºçš„å“ªä¸€éƒ¨åˆ†ä¼šæœ€åç»“æŸä½¿ç”¨å®ƒçš„æ—¶å€™ã€‚å¦‚æœç¡®å®çŸ¥é“å“ªéƒ¨åˆ†æ˜¯æœ€åä¸€ä¸ªç»“æŸä½¿ç”¨çš„è¯ï¼Œå°±å¯ä»¥ä»¤å…¶æˆä¸ºæ•°æ®çš„æ‰€æœ‰è€…åŒæ—¶ï¼Œæ­£å¸¸çš„æ‰€æœ‰æƒè§„åˆ™å°±å¯ä»¥åœ¨ç¼–è¯‘æ—¶ç”Ÿæ•ˆã€‚

*æ³¨æ„ `Rc<T>` åªèƒ½ç”¨äºå•çº¿ç¨‹åœºæ™¯ï¼›*

##### ä½¿ç”¨ Rc<T> å…±äº«æ•°æ®

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5,
        Box::new(Cons(10,
            Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}

```

ç¼–è¯‘ä¼šå¾—å‡ºå¦‚ä¸‹é”™è¯¯ï¼š

```rust
error[E0382]: use of moved value: `a`
  --> src/main.rs:13:30
   |
12 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
13 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move
   |
   = note: move occurs because `a` has type `List`, which does not implement
   the `Copy` trait

```

Cons æˆå‘˜æ‹¥æœ‰å…¶å‚¨å­˜çš„æ•°æ®ï¼Œæ‰€ä»¥å½“åˆ›å»º b åˆ—è¡¨æ—¶ï¼Œa è¢«ç§»åŠ¨è¿›äº† b è¿™æ · b å°±æ‹¥æœ‰äº† aã€‚æ¥ç€å½“å†æ¬¡å°ä½¿ç”¨ a åˆ›å»º c æ—¶ï¼Œè¿™ä¸è¢«å…è®¸å› ä¸º a çš„æ‰€æœ‰æƒå·²ç»è¢«ç§»åŠ¨ã€‚

å¯ä»¥æ”¹å˜ Cons çš„å®šä¹‰æ¥å­˜æ”¾ä¸€ä¸ªå¼•ç”¨ï¼Œä¸è¿‡æ¥ç€å¿…é¡»æŒ‡å®šç”Ÿå‘½å‘¨æœŸå‚æ•°ã€‚é€šè¿‡æŒ‡å®šç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œè¡¨æ˜åˆ—è¡¨ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ éƒ½è‡³å°‘ä¸åˆ—è¡¨æœ¬èº«å­˜åœ¨çš„ä¸€æ ·ä¹…ã€‚ä¾‹å¦‚ï¼Œå€Ÿç”¨æ£€æŸ¥å™¨ä¸ä¼šå…è®¸ let a = Cons(10, &Nil); ç¼–è¯‘ï¼Œå› ä¸ºä¸´æ—¶å€¼ Nil ä¼šåœ¨ a è·å–å…¶å¼•ç”¨ä¹‹å‰å°±è¢«ä¸¢å¼ƒäº†ã€‚

ç›¸åï¼Œä¿®æ”¹ List çš„å®šä¹‰ä¸ºä½¿ç”¨ Rc<T> ä»£æ›¿ Box<T>ï¼Œå¦‚åˆ—è¡¨ 15-18 æ‰€ç¤ºã€‚ç°åœ¨æ¯ä¸€ä¸ª Cons å˜é‡éƒ½åŒ…å«ä¸€ä¸ªå€¼å’Œä¸€ä¸ªæŒ‡å‘ List çš„ Rcã€‚å½“åˆ›å»º b æ—¶ï¼Œä¸åŒäºè·å– a çš„æ‰€æœ‰æƒï¼Œè¿™é‡Œä¼šå…‹éš† a æ‰€åŒ…å«çš„ Rcï¼Œè¿™ä¼šå°†å¼•ç”¨è®¡æ•°ä» 1 å¢åŠ åˆ° 2 å¹¶å…è®¸ a å’Œ b å…±äº« Rc ä¸­æ•°æ®çš„æ‰€æœ‰æƒã€‚åˆ›å»º c æ—¶ä¹Ÿä¼šå…‹éš† aï¼Œè¿™ä¼šå°†å¼•ç”¨è®¡æ•°ä» 2 å¢åŠ ä¸º 3ã€‚æ¯æ¬¡è°ƒç”¨ Rc::cloneï¼ŒRc ä¸­æ•°æ®çš„å¼•ç”¨è®¡æ•°éƒ½ä¼šå¢åŠ ï¼Œç›´åˆ°æœ‰é›¶ä¸ªå¼•ç”¨ä¹‹å‰å…¶æ•°æ®éƒ½ä¸ä¼šè¢«æ¸…ç†ã€‚

```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&a));
    let c = Cons(4, Rc::clone(&a));
}

```

éœ€è¦ä½¿ç”¨ use è¯­å¥å°† `Rc<T>` å¼•å…¥ä½œç”¨åŸŸï¼Œå› ä¸ºå®ƒä¸åœ¨ prelude ä¸­ã€‚åœ¨ main ä¸­åˆ›å»ºäº†å­˜æ”¾ 5 å’Œ 10 çš„åˆ—è¡¨å¹¶å°†å…¶å­˜æ”¾åœ¨ a çš„æ–°çš„ `Rc<List>`ä¸­ã€‚æ¥ç€å½“åˆ›å»º b å’Œ c æ—¶ï¼Œè°ƒç”¨ Rc::clone å‡½æ•°å¹¶ä¼ é€’ a ä¸­ `Rc<List>` çš„å¼•ç”¨ä½œä¸ºå‚æ•°ã€‚

ä¹Ÿå¯ä»¥è°ƒç”¨ a.clone() è€Œä¸æ˜¯ Rc::clone(&a)ï¼Œä¸è¿‡åœ¨è¿™é‡Œ Rust çš„ä¹ æƒ¯æ˜¯ä½¿ç”¨ Rc::cloneã€‚Rc::clone çš„å®ç°å¹¶ä¸åƒå¤§éƒ¨åˆ†ç±»å‹çš„ clone å®ç°é‚£æ ·å¯¹æ‰€æœ‰æ•°æ®è¿›è¡Œæ·±æ‹·è´ã€‚Rc::clone åªä¼šå¢åŠ å¼•ç”¨è®¡æ•°ï¼Œè¿™å¹¶ä¸ä¼šèŠ±è´¹å¤šå°‘æ—¶é—´ã€‚æ·±æ‹·è´å¯èƒ½ä¼šèŠ±è´¹å¾ˆé•¿æ—¶é—´ã€‚é€šè¿‡ä½¿ç”¨ Rc::clone è¿›è¡Œå¼•ç”¨è®¡æ•°ï¼Œå¯ä»¥æ˜æ˜¾çš„åŒºåˆ«æ·±æ‹·è´ç±»çš„å…‹éš†å’Œå¢åŠ å¼•ç”¨è®¡æ•°ç±»çš„å…‹éš†ã€‚å½“æŸ¥æ‰¾ä»£ç ä¸­çš„æ€§èƒ½é—®é¢˜æ—¶ï¼Œåªéœ€è€ƒè™‘æ·±æ‹·è´ç±»çš„å…‹éš†è€Œæ— éœ€è€ƒè™‘ Rc::clone è°ƒç”¨ã€‚

##### å…‹éš† Rc<T> ä¼šå¢åŠ å¼•ç”¨è®¡æ•°

```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&a));
    let b = Cons(3, Rc::clone(&a));
    println!("count after creating b = {}", Rc::strong_count(&a));
    {
        let c = Cons(4, Rc::clone(&a));
        println!("count after creating c = {}", Rc::strong_count(&a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&a));
}

```

åœ¨ç¨‹åºä¸­æ¯ä¸ªå¼•ç”¨è®¡æ•°å˜åŒ–çš„ç‚¹ï¼Œä¼šæ‰“å°å‡ºå¼•ç”¨è®¡æ•°ï¼Œå…¶å€¼å¯ä»¥é€šè¿‡è°ƒç”¨ Rc::strong_count å‡½æ•°è·å¾—ã€‚è¿™ä¸ªå‡½æ•°å«åš strong_count è€Œä¸æ˜¯ count æ˜¯å› ä¸º `Rc<T>` ä¹Ÿæœ‰ weak_countï¼›åœ¨ â€œé¿å…å¼•ç”¨å¾ªç¯ï¼šå°† `Rc<T>` å˜ä¸º `Weak<T>`â€ éƒ¨åˆ†ä¼šè®²è§£ weak_count çš„ç”¨é€”ã€‚

```
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
```

èƒ½å¤Ÿçœ‹åˆ° a ä¸­ `Rc<List>` çš„åˆå§‹å¼•ç”¨è®¡æ•°ä¸ºä¸€ï¼Œæ¥ç€æ¯æ¬¡è°ƒç”¨ cloneï¼Œè®¡æ•°ä¼šå¢åŠ ä¸€ã€‚å½“ c ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œè®¡æ•°å‡ä¸€ã€‚ä¸å¿…åƒè°ƒç”¨ Rc::clone å¢åŠ å¼•ç”¨è®¡æ•°é‚£æ ·è°ƒç”¨ä¸€ä¸ªå‡½æ•°æ¥å‡å°‘è®¡æ•°ï¼›Drop trait çš„å®ç°å½“ `Rc<T>` å€¼ç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨å‡å°‘å¼•ç”¨è®¡æ•°ã€‚

ä»è¿™ä¸ªä¾‹å­æ‰€ä¸èƒ½çœ‹åˆ°çš„æ˜¯åœ¨ main çš„ç»“å°¾å½“ b ç„¶åæ˜¯ a ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œæ­¤å¤„è®¡æ•°ä¼šæ˜¯ 0ï¼ŒåŒæ—¶ Rc è¢«å®Œå…¨æ¸…ç†ã€‚ä½¿ç”¨ Rc å…è®¸ä¸€ä¸ªå€¼æœ‰å¤šä¸ªæ‰€æœ‰è€…ï¼Œå¼•ç”¨è®¡æ•°åˆ™ç¡®ä¿åªè¦ä»»ä½•æ‰€æœ‰è€…ä¾ç„¶å­˜åœ¨å…¶å€¼ä¹Ÿä¿æŒæœ‰æ•ˆã€‚

é€šè¿‡ä¸å¯å˜å¼•ç”¨ï¼Œ `Rc<T>` å…è®¸åœ¨ç¨‹åºçš„å¤šä¸ªéƒ¨åˆ†ä¹‹é—´åªè¯»åœ°å…±äº«æ•°æ®ã€‚å¦‚æœ `Rc<T>` ä¹Ÿå…è®¸å¤šä¸ªå¯å˜å¼•ç”¨ï¼Œåˆ™ä¼šè¿åç¬¬å››ç« è®¨è®ºçš„å€Ÿç”¨è§„åˆ™ä¹‹ä¸€ï¼šç›¸åŒä½ç½®çš„å¤šä¸ªå¯å˜å€Ÿç”¨å¯èƒ½é€ æˆæ•°æ®ç«äº‰å’Œä¸ä¸€è‡´ã€‚ä¸è¿‡å¯ä»¥ä¿®æ”¹æ•°æ®æ˜¯éå¸¸æœ‰ç”¨çš„ï¼åœ¨ä¸‹ä¸€éƒ¨åˆ†ï¼Œå°†è®¨è®ºå†…éƒ¨å¯å˜æ€§æ¨¡å¼å’Œ `RefCell<T>` ç±»å‹ï¼Œå®ƒå¯ä»¥ä¸ `Rc<T>` ç»“åˆä½¿ç”¨æ¥å¤„ç†ä¸å¯å˜æ€§çš„é™åˆ¶ã€‚

#### RefCell<T> å’Œå†…éƒ¨å¯å˜æ€§æ¨¡å¼

**å†…éƒ¨å¯å˜æ€§ï¼ˆInterior mutabilityï¼‰**æ˜¯ Rust ä¸­çš„ä¸€ä¸ªè®¾è®¡æ¨¡å¼ï¼Œå®ƒå…è®¸å³ä½¿åœ¨æœ‰ä¸å¯å˜å¼•ç”¨æ—¶æ”¹å˜æ•°æ®ï¼Œè¿™é€šå¸¸æ˜¯å€Ÿç”¨è§„åˆ™æ‰€ä¸å…è®¸çš„ã€‚ä¸ºäº†æ”¹å˜æ•°æ®ï¼Œè¯¥æ¨¡å¼åœ¨æ•°æ®ç»“æ„ä¸­ä½¿ç”¨ unsafe ä»£ç æ¥æ¨¡ç³Š Rust é€šå¸¸çš„å¯å˜æ€§å’Œå€Ÿç”¨è§„åˆ™ã€‚è¿˜æœªè®²åˆ°ä¸å®‰å…¨ä»£ç ï¼›ç¬¬åä¹ç« ä¼šå­¦ä¹ å®ƒä»¬ã€‚å½“å¯ä»¥ç¡®ä¿ä»£ç åœ¨è¿è¡Œæ—¶ä¼šéµå®ˆå€Ÿç”¨è§„åˆ™ï¼Œå³ä½¿ç¼–è¯‘å™¨ä¸èƒ½ä¿è¯çš„æƒ…å†µï¼Œå¯ä»¥é€‰æ‹©ä½¿ç”¨é‚£äº›è¿ç”¨å†…éƒ¨å¯å˜æ€§æ¨¡å¼çš„ç±»å‹ã€‚æ‰€æ¶‰åŠçš„ unsafe ä»£ç å°†è¢«å°è£…è¿›å®‰å…¨çš„ API ä¸­ï¼Œè€Œå¤–éƒ¨ç±»å‹ä»ç„¶æ˜¯ä¸å¯å˜çš„ã€‚

##### é€šè¿‡ RefCell<T> åœ¨è¿è¡Œæ—¶æ£€æŸ¥å€Ÿç”¨è§„åˆ™

ä¸åŒäº `Rc<T>`ï¼Œ`RefCell<T>` ä»£è¡¨å…¶æ•°æ®çš„å”¯ä¸€çš„æ‰€æœ‰æƒã€‚

* åœ¨ä»»æ„ç»™å®šæ—¶é—´ï¼Œåªèƒ½æ‹¥æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨æˆ–ä»»æ„æ•°é‡çš„ä¸å¯å˜å¼•ç”¨ ä¹‹ä¸€ï¼ˆè€Œä¸æ˜¯å…¨éƒ¨ï¼‰ã€‚
* å¼•ç”¨å¿…é¡»æ€»æ˜¯æœ‰æ•ˆçš„ã€‚

å¯¹äºå¼•ç”¨å’Œ `Box<T>`ï¼Œå€Ÿç”¨è§„åˆ™çš„ä¸å¯å˜æ€§ä½œç”¨äºç¼–è¯‘æ—¶ã€‚å¯¹äº `RefCell<T>`ï¼Œè¿™äº›ä¸å¯å˜æ€§ä½œç”¨äº è¿è¡Œæ—¶ã€‚å¯¹äºå¼•ç”¨ï¼Œå¦‚æœè¿åè¿™äº›è§„åˆ™ï¼Œä¼šå¾—åˆ°ä¸€ä¸ªç¼–è¯‘é”™è¯¯ã€‚è€Œå¯¹äº `RefCell<T>`ï¼Œå¦‚æœè¿åè¿™äº›è§„åˆ™ç¨‹åºä¼š panic å¹¶é€€å‡ºã€‚

åœ¨ç¼–è¯‘æ—¶æ£€æŸ¥å€Ÿç”¨è§„åˆ™çš„ä¼˜åŠ¿æ˜¯è¿™äº›é”™è¯¯å°†åœ¨å¼€å‘è¿‡ç¨‹çš„æ—©æœŸè¢«æ•è·åŒæ—¶å¯¹æ²¡æœ‰è¿è¡Œæ—¶æ€§èƒ½å½±å“ï¼Œå› ä¸ºæ‰€æœ‰çš„åˆ†æéƒ½æå‰å®Œæˆäº†ã€‚ä¸ºæ­¤ï¼Œåœ¨ç¼–è¯‘æ—¶æ£€æŸ¥å€Ÿç”¨è§„åˆ™æ˜¯å¤§éƒ¨åˆ†æƒ…å†µçš„æœ€ä½³é€‰æ‹©ï¼Œè¿™ä¹Ÿæ­£æ˜¯å…¶ä¸ºä½•æ˜¯ Rust çš„é»˜è®¤è¡Œä¸ºã€‚

ç›¸ååœ¨è¿è¡Œæ—¶æ£€æŸ¥å€Ÿç”¨è§„åˆ™çš„å¥½å¤„åˆ™æ˜¯å…è®¸å‡ºç°ç‰¹å®šå†…å­˜å®‰å…¨çš„åœºæ™¯ï¼Œè€Œå®ƒä»¬åœ¨ç¼–è¯‘æ—¶æ£€æŸ¥ä¸­æ˜¯ä¸å…è®¸çš„ã€‚é™æ€åˆ†æï¼Œæ­£å¦‚ Rust ç¼–è¯‘å™¨ï¼Œæ˜¯å¤©ç”Ÿä¿å®ˆçš„ã€‚ä½†ä»£ç çš„ä¸€äº›å±æ€§ä¸å¯èƒ½é€šè¿‡åˆ†æä»£ç å‘ç°ï¼šå…¶ä¸­æœ€è‘—åçš„å°±æ˜¯ åœæœºé—®é¢˜ï¼ˆHalting Problemï¼‰ï¼Œè¿™è¶…å‡ºäº†æœ¬ä¹¦çš„èŒƒç•´ï¼Œä¸è¿‡å¦‚æœæ„Ÿå…´è¶£çš„è¯è¿™æ˜¯ä¸€ä¸ªå€¼å¾—ç ”ç©¶çš„æœ‰è¶£ä¸»é¢˜ã€‚

å› ä¸ºä¸€äº›åˆ†ææ˜¯ä¸å¯èƒ½çš„ï¼Œå¦‚æœ Rust ç¼–è¯‘å™¨ä¸èƒ½é€šè¿‡æ‰€æœ‰æƒè§„åˆ™ç¼–è¯‘ï¼Œå®ƒå¯èƒ½ä¼šæ‹’ç»ä¸€ä¸ªæ­£ç¡®çš„ç¨‹åºï¼›ä»è¿™ç§è§’åº¦è€ƒè™‘å®ƒæ˜¯ä¿å®ˆçš„ã€‚å¦‚æœ Rust æ¥å—ä¸æ­£ç¡®çš„ç¨‹åºï¼Œé‚£ä¹ˆç”¨æˆ·ä¹Ÿå°±ä¸ä¼šç›¸ä¿¡ Rust æ‰€åšçš„ä¿è¯äº†ã€‚ç„¶è€Œï¼Œå¦‚æœ Rust æ‹’ç»æ­£ç¡®çš„ç¨‹åºï¼Œè™½ç„¶ä¼šç»™ç¨‹åºå‘˜å¸¦æ¥ä¸ä¾¿ï¼Œä½†ä¸ä¼šå¸¦æ¥ç¾éš¾ã€‚`RefCell<T>` æ­£æ˜¯ç”¨äºå½“ç¡®ä¿¡ä»£ç éµå®ˆå€Ÿç”¨è§„åˆ™ï¼Œè€Œç¼–è¯‘å™¨ä¸èƒ½ç†è§£å’Œç¡®å®šçš„æ—¶å€™ã€‚

ç±»ä¼¼äº `Rc<T>`ï¼Œ`RefCell<T>` åªèƒ½ç”¨äºå•çº¿ç¨‹åœºæ™¯ã€‚å¦‚æœå°è¯•åœ¨å¤šçº¿ç¨‹ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨ `RefCell<T>`ï¼Œä¼šå¾—åˆ°ä¸€ä¸ªç¼–è¯‘é”™è¯¯ã€‚

å¦‚ä¸‹ä¸ºé€‰æ‹© `Box<T>`ï¼Œ`Rc<T>` æˆ– `RefCell<T>` çš„ç†ç”±ï¼š

* `Rc<T>` å…è®¸ç›¸åŒæ•°æ®æœ‰å¤šä¸ªæ‰€æœ‰è€…ï¼›`Box<T>` å’Œ `RefCell<T>` æœ‰å•ä¸€æ‰€æœ‰è€…ã€‚
* `Box<T>` å…è®¸åœ¨ç¼–è¯‘æ—¶æ‰§è¡Œä¸å¯å˜æˆ–å¯å˜å€Ÿç”¨æ£€æŸ¥ï¼›`Rc<T>`ä»…å…è®¸åœ¨ç¼–è¯‘æ—¶æ‰§è¡Œä¸å¯å˜å€Ÿç”¨æ£€æŸ¥ï¼›`RefCell<T>` å…è®¸åœ¨è¿è¡Œæ—¶æ‰§è¡Œä¸å¯å˜æˆ–å¯å˜å€Ÿç”¨æ£€æŸ¥ã€‚
* å› ä¸º `RefCell<T>` å…è®¸åœ¨è¿è¡Œæ—¶æ‰§è¡Œå¯å˜å€Ÿç”¨æ£€æŸ¥ï¼Œæ‰€ä»¥å¯ä»¥åœ¨å³ä¾¿ `RefCell<T>` è‡ªèº«æ˜¯ä¸å¯å˜çš„æƒ…å†µä¸‹ä¿®æ”¹å…¶å†…éƒ¨çš„å€¼ã€‚
* 
åœ¨ä¸å¯å˜å€¼å†…éƒ¨æ”¹å˜å€¼å°±æ˜¯ å†…éƒ¨å¯å˜æ€§ æ¨¡å¼ã€‚è®©çœ‹çœ‹ä½•æ—¶å†…éƒ¨å¯å˜æ€§æ˜¯æœ‰ç”¨çš„ï¼Œå¹¶è®¨è®ºè¿™æ˜¯å¦‚ä½•æˆä¸ºå¯èƒ½çš„ã€‚

##### å†…éƒ¨å¯å˜æ€§ï¼šä¸å¯å˜å€¼çš„å¯å˜å€Ÿç”¨

å†…éƒ¨å¯å˜æ€§çš„ç”¨ä¾‹ï¼šmock å¯¹è±¡
æµ‹è¯•æ›¿èº«ï¼ˆtest doubleï¼‰æ˜¯ä¸€ä¸ªé€šç”¨ç¼–ç¨‹æ¦‚å¿µï¼Œå®ƒä»£è¡¨ä¸€ä¸ªåœ¨æµ‹è¯•ä¸­æ›¿ä»£æŸä¸ªç±»å‹çš„ç±»å‹ã€‚mock å¯¹è±¡ æ˜¯ç‰¹å®šç±»å‹çš„æµ‹è¯•æ›¿èº«ï¼Œå®ƒä»¬è®°å½•æµ‹è¯•è¿‡ç¨‹ä¸­å‘ç”Ÿäº†ä»€ä¹ˆä»¥ä¾¿å¯ä»¥æ–­è¨€æ“ä½œæ˜¯æ­£ç¡®çš„ã€‚

è™½ç„¶ Rust æ²¡æœ‰ä¸å…¶ä»–è¯­è¨€ä¸­çš„å¯¹è±¡å®Œå…¨ç›¸åŒçš„å¯¹è±¡ï¼ŒRust ä¹Ÿæ²¡æœ‰åƒå…¶ä»–è¯­è¨€é‚£æ ·åœ¨æ ‡å‡†åº“ä¸­å†…å»º mock å¯¹è±¡åŠŸèƒ½ï¼Œä¸è¿‡ç¡®å®å¯ä»¥åˆ›å»ºä¸€ä¸ªä¸ mock å¯¹è±¡æœ‰ç€ç›¸åŒåŠŸèƒ½çš„ç»“æ„ä½“ã€‚

å¦‚ä¸‹æ˜¯ä¸€ä¸ªæƒ³è¦æµ‹è¯•çš„åœºæ™¯ï¼šåœ¨ç¼–å†™ä¸€ä¸ªè®°å½•æŸä¸ªå€¼ä¸æœ€å¤§å€¼çš„å·®è·çš„åº“ï¼Œå¹¶æ ¹æ®å½“å‰å€¼ä¸æœ€å¤§å€¼çš„å·®è·æ¥å‘é€æ¶ˆæ¯ã€‚ä¾‹å¦‚ï¼Œè¿™ä¸ªåº“å¯ä»¥ç”¨äºè®°å½•ç”¨æˆ·æ‰€å…è®¸çš„ API è°ƒç”¨æ•°é‡é™é¢ã€‚

è¯¥åº“åªæä¾›è®°å½•ä¸æœ€å¤§å€¼çš„å·®è·ï¼Œä»¥åŠä½•ç§æƒ…å†µå‘é€ä»€ä¹ˆæ¶ˆæ¯çš„åŠŸèƒ½ã€‚ä½¿ç”¨æ­¤åº“çš„ç¨‹åºåˆ™æœŸæœ›æä¾›å®é™…å‘é€æ¶ˆæ¯çš„æœºåˆ¶ï¼šç¨‹åºå¯ä»¥é€‰æ‹©è®°å½•ä¸€æ¡æ¶ˆæ¯ã€å‘é€ emailã€å‘é€çŸ­ä¿¡ç­‰ç­‰ã€‚åº“æœ¬èº«æ— éœ€çŸ¥é“è¿™äº›ç»†èŠ‚ï¼›åªéœ€å®ç°å…¶æä¾›çš„ Messenger trait å³å¯ã€‚

```rust

#![allow(unused_variables)]
fn main() {
pub trait Messenger {
    fn send(&self, msg: &str);
}

pub struct LimitTracker<'a, T: Messenger> {
    messenger: &'a T,
    value: usize,
    max: usize,
}

impl<'a, T> LimitTracker<'a, T>
    where T: Messenger {
    pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max >= 1.0 {
            self.messenger.send("Error: You are over your quota!");
        } else if percentage_of_max >= 0.9 {
             self.messenger.send("Urgent warning: You've used up over 90% of your quota!");
        } else if percentage_of_max >= 0.75 {
            self.messenger.send("Warning: You've used up over 75% of your quota!");
        }
    }
}
}
```

è¿™äº›ä»£ç ä¸­ä¸€ä¸ªé‡è¦éƒ¨åˆ†æ˜¯æ‹¥æœ‰ä¸€ä¸ªæ–¹æ³• send çš„ Messenger traitï¼Œå…¶è·å–ä¸€ä¸ª self çš„ä¸å¯å˜å¼•ç”¨å’Œæ–‡æœ¬ä¿¡æ¯ã€‚è¿™æ˜¯çš„ mock å¯¹è±¡æ‰€éœ€è¦æ‹¥æœ‰çš„æ¥å£ã€‚å¦ä¸€ä¸ªé‡è¦çš„éƒ¨åˆ†æ˜¯éœ€è¦æµ‹è¯• LimitTracker çš„ set_value æ–¹æ³•çš„è¡Œä¸ºã€‚å¯ä»¥æ”¹å˜ä¼ é€’çš„ value å‚æ•°çš„å€¼ï¼Œä¸è¿‡ set_value å¹¶æ²¡æœ‰è¿”å›ä»»ä½•å¯ä¾›æ–­è¨€çš„å€¼ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœä½¿ç”¨æŸä¸ªå®ç°äº† Messenger trait çš„å€¼å’Œç‰¹å®šçš„ max åˆ›å»º LimitTrackerï¼Œå½“ä¼ é€’ä¸åŒ value å€¼æ—¶ï¼Œæ¶ˆæ¯å‘é€è€…åº”è¢«å‘ŠçŸ¥å‘é€åˆé€‚çš„æ¶ˆæ¯ã€‚

æ‰€éœ€çš„ mock å¯¹è±¡æ˜¯ï¼Œè°ƒç”¨ send ä¸åŒäºå®é™…å‘é€ email æˆ–çŸ­æ¯ï¼Œå…¶åªè®°å½•ä¿¡æ¯è¢«é€šçŸ¥è¦å‘é€äº†ã€‚å¯ä»¥æ–°å»ºä¸€ä¸ª mock å¯¹è±¡ç¤ºä¾‹ï¼Œç”¨å…¶åˆ›å»º LimitTrackerï¼Œè°ƒç”¨ LimitTracker çš„ set_value æ–¹æ³•ï¼Œç„¶åæ£€æŸ¥ mock å¯¹è±¡æ˜¯å¦æœ‰æœŸæœ›çš„æ¶ˆæ¯ã€‚ä¸‹ä¾‹å±•ç¤ºäº†ä¸€ä¸ªå¦‚æ­¤å°è¯•çš„ mock å¯¹è±¡å®ç°ï¼Œä¸è¿‡å€Ÿç”¨æ£€æŸ¥å™¨å¹¶ä¸å…è®¸ï¼š

```rust
#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec<String>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger { sent_messages: vec![] }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}

```

æµ‹è¯•ä»£ç å®šä¹‰äº†ä¸€ä¸ª MockMessenger ç»“æ„ä½“ï¼Œå…¶ sent_messages å­—æ®µä¸ºä¸€ä¸ª String å€¼çš„ Vec ç”¨æ¥è®°å½•è¢«å‘ŠçŸ¥å‘é€çš„æ¶ˆæ¯ã€‚è¿˜å®šä¹‰äº†ä¸€ä¸ªå…³è”å‡½æ•° new ä»¥ä¾¿äºæ–°å»ºä»ç©ºæ¶ˆæ¯åˆ—è¡¨å¼€å§‹çš„ MockMessenger å€¼ã€‚æ¥ç€ä¸º MockMessenger å®ç° Messenger trait è¿™æ ·å°±å¯ä»¥ä¸º LimitTracker æä¾›ä¸€ä¸ª MockMessengerã€‚åœ¨ send æ–¹æ³•çš„å®šä¹‰ä¸­ï¼Œè·å–ä¼ å…¥çš„æ¶ˆæ¯ä½œä¸ºå‚æ•°å¹¶å‚¨å­˜åœ¨ MockMessenger çš„ sent_messages åˆ—è¡¨ä¸­ã€‚

åœ¨æµ‹è¯•ä¸­ï¼Œæµ‹è¯•äº†å½“ LimitTracker è¢«å‘ŠçŸ¥å°† value è®¾ç½®ä¸ºè¶…è¿‡ max å€¼ 75% çš„æŸä¸ªå€¼ã€‚é¦–å…ˆæ–°å»ºä¸€ä¸ª MockMessengerï¼Œå…¶ä»ç©ºæ¶ˆæ¯åˆ—è¡¨å¼€å§‹ã€‚æ¥ç€æ–°å»ºä¸€ä¸ª LimitTracker å¹¶ä¼ é€’æ–°å»º MockMessenger çš„å¼•ç”¨å’Œ max å€¼ 100ã€‚ä½¿ç”¨å€¼ 80 è°ƒç”¨ LimitTracker çš„ set_value æ–¹æ³•ï¼Œè¿™è¶…è¿‡äº† 100 çš„ 75%ã€‚æ¥ç€æ–­è¨€ MockMessenger ä¸­è®°å½•çš„æ¶ˆæ¯åˆ—è¡¨åº”è¯¥æœ‰ä¸€æ¡æ¶ˆæ¯ã€‚

ç„¶è€Œï¼Œè¿™ä¸ªæµ‹è¯•æ˜¯æœ‰é—®é¢˜çš„ï¼š

```rust
error[E0596]: cannot borrow immutable field `self.sent_messages` as mutable
  --> src/lib.rs:52:13
   |
51 |         fn send(&self, message: &str) {
   |                 ----- use `&mut self` here to make mutable
52 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ cannot mutably borrow immutable field

```

ä¸èƒ½ä¿®æ”¹ MockMessenger æ¥è®°å½•æ¶ˆæ¯ï¼Œå› ä¸º send æ–¹æ³•è·å–äº† self çš„ä¸å¯å˜å¼•ç”¨ã€‚ä¹Ÿä¸èƒ½å‚è€ƒé”™è¯¯æ–‡æœ¬çš„å»ºè®®ä½¿ç”¨ &mut self æ›¿ä»£ï¼Œå› ä¸ºè¿™æ · send çš„ç­¾åå°±ä¸ç¬¦åˆ Messenger trait å®šä¹‰ä¸­çš„ç­¾åäº†ï¼ˆå¯ä»¥è¯•ç€è¿™ä¹ˆæ”¹ï¼Œçœ‹çœ‹ä¼šå‡ºç°ä»€ä¹ˆé”™è¯¯ä¿¡æ¯ï¼‰ã€‚

è¿™æ­£æ˜¯å†…éƒ¨å¯å˜æ€§çš„ç”¨æ­¦ä¹‹åœ°ï¼å°†é€šè¿‡ RefCell æ¥å‚¨å­˜ sent_messagesï¼Œç„¶å send å°†èƒ½å¤Ÿä¿®æ”¹ sent_messages å¹¶å‚¨å­˜æ¶ˆæ¯ã€‚

```rust
pub trait Messenger {
    fn send(&self, msg: &str);
}

pub struct LimitTracker<'a, T: Messenger> {
    messenger: &'a T,
    value: usize,
    max: usize,
}

impl<'a, T> LimitTracker<'a, T>
    where T: Messenger {
    pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max >= 1.0 {
            self.messenger.send("Error: You are over your quota!");
        } else if percentage_of_max >= 0.9 {
             self.messenger.send("Urgent warning: You've used up over 90% of your quota!");
        } else if percentage_of_max >= 0.75 {
            self.messenger.send("Warning: You've used up over 75% of your quota!");
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell<Vec<String>>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger { sent_messages: RefCell::new(vec![]) }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);
        limit_tracker.set_value(75);

        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}
fn main() {}

```

ç°åœ¨ sent_messages å­—æ®µçš„ç±»å‹æ˜¯ `RefCell<Vec<String>>` è€Œä¸æ˜¯ `Vec<String>`ã€‚åœ¨ new å‡½æ•°ä¸­æ–°å»ºäº†ä¸€ä¸ª RefCell ç¤ºä¾‹æ›¿ä»£ç©º vectorã€‚

å¯¹äº send æ–¹æ³•çš„å®ç°ï¼Œç¬¬ä¸€ä¸ªå‚æ•°ä»ä¸º self çš„ä¸å¯å˜å€Ÿç”¨ï¼Œè¿™æ˜¯ç¬¦åˆæ–¹æ³•å®šä¹‰çš„ã€‚è°ƒç”¨ self.sent_messages ä¸­ RefCell çš„ borrow_mut æ–¹æ³•æ¥è·å– RefCell ä¸­å€¼çš„å¯å˜å¼•ç”¨ï¼Œè¿™æ˜¯ä¸€ä¸ª vectorã€‚æ¥ç€å¯ä»¥å¯¹ vector çš„å¯å˜å¼•ç”¨è°ƒç”¨ push ä»¥ä¾¿è®°å½•æµ‹è¯•è¿‡ç¨‹ä¸­çœ‹åˆ°çš„æ¶ˆæ¯ã€‚

æœ€åå¿…é¡»åšå‡ºçš„ä¿®æ”¹ä½äºæ–­è¨€ä¸­ï¼šä¸ºäº†çœ‹åˆ°å…¶å†…éƒ¨ vector ä¸­æœ‰å¤šå°‘ä¸ªé¡¹ï¼Œéœ€è¦è°ƒç”¨ RefCell çš„ borrow ä»¥è·å– vector çš„ä¸å¯å˜å¼•ç”¨ã€‚

##### `RefCell<T>` åœ¨è¿è¡Œæ—¶è®°å½•å€Ÿç”¨

å½“åˆ›å»ºä¸å¯å˜å’Œå¯å˜å¼•ç”¨æ—¶ï¼Œåˆ†åˆ«ä½¿ç”¨ & å’Œ &mut è¯­æ³•ã€‚å¯¹äº `RefCell<T>` æ¥è¯´ï¼Œåˆ™æ˜¯ borrow å’Œ borrow_mut æ–¹æ³•ï¼Œè¿™å±äº `RefCell<T>` å®‰å…¨ API çš„ä¸€éƒ¨åˆ†ã€‚borrow æ–¹æ³•è¿”å› Ref ç±»å‹çš„æ™ºèƒ½æŒ‡é’ˆï¼Œborrow_mut æ–¹æ³•è¿”å› RefMut ç±»å‹çš„æ™ºèƒ½æŒ‡é’ˆã€‚è¿™ä¸¤ä¸ªç±»å‹éƒ½å®ç°äº† Derefï¼Œæ‰€ä»¥å¯ä»¥å½“ä½œå¸¸è§„å¼•ç”¨å¯¹å¾…ã€‚

`RefCell<T>` è®°å½•å½“å‰æœ‰å¤šå°‘ä¸ªæ´»åŠ¨çš„ `Ref<T>` å’Œ `RefMut<T>` æ™ºèƒ½æŒ‡é’ˆã€‚æ¯æ¬¡è°ƒç”¨ borrowï¼Œ`RefCell<T>` å°†æ´»åŠ¨çš„ä¸å¯å˜å€Ÿç”¨è®¡æ•°åŠ ä¸€ã€‚å½“ Ref å€¼ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œä¸å¯å˜å€Ÿç”¨è®¡æ•°å‡ä¸€ã€‚å°±åƒç¼–è¯‘æ—¶å€Ÿç”¨è§„åˆ™ä¸€æ ·ï¼Œ`RefCell<T>` åœ¨ä»»ä½•æ—¶å€™åªå…è®¸æœ‰å¤šä¸ªä¸å¯å˜å€Ÿç”¨æˆ–ä¸€ä¸ªå¯å˜å€Ÿç”¨ã€‚

å¦‚æœå°è¯•è¿åè¿™äº›è§„åˆ™ï¼Œç›¸æ¯”å¼•ç”¨æ—¶çš„ç¼–è¯‘æ—¶é”™è¯¯ï¼Œ`RefCell<T>` çš„å®ç°ä¼šåœ¨è¿è¡Œæ—¶ panic!ã€‚ä¸‹ä¾‹å±•ç¤ºäº†å¯¹ä¸Šä¾‹ä¸­ send å®ç°çš„ä¿®æ”¹ï¼Œè¿™é‡Œæ•…æ„å°è¯•åœ¨ç›¸åŒä½œç”¨åŸŸåˆ›å»ºä¸¤ä¸ªå¯å˜å€Ÿç”¨ä»¥ä¾¿æ¼”ç¤º `RefCell<T>` ä¸å…è®¸åœ¨è¿è¡Œæ—¶è¿™ä¹ˆåšï¼š

```rust
impl Messenger for MockMessenger {
    fn send(&self, message: &str) {
        let mut one_borrow = self.sent_messages.borrow_mut();
        let mut two_borrow = self.sent_messages.borrow_mut();

        one_borrow.push(String::from(message));
        two_borrow.push(String::from(message));
    }
}

```

è¿™é‡Œä¸º borrow_mut è¿”å›çš„ RefMut æ™ºèƒ½æŒ‡é’ˆåˆ›å»ºäº† one_borrow å˜é‡ã€‚æ¥ç€ç”¨ç›¸åŒçš„æ–¹å¼åœ¨å˜é‡ two_borrow åˆ›å»ºäº†å¦ä¸€ä¸ªå¯å˜å€Ÿç”¨ã€‚è¿™ä¼šåœ¨ç›¸åŒä½œç”¨åŸŸä¸­åˆ›å»ºä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œè¿™æ˜¯ä¸å…è®¸çš„ã€‚å½“è¿è¡Œåº“çš„æµ‹è¯•æ—¶ï¼Œç¤ºä¾‹ 15-23 ç¼–è¯‘æ—¶ä¸ä¼šæœ‰ä»»ä½•é”™è¯¯ï¼Œä¸è¿‡æµ‹è¯•ä¼šå¤±è´¥ï¼š

```rust
---- tests::it_sends_an_over_75_percent_warning_message stdout ----
	thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at
'already borrowed: BorrowMutError', src/libcore/result.rs:906:4
note: Run with `RUST_BACKTRACE=1` for a backtrace.

```

##### ç»“åˆ `Rc<T>` å’Œ `RefCell<T>` æ¥æ‹¥æœ‰å¤šä¸ªå¯å˜æ•°æ®æ‰€æœ‰è€…

`RefCell<T>` çš„ä¸€ä¸ªå¸¸è§ç”¨æ³•æ˜¯ä¸ `Rc<T>` ç»“åˆã€‚å›å¿†ä¸€ä¸‹ `Rc<T>` å…è®¸å¯¹ç›¸åŒæ•°æ®æœ‰å¤šä¸ªæ‰€æœ‰è€…ï¼Œä¸è¿‡åªèƒ½æä¾›æ•°æ®çš„ä¸å¯å˜è®¿é—®ã€‚å¦‚æœæœ‰ä¸€ä¸ªå‚¨å­˜äº† `RefCell<T>` çš„ `Rc<T>` çš„è¯ï¼Œå°±å¯ä»¥å¾—åˆ°æœ‰å¤šä¸ªæ‰€æœ‰è€… å¹¶ä¸” å¯ä»¥ä¿®æ”¹çš„å€¼äº†ï¼

```rust
#[derive(Debug)]
enum List {
    Cons(Rc<RefCell<i32>>, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&a));
    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&a));

    *value.borrow_mut() += 10;

    println!("a after = {:?}", a);
    println!("b after = {:?}", b);
    println!("c after = {:?}", c);
}

```

#### å¼•ç”¨å¾ªç¯ä¸å†…å­˜æ³„æ¼

Rust çš„å†…å­˜å®‰å…¨ä¿è¯ä½¿å…¶éš¾ä»¥æ„å¤–åœ°åˆ¶é€ æ°¸è¿œä¹Ÿä¸ä¼šè¢«æ¸…ç†çš„å†…å­˜ï¼ˆè¢«ç§°ä¸º å†…å­˜æ³„éœ²ï¼ˆmemory leakï¼‰ï¼‰ï¼Œä½†å¹¶ä¸æ˜¯ä¸å¯èƒ½ã€‚ä¸åœ¨ç¼–è¯‘æ—¶æ‹’ç»æ•°æ®ç«äº‰ä¸åŒï¼Œ Rust å¹¶ä¸ä¿è¯å®Œå…¨åœ°é¿å…å†…å­˜æ³„éœ²ï¼Œè¿™æ„å‘³ç€å†…å­˜æ³„éœ²åœ¨ Rust è¢«è®¤ä¸ºæ˜¯å†…å­˜å®‰å…¨çš„ã€‚è¿™ä¸€ç‚¹å¯ä»¥é€šè¿‡ `Rc<T>` å’Œ `RefCell<T>` çœ‹å‡ºï¼šåˆ›å»ºå¼•ç”¨å¾ªç¯çš„å¯èƒ½æ€§æ˜¯å­˜åœ¨çš„ã€‚è¿™ä¼šé€ æˆå†…å­˜æ³„éœ²ï¼Œå› ä¸ºæ¯ä¸€é¡¹çš„å¼•ç”¨è®¡æ•°æ°¸è¿œä¹Ÿåˆ°ä¸äº† 0ï¼Œå…¶å€¼ä¹Ÿæ°¸è¿œä¹Ÿä¸ä¼šè¢«ä¸¢å¼ƒã€‚

##### åˆ¶é€ å¼•ç”¨å¾ªç¯

```rust
fn main() {}
use std::rc::Rc;
use std::cell::RefCell;
use crate::List::{Cons, Nil};

#[derive(Debug)]
enum List {
    Cons(i32, RefCell<Rc<List>>),
    Nil,
}

impl List {
    fn tail(&self) -> Option<&RefCell<Rc<List>>> {
        match self {
            Cons(_, item) => Some(item),
            Nil => None,
        }
    }
}

```

è¿™é‡Œé‡‡ç”¨äº†ä¸‹ä¾‹ä¸­ List å®šä¹‰çš„å¦ä¸€ç§å˜ä½“ã€‚ç°åœ¨ Cons æˆå‘˜çš„ç¬¬äºŒä¸ªå…ƒç´ æ˜¯ `RefCell<Rc<List>>`ï¼Œè¿™æ„å‘³ç€ä¸åŒäºåƒä¸Šä¾‹é‚£æ ·èƒ½å¤Ÿä¿®æ”¹ i32 çš„å€¼ï¼Œå¸Œæœ›èƒ½å¤Ÿä¿®æ”¹ Cons æˆå‘˜æ‰€æŒ‡å‘çš„ Listã€‚è¿™é‡Œè¿˜å¢åŠ äº†ä¸€ä¸ª tail æ–¹æ³•æ¥æ–¹ä¾¿åœ¨æœ‰ Cons æˆå‘˜çš„æ—¶å€™è®¿é—®å…¶ç¬¬äºŒé¡¹ã€‚

åœ¨ä¸‹ä¾‹ä¸­å¢åŠ äº†ä¸€ä¸ª main å‡½æ•°ï¼Œå…¶ä½¿ç”¨äº†ä¸Šä¾‹ä¸­çš„å®šä¹‰ã€‚è¿™äº›ä»£ç åœ¨ a ä¸­åˆ›å»ºäº†ä¸€ä¸ªåˆ—è¡¨ï¼Œä¸€ä¸ªæŒ‡å‘ a ä¸­åˆ—è¡¨çš„ b åˆ—è¡¨ï¼Œæ¥ç€ä¿®æ”¹ b ä¸­çš„åˆ—è¡¨æŒ‡å‘ a ä¸­çš„åˆ—è¡¨ï¼Œè¿™ä¼šåˆ›å»ºä¸€ä¸ªå¼•ç”¨å¾ªç¯ã€‚åœ¨è¿™ä¸ªè¿‡ç¨‹çš„å¤šä¸ªä½ç½®æœ‰ println! è¯­å¥å±•ç¤ºå¼•ç”¨è®¡æ•°ã€‚

```rust
use crate::List::{Cons, Nil};
use std::rc::Rc;
use std::cell::RefCell;
#[derive(Debug)]
enum List {
    Cons(i32, RefCell<Rc<List>>),
    Nil,
}

impl List {
    fn tail(&self) -> Option<&RefCell<Rc<List>>> {
        match self {
            Cons(_, item) => Some(item),
            Nil => None,
        }
    }
}

fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!("a initial rc count = {}", Rc::strong_count(&a));
    println!("a next item = {:?}", a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));

    println!("a rc count after b creation = {}", Rc::strong_count(&a));
    println!("b initial rc count = {}", Rc::strong_count(&b));
    println!("b next item = {:?}", b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&b);
    }

    println!("b rc count after changing a = {}", Rc::strong_count(&b));
    println!("a rc count after changing a = {}", Rc::strong_count(&a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack
    // println!("a next item = {:?}", a.tail());
}

```

è¿™é‡Œåœ¨å˜é‡ a ä¸­åˆ›å»ºäº†ä¸€ä¸ª `Rc<List>` å®ä¾‹æ¥å­˜æ”¾åˆå€¼ä¸º 5, Nil çš„ List å€¼ã€‚æ¥ç€åœ¨å˜é‡ b ä¸­åˆ›å»ºäº†å­˜æ”¾åŒ…å«å€¼ 10 å’ŒæŒ‡å‘åˆ—è¡¨ a çš„ List çš„å¦ä¸€ä¸ª `Rc<List>` å®ä¾‹ã€‚

æœ€åï¼Œä¿®æ”¹ a ä½¿å…¶æŒ‡å‘ b è€Œä¸æ˜¯ Nilï¼Œè¿™å°±åˆ›å»ºäº†ä¸€ä¸ªå¾ªç¯ã€‚ä¸ºæ­¤éœ€è¦ä½¿ç”¨ tail æ–¹æ³•è·å– a ä¸­ `RefCell<Rc<List>>` çš„å¼•ç”¨ï¼Œå¹¶æ”¾å…¥å˜é‡ link ä¸­ã€‚æ¥ç€ä½¿ç”¨ `RefCell<Rc<List>>` çš„ borrow_mut æ–¹æ³•å°†å…¶å€¼ä»å­˜æ”¾ Nil çš„ Rc ä¿®æ”¹ä¸º b ä¸­çš„ `Rc<List>`ã€‚

##### é¿å…å¼•ç”¨å¾ªç¯ï¼šå°† Rc<T> å˜ä¸º Weak<T>

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œå·²ç»å±•ç¤ºäº†è°ƒç”¨ Rc::clone ä¼šå¢åŠ  `Rc<T>` å®ä¾‹çš„ strong_countï¼Œå’Œåªåœ¨å…¶ strong_count ä¸º 0 æ—¶æ‰ä¼šè¢«æ¸…ç†çš„ `Rc<T>` å®ä¾‹ã€‚ä¹Ÿå¯ä»¥é€šè¿‡è°ƒç”¨ Rc::downgrade å¹¶ä¼ é€’ Rc å®ä¾‹çš„å¼•ç”¨æ¥åˆ›å»ºå…¶å€¼çš„ å¼±å¼•ç”¨ï¼ˆweak referenceï¼‰ã€‚è°ƒç”¨ Rc::downgrade æ—¶ä¼šå¾—åˆ° `Weak<T>` ç±»å‹çš„æ™ºèƒ½æŒ‡é’ˆã€‚ä¸åŒäºå°† `Rc<T>` å®ä¾‹çš„ strong_count åŠ ä¸€ï¼Œè°ƒç”¨ Rc::downgrade ä¼šå°† weak_count åŠ ä¸€ã€‚`Rc<T>` ç±»å‹ä½¿ç”¨ weak_count æ¥è®°å½•å…¶å­˜åœ¨å¤šå°‘ä¸ª `Weak<T>` å¼•ç”¨ï¼Œç±»ä¼¼äº strong_countã€‚å…¶åŒºåˆ«åœ¨äº weak_count æ— éœ€è®¡æ•°ä¸º 0 å°±èƒ½ä½¿ Rc å®ä¾‹è¢«æ¸…ç†ã€‚

å¼ºå¼•ç”¨ä»£è¡¨å¦‚ä½•å…±äº« `Rc<T>` å®ä¾‹çš„æ‰€æœ‰æƒï¼Œä½†å¼±å¼•ç”¨å¹¶ä¸å±äºæ‰€æœ‰æƒå…³ç³»ã€‚ä»–ä»¬ä¸ä¼šé€ æˆå¼•ç”¨å¾ªç¯ï¼Œå› ä¸ºä»»ä½•å¼±å¼•ç”¨çš„å¾ªç¯ä¼šåœ¨å…¶ç›¸å…³çš„å¼ºå¼•ç”¨è®¡æ•°ä¸º 0 æ—¶è¢«æ‰“æ–­ã€‚

å› ä¸º `Weak<T>` å¼•ç”¨çš„å€¼å¯èƒ½å·²ç»è¢«ä¸¢å¼ƒäº†ï¼Œä¸ºäº†ä½¿ç”¨ `Weak<T>` æ‰€æŒ‡å‘çš„å€¼ï¼Œå¿…é¡»ç¡®ä¿å…¶å€¼ä»ç„¶æœ‰æ•ˆã€‚ä¸ºæ­¤å¯ä»¥è°ƒç”¨ `Weak<T>` å®ä¾‹çš„ upgrade æ–¹æ³•ï¼Œè¿™ä¼šè¿”å› `Option<Rc<T>>`ã€‚å¦‚æœ `Rc<T>` å€¼è¿˜æœªè¢«ä¸¢å¼ƒï¼Œåˆ™ç»“æœæ˜¯ Someï¼›å¦‚æœ `Rc<T>` å·²è¢«ä¸¢å¼ƒï¼Œåˆ™ç»“æœæ˜¯ Noneã€‚å› ä¸º upgrade è¿”å›ä¸€ä¸ª `Option<T>`ï¼Œç¡®ä¿¡ Rust ä¼šå¤„ç† Some å’Œ None çš„æƒ…å†µï¼Œæ‰€ä»¥å®ƒä¸ä¼šè¿”å›éæ³•æŒ‡é’ˆã€‚

ä¼šåˆ›å»ºä¸€ä¸ªæŸé¡¹çŸ¥é“å…¶å­é¡¹å’Œçˆ¶é¡¹çš„æ ‘å½¢ç»“æ„çš„ä¾‹å­ï¼Œè€Œä¸æ˜¯åªçŸ¥é“å…¶ä¸‹ä¸€é¡¹çš„åˆ—è¡¨ã€‚

###### åˆ›å»ºæ ‘å½¢æ•°æ®ç»“æ„ï¼šå¸¦æœ‰å­ç»“ç‚¹çš„ Node

```rust

#![allow(unused_variables)]
fn main() {
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell<Vec<Rc<Node>>>,
}
}
```

å¸Œæœ›èƒ½å¤Ÿ Node æ‹¥æœ‰å…¶å­ç»“ç‚¹ï¼ŒåŒæ—¶ä¹Ÿå¸Œæœ›é€šè¿‡å˜é‡æ¥å…±äº«æ‰€æœ‰æƒï¼Œä»¥ä¾¿å¯ä»¥ç›´æ¥è®¿é—®æ ‘ä¸­çš„æ¯ä¸€ä¸ª Nodeï¼Œä¸ºæ­¤ `Vec<T>` çš„é¡¹çš„ç±»å‹è¢«å®šä¹‰ä¸º `Rc<Node>`ã€‚è¿˜å¸Œæœ›èƒ½ä¿®æ”¹å…¶ä»–ç»“ç‚¹çš„å­ç»“ç‚¹ï¼Œæ‰€ä»¥ children ä¸­ `Vec<Rc<Node>>` è¢«æ”¾è¿›äº† `RefCell<T>`ã€‚

æ¥ä¸‹æ¥ï¼Œä½¿ç”¨æ­¤ç»“æ„ä½“å®šä¹‰æ¥åˆ›å»ºä¸€ä¸ªå«åš leaf çš„å¸¦æœ‰å€¼ 3 ä¸”æ²¡æœ‰å­ç»“ç‚¹çš„ Node å®ä¾‹ï¼Œå’Œå¦ä¸€ä¸ªå¸¦æœ‰å€¼ 5 å¹¶ä»¥ leaf ä½œä¸ºå­ç»“ç‚¹çš„å®ä¾‹ branchï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```rust
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
   children: RefCell<Vec<Rc<Node>>>,
}

fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });
}

```

```rust
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
   children: RefCell<Vec<Rc<Node>>>,
}

fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });
}

```

è¿™é‡Œå…‹éš†äº† leaf ä¸­çš„ `Rc<Node>` å¹¶å‚¨å­˜åœ¨äº† branch ä¸­ï¼Œè¿™æ„å‘³ç€ leaf ä¸­çš„ Node ç°åœ¨æœ‰ä¸¤ä¸ªæ‰€æœ‰è€…ï¼šleafå’Œbranchã€‚å¯ä»¥é€šè¿‡ branch.children ä» branch ä¸­è·å¾— leafï¼Œä¸è¿‡æ— æ³•ä» leaf åˆ° branchã€‚leaf æ²¡æœ‰åˆ° branch çš„å¼•ç”¨ä¸”å¹¶ä¸çŸ¥é“ä»–ä»¬ç›¸äº’å…³è”ã€‚å¸Œæœ› leaf çŸ¥é“ branch æ˜¯å…¶çˆ¶ç»“ç‚¹ã€‚ç¨åä¼šè¿™ä¹ˆåšã€‚

###### å¢åŠ ä»å­åˆ°çˆ¶çš„å¼•ç”¨

ä¸ºäº†ä½¿å­ç»“ç‚¹çŸ¥é“å…¶çˆ¶ç»“ç‚¹ï¼Œéœ€è¦åœ¨ Node ç»“æ„ä½“å®šä¹‰ä¸­å¢åŠ ä¸€ä¸ª parent å­—æ®µã€‚é—®é¢˜æ˜¯ parent çš„ç±»å‹åº”è¯¥æ˜¯ä»€ä¹ˆã€‚çŸ¥é“å…¶ä¸èƒ½åŒ…å« `Rc<T>`ï¼Œå› ä¸ºè¿™æ · leaf.parent å°†ä¼šæŒ‡å‘ branch è€Œ branch.children ä¼šåŒ…å« leaf çš„æŒ‡é’ˆï¼Œè¿™ä¼šå½¢æˆå¼•ç”¨å¾ªç¯ï¼Œä¼šé€ æˆå…¶ strong_count æ°¸è¿œä¹Ÿä¸ä¼šä¸º 0.

ç°åœ¨æ¢ä¸€ç§æ–¹å¼æ€è€ƒè¿™ä¸ªå…³ç³»ï¼Œçˆ¶ç»“ç‚¹åº”è¯¥æ‹¥æœ‰å…¶å­ç»“ç‚¹ï¼šå¦‚æœçˆ¶ç»“ç‚¹è¢«ä¸¢å¼ƒäº†ï¼Œå…¶å­ç»“ç‚¹ä¹Ÿåº”è¯¥è¢«ä¸¢å¼ƒã€‚ç„¶è€Œå­ç»“ç‚¹ä¸åº”è¯¥æ‹¥æœ‰å…¶çˆ¶ç»“ç‚¹ï¼šå¦‚æœä¸¢å¼ƒå­ç»“ç‚¹ï¼Œå…¶çˆ¶ç»“ç‚¹åº”è¯¥ä¾ç„¶å­˜åœ¨ã€‚è¿™æ­£æ˜¯å¼±å¼•ç”¨çš„ä¾‹å­ï¼

æ‰€ä»¥ parent ä½¿ç”¨ `Weak<T>` ç±»å‹è€Œä¸æ˜¯ `Rc<T>`ï¼Œå…·ä½“æ¥è¯´æ˜¯ `RefCell<Weak<Node>>`ã€‚ç°åœ¨ Node ç»“æ„ä½“å®šä¹‰çœ‹èµ·æ¥åƒè¿™æ ·ï¼š

```rust

#![allow(unused_variables)]
fn main() {
use std::rc::{Rc, Weak};
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}
}
```

```rust
use std::rc::{Rc, Weak};
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}

fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
}

```

åˆ›å»º leaf ç»“ç‚¹ç±»ä¼¼äºç¤ºä¾‹ 15-27 ä¸­å¦‚ä½•åˆ›å»º leaf ç»“ç‚¹çš„ï¼Œé™¤äº† parent å­—æ®µæœ‰æ‰€ä¸åŒï¼šleaf å¼€å§‹æ—¶æ²¡æœ‰çˆ¶ç»“ç‚¹ï¼Œæ‰€ä»¥æ–°å»ºäº†ä¸€ä¸ªç©ºçš„ Weak å¼•ç”¨å®ä¾‹ã€‚

æ­¤æ—¶ï¼Œå½“å°è¯•ä½¿ç”¨ upgrade æ–¹æ³•è·å– leaf çš„çˆ¶ç»“ç‚¹å¼•ç”¨æ—¶ï¼Œä¼šå¾—åˆ°ä¸€ä¸ª None å€¼ã€‚å¦‚ç¬¬ä¸€ä¸ª println! è¾“å‡ºæ‰€ç¤ºï¼š

```rust
leaf parent = None
```

å½“åˆ›å»º branch ç»“ç‚¹æ—¶ï¼Œå…¶ä¹Ÿä¼šæ–°å»ºä¸€ä¸ª `Weak<Node>` å¼•ç”¨ï¼Œå› ä¸º branch å¹¶æ²¡æœ‰çˆ¶ç»“ç‚¹ã€‚leaf ä»ç„¶ä½œä¸º branch çš„ä¸€ä¸ªå­ç»“ç‚¹ã€‚ä¸€æ—¦åœ¨ branch ä¸­æœ‰äº† Node å®ä¾‹ï¼Œå°±å¯ä»¥ä¿®æ”¹ leaf ä½¿å…¶æ‹¥æœ‰æŒ‡å‘çˆ¶ç»“ç‚¹çš„ `Weak<Node>` å¼•ç”¨ã€‚è¿™é‡Œä½¿ç”¨äº† leaf ä¸­ parent å­—æ®µé‡Œçš„ `RefCell<Weak<Node>>` çš„ borrow_mut æ–¹æ³•ï¼Œæ¥ç€ä½¿ç”¨äº† Rc::downgrade å‡½æ•°æ¥ä» branch ä¸­çš„ Rc å€¼åˆ›å»ºäº†ä¸€ä¸ªæŒ‡å‘ branch çš„ `Weak<Node>` å¼•ç”¨ã€‚

å½“å†æ¬¡æ‰“å°å‡º leaf çš„çˆ¶ç»“ç‚¹æ—¶ï¼Œè¿™ä¸€æ¬¡å°†ä¼šå¾—åˆ°å­˜æ”¾äº† branch çš„ Some å€¼ï¼šç°åœ¨ leaf å¯ä»¥è®¿é—®å…¶çˆ¶ç»“ç‚¹äº†ï¼å½“æ‰“å°å‡º leaf æ—¶ï¼Œ

###### å¯è§†åŒ– strong_count å’Œ weak_count çš„æ”¹å˜

é€šè¿‡åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„å†…éƒ¨ä½œç”¨åŸŸå¹¶å°† branch çš„åˆ›å»ºæ”¾å…¥å…¶ä¸­ï¼Œæ¥è§‚å¯Ÿ `Rc<Node>` å®ä¾‹çš„ strong_count å’Œ weak_count å€¼çš„å˜åŒ–ã€‚è¿™ä¼šå±•ç¤ºå½“ branch åˆ›å»ºå’Œç¦»å¼€ä½œç”¨åŸŸè¢«ä¸¢å¼ƒæ—¶ä¼šå‘ç”Ÿä»€ä¹ˆã€‚

```rust
use std::rc::{Rc, Weak};
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}

fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

        println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&branch),
            Rc::weak_count(&branch),
        );

        println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&leaf),
            Rc::weak_count(&leaf),
        );
    }

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );
}

```

ä¸€æ—¦åˆ›å»ºäº† leafï¼Œå…¶ `Rc<Node>` çš„å¼ºå¼•ç”¨è®¡æ•°ä¸º 1ï¼Œå¼±å¼•ç”¨è®¡æ•°ä¸º 0ã€‚åœ¨å†…éƒ¨ä½œç”¨åŸŸä¸­åˆ›å»ºäº† branch å¹¶ä¸ leaf ç›¸å…³è”ï¼Œæ­¤æ—¶ branch ä¸­ `Rc<Node>` çš„å¼ºå¼•ç”¨è®¡æ•°ä¸º 1ï¼Œå¼±å¼•ç”¨è®¡æ•°ä¸º 1ï¼ˆå› ä¸º leaf.parent é€šè¿‡ `Weak<Node>` æŒ‡å‘ branchï¼‰ã€‚è¿™é‡Œ leaf çš„å¼ºå¼•ç”¨è®¡æ•°ä¸º 2ï¼Œå› ä¸ºç°åœ¨ branch çš„ branch.children ä¸­å‚¨å­˜äº† leaf çš„ `Rc<Node>` çš„æ‹·è´ï¼Œä¸è¿‡å¼±å¼•ç”¨è®¡æ•°ä»ç„¶ä¸º 0ã€‚

å½“å†…éƒ¨ä½œç”¨åŸŸç»“æŸæ—¶ï¼Œbranch ç¦»å¼€ä½œç”¨åŸŸï¼Œ`Rc<Node>` çš„å¼ºå¼•ç”¨è®¡æ•°å‡å°‘ä¸º 0ï¼Œæ‰€ä»¥å…¶ Node è¢«ä¸¢å¼ƒã€‚æ¥è‡ª leaf.parent çš„å¼±å¼•ç”¨è®¡æ•° 1 ä¸ Node æ˜¯å¦è¢«ä¸¢å¼ƒæ— å…³ï¼Œæ‰€ä»¥å¹¶æ²¡æœ‰äº§ç”Ÿä»»ä½•å†…å­˜æ³„éœ²ï¼

å¦‚æœåœ¨å†…éƒ¨ä½œç”¨åŸŸç»“æŸåå°è¯•è®¿é—® leaf çš„çˆ¶ç»“ç‚¹ï¼Œä¼šå†æ¬¡å¾—åˆ° Noneã€‚åœ¨ç¨‹åºçš„ç»“å°¾ï¼Œleaf ä¸­ `Rc<Node>` çš„å¼ºå¼•ç”¨è®¡æ•°ä¸º 1ï¼Œå¼±å¼•ç”¨è®¡æ•°ä¸º 0ï¼Œå› ä¸ºç°åœ¨ leaf åˆæ˜¯ `Rc<Node>` å”¯ä¸€çš„å¼•ç”¨äº†ã€‚

æ‰€æœ‰è¿™äº›ç®¡ç†è®¡æ•°å’Œå€¼çš„é€»è¾‘éƒ½å†…å»ºäº `Rc<T>` å’Œ `Weak<T>` ä»¥åŠå®ƒä»¬çš„ Drop trait å®ç°ä¸­ã€‚é€šè¿‡åœ¨ Node å®šä¹‰ä¸­æŒ‡å®šä»å­ç»“ç‚¹åˆ°çˆ¶ç»“ç‚¹çš„å…³ç³»ä¸ºä¸€ä¸ª`Weak<T>`å¼•ç”¨ï¼Œå°±èƒ½å¤Ÿæ‹¥æœ‰çˆ¶ç»“ç‚¹å’Œå­ç»“ç‚¹ä¹‹é—´çš„åŒå‘å¼•ç”¨è€Œä¸ä¼šé€ æˆå¼•ç”¨å¾ªç¯å’Œå†…å­˜æ³„éœ²ã€‚

### æ— ç•å¹¶å‘

å®‰å…¨å¹¶é«˜æ•ˆçš„å¤„ç†å¹¶å‘ç¼–ç¨‹æ˜¯ Rust çš„å¦ä¸€ä¸ªä¸»è¦ç›®æ ‡ã€‚å¹¶å‘ç¼–ç¨‹ï¼ˆConcurrent programmingï¼‰ï¼Œä»£è¡¨ç¨‹åºçš„ä¸åŒéƒ¨åˆ†ç›¸äº’ç‹¬ç«‹çš„æ‰§è¡Œï¼Œè€Œ å¹¶è¡Œç¼–ç¨‹ï¼ˆparallel programmingï¼‰ä»£è¡¨ç¨‹åºä¸åŒéƒ¨åˆ†äºåŒæ—¶æ‰§è¡Œï¼Œè¿™ä¸¤ä¸ªæ¦‚å¿µéšç€è®¡ç®—æœºè¶Šæ¥è¶Šå¤šçš„åˆ©ç”¨å¤šå¤„ç†å™¨çš„ä¼˜åŠ¿æ—¶æ˜¾å¾—æ„ˆå‘é‡è¦ã€‚ç”±äºå†å²åŸå› ï¼Œåœ¨æ­¤ç±»ä¸Šä¸‹æ–‡ä¸­ç¼–ç¨‹ä¸€ç›´æ˜¯å›°éš¾ä¸”å®¹æ˜“å‡ºé”™çš„ï¼šRust å¸Œæœ›èƒ½æ”¹å˜è¿™ä¸€ç‚¹ã€‚

èµ·åˆï¼ŒRust å›¢é˜Ÿè®¤ä¸ºç¡®ä¿å†…å­˜å®‰å…¨å’Œé˜²æ­¢å¹¶å‘é—®é¢˜æ˜¯ä¸¤ä¸ªåˆ†åˆ«éœ€è¦ä¸åŒæ–¹æ³•åº”å¯¹çš„æŒ‘æˆ˜ã€‚éšç€æ—¶é—´çš„æ¨ç§»ï¼Œå›¢é˜Ÿå‘ç°æ‰€æœ‰æƒå’Œç±»å‹ç³»ç»Ÿæ˜¯ä¸€ç³»åˆ—è§£å†³å†…å­˜å®‰å…¨ å’Œ å¹¶å‘é—®é¢˜çš„å¼ºæœ‰åŠ›çš„å·¥å…·ï¼é€šè¿‡åˆ©ç”¨æ‰€æœ‰æƒå’Œç±»å‹æ£€æŸ¥ï¼Œåœ¨ Rust ä¸­å¾ˆå¤šå¹¶å‘é”™è¯¯éƒ½æ˜¯ ç¼–è¯‘æ—¶ é”™è¯¯ï¼Œè€Œéè¿è¡Œæ—¶é”™è¯¯ã€‚å› æ­¤ï¼Œç›¸æ¯”èŠ±è´¹å¤§é‡æ—¶é—´å°è¯•é‡ç°è¿è¡Œæ—¶å¹¶å‘ bug å‡ºç°çš„ç‰¹å®šæƒ…å†µï¼ŒRust ä¼šæ‹’ç»ç¼–è¯‘ä¸æ­£ç¡®çš„ä»£ç å¹¶æä¾›è§£é‡Šé—®é¢˜çš„é”™è¯¯ä¿¡æ¯ã€‚å› æ­¤ï¼Œå¯ä»¥åœ¨å¼€å‘æ—¶ä¿®å¤ä»£ç ï¼Œè€Œä¸æ˜¯åœ¨éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒåä¿®å¤ä»£ç ã€‚ç»™ Rust çš„è¿™ä¸€éƒ¨åˆ†èµ·äº†ä¸€ä¸ªç»°å· æ— ç•å¹¶å‘ï¼ˆfearless concurrencyï¼‰ã€‚æ— ç•å¹¶å‘ä»¤çš„ä»£ç å…äºå‡ºç°è¯¡å¼‚çš„ bug å¹¶å¯ä»¥è½»æ¾é‡æ„ä¸”æ— éœ€æ‹…å¿ƒä¼šå¼•å…¥æ–°çš„ bugã€‚

*æ³¨æ„ï¼šæ³¨æ„ï¼šå‡ºäºç®€æ´çš„è€ƒè™‘ï¼Œå°†å¾ˆå¤šé—®é¢˜å½’ç±»ä¸º å¹¶å‘ï¼Œè€Œä¸æ˜¯æ›´å‡†ç¡®çš„åŒºåˆ† å¹¶å‘å’Œï¼ˆæˆ–ï¼‰å¹¶è¡Œã€‚å¦‚æœè¿™æ˜¯ä¸€æœ¬ä¸“æ³¨äºå¹¶å‘å’Œ/æˆ–å¹¶è¡Œçš„ä¹¦ï¼Œè‚¯å®šä¼šæ›´åŠ ç²¾ç¡®çš„ã€‚å¯¹äºæœ¬ç« ï¼Œå½“è°ˆåˆ° å¹¶å‘ æ—¶ï¼Œè¯·è‡ªè¡Œè„‘å†…æ›¿æ¢ä¸º å¹¶å‘å’Œï¼ˆæˆ–ï¼‰å¹¶è¡Œã€‚*

å¾ˆå¤šè¯­è¨€æ‰€æä¾›çš„å¤„ç†å¹¶å‘é—®é¢˜çš„è§£å†³æ–¹æ³•éƒ½éå¸¸æœ‰ç‰¹è‰²ã€‚ä¾‹å¦‚ï¼ŒErlang æœ‰ç€ä¼˜é›…çš„æ¶ˆæ¯ä¼ é€’å¹¶å‘åŠŸèƒ½ï¼Œä½†åªæœ‰æ¨¡ç³Šä¸æ¸…çš„åœ¨çº¿ç¨‹é—´å…±äº«çŠ¶æ€çš„æ–¹æ³•ã€‚å¯¹äºé«˜çº§è¯­è¨€æ¥è¯´ï¼Œåªå®ç°å¯èƒ½è§£å†³æ–¹æ¡ˆçš„å­é›†æ˜¯ä¸€ä¸ªåˆç†çš„ç­–ç•¥ï¼Œå› ä¸ºé«˜çº§è¯­è¨€æ‰€è®¸è¯ºçš„ä»·å€¼æ¥æºäºç‰ºç‰²ä¸€äº›æ§åˆ¶æ¥æ¢å–æŠ½è±¡ã€‚ç„¶è€Œå¯¹äºåº•å±‚è¯­è¨€åˆ™æœŸæœ›æä¾›åœ¨ä»»ä½•ç»™å®šçš„æƒ…å†µä¸‹æœ‰ç€æœ€é«˜çš„æ€§èƒ½ä¸”å¯¹ç¡¬ä»¶æœ‰æ›´å°‘çš„æŠ½è±¡ã€‚å› æ­¤ï¼ŒRust æä¾›äº†å¤šç§å·¥å…·ï¼Œä»¥ç¬¦åˆå®é™…æƒ…å†µå’Œéœ€æ±‚çš„æ–¹å¼æ¥ä¸ºé—®é¢˜å»ºæ¨¡ã€‚

å¦‚ä¸‹æ˜¯æœ¬ç« å°†è¦æ¶‰åŠåˆ°çš„å†…å®¹ï¼š

* å¦‚ä½•åˆ›å»ºçº¿ç¨‹æ¥åŒæ—¶è¿è¡Œå¤šæ®µä»£ç ã€‚
* æ¶ˆæ¯ä¼ é€’ï¼ˆMessage passingï¼‰å¹¶å‘ï¼Œå…¶ä¸­é€šé“ï¼ˆchannelï¼‰è¢«ç”¨æ¥åœ¨çº¿ç¨‹é—´ä¼ é€’æ¶ˆæ¯ã€‚
* å…±äº«çŠ¶æ€ï¼ˆShared stateï¼‰å¹¶å‘ï¼Œå…¶ä¸­å¤šä¸ªçº¿ç¨‹å¯ä»¥è®¿é—®åŒä¸€ç‰‡æ•°æ®ã€‚
* Sync å’Œ Send traitï¼Œä»–ä»¬å…è®¸ Rust çš„å¹¶å‘ä¿è¯èƒ½è¢«æ‰©å±•åˆ°ç”¨æˆ·å®šä¹‰çš„å’Œæ ‡å‡†åº“ä¸­æä¾›çš„ç±»å‹ä¸­ã€‚

#### ä½¿ç”¨çº¿ç¨‹åŒæ—¶è¿è¡Œä»£ç 

åœ¨å¤§éƒ¨åˆ†ç°ä»£æ“ä½œç³»ç»Ÿä¸­ï¼Œæ‰§è¡Œä¸­ç¨‹åºçš„ä»£ç è¿è¡Œäºä¸€ä¸ª è¿›ç¨‹ï¼ˆprocessï¼‰ä¸­ï¼Œæ“ä½œç³»ç»Ÿåˆ™è´Ÿè´£ç®¡ç†å¤šä¸ªè¿›ç¨‹ã€‚åœ¨ç¨‹åºå†…éƒ¨ï¼Œä¹Ÿå¯ä»¥æ‹¥æœ‰å¤šä¸ªåŒæ—¶è¿è¡Œçš„ç‹¬ç«‹éƒ¨åˆ†ã€‚è¿™ä¸ªè¿è¡Œè¿™äº›ç‹¬ç«‹éƒ¨åˆ†çš„åŠŸèƒ½è¢«ç§°ä¸º çº¿ç¨‹ï¼ˆthreadsï¼‰ã€‚

å°†ç¨‹åºä¸­çš„è®¡ç®—æ‹†åˆ†è¿›å¤šä¸ªçº¿ç¨‹å¯ä»¥æ”¹å–„æ€§èƒ½ï¼Œå› ä¸ºç¨‹åºå¯ä»¥åŒæ—¶è¿›è¡Œå¤šä¸ªä»»åŠ¡ï¼Œä¸è¿‡è¿™ä¹Ÿä¼šå¢åŠ å¤æ‚æ€§ã€‚å› ä¸ºçº¿ç¨‹æ˜¯åŒæ—¶è¿è¡Œçš„ï¼Œæ‰€ä»¥æ— æ³•é¢„å…ˆä¿è¯ä¸åŒçº¿ç¨‹ä¸­çš„ä»£ç çš„æ‰§è¡Œé¡ºåºã€‚è¿™ä¼šå¯¼è‡´è¯¸å¦‚æ­¤ç±»çš„é—®é¢˜ï¼š

* ç«äº‰çŠ¶æ€ï¼ˆRace conditionsï¼‰ï¼Œå¤šä¸ªçº¿ç¨‹ä»¥ä¸ä¸€è‡´çš„é¡ºåºè®¿é—®æ•°æ®æˆ–èµ„æº
* æ­»é”ï¼ˆDeadlocksï¼‰ï¼Œä¸¤ä¸ªçº¿ç¨‹ç›¸äº’ç­‰å¾…å¯¹æ–¹åœæ­¢ä½¿ç”¨å…¶æ‰€æ‹¥æœ‰çš„èµ„æºï¼Œè¿™ä¼šé˜»æ­¢å®ƒä»¬ç»§ç»­è¿è¡Œ
* åªä¼šå‘ç”Ÿåœ¨ç‰¹å®šæƒ…å†µä¸”éš¾ä»¥ç¨³å®šé‡ç°å’Œä¿®å¤çš„ bug

Rust å°è¯•ç¼“å’Œä½¿ç”¨çº¿ç¨‹çš„è´Ÿé¢å½±å“ã€‚ä¸è¿‡åœ¨å¤šçº¿ç¨‹ä¸Šä¸‹æ–‡ä¸­ç¼–ç¨‹ä»éœ€æ ¼å¤–å°å¿ƒï¼ŒåŒæ—¶å…¶æ‰€è¦æ±‚çš„ä»£ç ç»“æ„ä¹Ÿä¸åŒäºè¿è¡Œäºå•çº¿ç¨‹çš„ç¨‹åºã€‚

ç¼–ç¨‹è¯­è¨€æœ‰ä¸€äº›ä¸åŒçš„æ–¹æ³•æ¥å®ç°çº¿ç¨‹ã€‚å¾ˆå¤šæ“ä½œç³»ç»Ÿæä¾›äº†åˆ›å»ºæ–°çº¿ç¨‹çš„ APIã€‚è¿™ç§ç”±ç¼–ç¨‹è¯­è¨€è°ƒç”¨æ“ä½œç³»ç»Ÿ API åˆ›å»ºçº¿ç¨‹çš„æ¨¡å‹æœ‰æ—¶è¢«ç§°ä¸º 1:1ï¼Œä¸€ä¸ª OS çº¿ç¨‹å¯¹åº”ä¸€ä¸ªè¯­è¨€çº¿ç¨‹ã€‚

å¾ˆå¤šç¼–ç¨‹è¯­è¨€æä¾›äº†è‡ªå·±ç‰¹æ®Šçš„çº¿ç¨‹å®ç°ã€‚ç¼–ç¨‹è¯­è¨€æä¾›çš„çº¿ç¨‹è¢«ç§°ä¸º ç»¿è‰²ï¼ˆgreenï¼‰çº¿ç¨‹ï¼Œä½¿ç”¨ç»¿è‰²çº¿ç¨‹çš„è¯­è¨€ä¼šåœ¨ä¸åŒæ•°é‡çš„ OS çº¿ç¨‹çš„ä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œå®ƒä»¬ã€‚ä¸ºæ­¤ï¼Œç»¿è‰²çº¿ç¨‹æ¨¡å¼è¢«ç§°ä¸º M:N æ¨¡å‹ï¼šM ä¸ªç»¿è‰²çº¿ç¨‹å¯¹åº” N ä¸ª OS çº¿ç¨‹ï¼Œè¿™é‡Œ M å’Œ N ä¸å¿…ç›¸åŒã€‚

æ¯ä¸€ä¸ªæ¨¡å‹éƒ½æœ‰å…¶ä¼˜åŠ¿å’Œå–èˆã€‚å¯¹äº Rust æ¥è¯´æœ€é‡è¦çš„å–èˆæ˜¯è¿è¡Œæ—¶æ”¯æŒã€‚è¿è¡Œæ—¶ï¼ˆRuntimeï¼‰æ˜¯ä¸€ä¸ªä»¤äººè¿·æƒ‘çš„æ¦‚å¿µï¼Œå…¶åœ¨ä¸åŒä¸Šä¸‹æ–‡ä¸­å¯èƒ½æœ‰ä¸åŒçš„å«ä¹‰ã€‚

åœ¨å½“å‰ä¸Šä¸‹æ–‡ä¸­ï¼Œè¿è¡Œæ—¶ ä»£è¡¨äºŒè¿›åˆ¶æ–‡ä»¶ä¸­åŒ…å«çš„ç”±è¯­è¨€è‡ªèº«æä¾›çš„ä»£ç ã€‚è¿™äº›ä»£ç æ ¹æ®è¯­è¨€çš„ä¸åŒå¯å¤§å¯å°ï¼Œä¸è¿‡ä»»ä½•éæ±‡ç¼–è¯­è¨€éƒ½ä¼šæœ‰ä¸€å®šæ•°é‡çš„è¿è¡Œæ—¶ä»£ç ã€‚ä¸ºæ­¤ï¼Œé€šå¸¸äººä»¬è¯´ä¸€ä¸ªè¯­è¨€ â€œæ²¡æœ‰è¿è¡Œæ—¶â€ï¼Œä¸€èˆ¬æ„å‘³ç€ â€œå°è¿è¡Œæ—¶â€ã€‚æ›´å°çš„è¿è¡Œæ—¶æ‹¥æœ‰æ›´å°‘çš„åŠŸèƒ½ä¸è¿‡å…¶ä¼˜åŠ¿åœ¨äºæ›´å°çš„äºŒè¿›åˆ¶è¾“å‡ºï¼Œè¿™ä½¿å…¶æ˜“äºåœ¨æ›´å¤šä¸Šä¸‹æ–‡ä¸­ä¸å…¶ä»–è¯­è¨€ç›¸ç»“åˆã€‚è™½ç„¶å¾ˆå¤šè¯­è¨€è§‰å¾—å¢åŠ è¿è¡Œæ—¶æ¥æ¢å–æ›´å¤šåŠŸèƒ½æ²¡æœ‰ä»€ä¹ˆé—®é¢˜ï¼Œä½†æ˜¯ Rust éœ€è¦åšåˆ°å‡ ä¹æ²¡æœ‰è¿è¡Œæ—¶ï¼ŒåŒæ—¶ä¸ºäº†ä¿æŒé«˜æ€§èƒ½å¿…éœ€èƒ½å¤Ÿè°ƒç”¨ C è¯­è¨€ï¼Œè¿™ç‚¹ä¹Ÿæ˜¯ä¸èƒ½å¦¥åçš„ã€‚

ç»¿è‰²çº¿ç¨‹çš„ M:N æ¨¡å‹éœ€è¦æ›´å¤§çš„è¯­è¨€è¿è¡Œæ—¶æ¥ç®¡ç†è¿™äº›çº¿ç¨‹ã€‚å› æ­¤ï¼ŒRust æ ‡å‡†åº“åªæä¾›äº† 1:1 çº¿ç¨‹æ¨¡å‹å®ç°ã€‚ç”±äº Rust æ˜¯è¾ƒä¸ºåº•å±‚çš„è¯­è¨€ï¼Œå¦‚æœæ„¿æ„ç‰ºç‰²æ€§èƒ½æ¥æ¢å–çš„æŠ½è±¡ï¼Œä»¥è·å¾—å¯¹çº¿ç¨‹è¿è¡Œæ›´ç²¾ç»†çš„æ§åˆ¶åŠæ›´ä½çš„ä¸Šä¸‹æ–‡åˆ‡æ¢æˆæœ¬ï¼Œå¯ä»¥ä½¿ç”¨å®ç°äº† M:N çº¿ç¨‹æ¨¡å‹çš„ crateã€‚

#### ä½¿ç”¨ spawn åˆ›å»ºæ–°çº¿ç¨‹

éœ€è¦è°ƒç”¨ thread::spawn å‡½æ•°å¹¶ä¼ é€’ä¸€ä¸ªé—­åŒ…ï¼Œå¹¶åœ¨å…¶ä¸­åŒ…å«å¸Œæœ›åœ¨æ–°çº¿ç¨‹è¿è¡Œçš„ä»£ç ã€‚

```rust
use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}

```

æ³¨æ„è¿™ä¸ªå‡½æ•°ç¼–å†™çš„æ–¹å¼ï¼Œå½“ä¸»çº¿ç¨‹ç»“æŸæ—¶ï¼Œæ–°çº¿ç¨‹ä¹Ÿä¼šç»“æŸï¼Œè€Œä¸ç®¡å…¶æ˜¯å¦æ‰§è¡Œå®Œæ¯•ã€‚

thread::sleep è°ƒç”¨å¼ºåˆ¶çº¿ç¨‹åœæ­¢æ‰§è¡Œä¸€å°æ®µæ—¶é—´ï¼Œè¿™ä¼šå…è®¸å…¶ä»–ä¸åŒçš„çº¿ç¨‹è¿è¡Œã€‚è¿™äº›çº¿ç¨‹å¯èƒ½ä¼šè½®æµè¿è¡Œï¼Œä¸è¿‡å¹¶ä¸ä¿è¯å¦‚æ­¤ï¼šè¿™ä¾èµ–æ“ä½œç³»ç»Ÿå¦‚ä½•è°ƒåº¦çº¿ç¨‹ã€‚åœ¨è¿™é‡Œï¼Œä¸»çº¿ç¨‹é¦–å…ˆæ‰“å°ï¼Œå³ä¾¿æ–°åˆ›å»ºçº¿ç¨‹çš„æ‰“å°è¯­å¥ä½äºç¨‹åºçš„å¼€å¤´ï¼Œç”šè‡³å³ä¾¿å‘Šè¯‰æ–°å»ºçš„çº¿ç¨‹æ‰“å°ç›´åˆ° i ç­‰äº 9 ï¼Œå®ƒåœ¨ä¸»çº¿ç¨‹ç»“æŸä¹‹å‰ä¹Ÿåªæ‰“å°åˆ°äº† 5ã€‚

å¦‚æœè¿è¡Œä»£ç åªçœ‹åˆ°äº†ä¸»çº¿ç¨‹çš„è¾“å‡ºï¼Œæˆ–æ²¡æœ‰å‡ºç°é‡å æ‰“å°çš„ç°è±¡ï¼Œå°è¯•å¢åŠ  range çš„æ•°å€¼æ¥å¢åŠ æ“ä½œç³»ç»Ÿåˆ‡æ¢çº¿ç¨‹çš„æœºä¼šã€‚

#### ä½¿ç”¨ join ç­‰å¾…æ‰€æœ‰çº¿ç¨‹ç»“æŸ

å¯ä»¥é€šè¿‡å°† thread::spawn çš„è¿”å›å€¼å‚¨å­˜åœ¨å˜é‡ä¸­æ¥ä¿®å¤æ–°å»ºçº¿ç¨‹éƒ¨åˆ†æ²¡æœ‰æ‰§è¡Œæˆ–è€…å®Œå…¨æ²¡æœ‰æ‰§è¡Œçš„é—®é¢˜ã€‚thread::spawn çš„è¿”å›å€¼ç±»å‹æ˜¯ JoinHandleã€‚JoinHandle æ˜¯ä¸€ä¸ªæ‹¥æœ‰æ‰€æœ‰æƒçš„å€¼ï¼Œå½“å¯¹å…¶è°ƒç”¨ join æ–¹æ³•æ—¶ï¼Œå®ƒä¼šç­‰å¾…å…¶çº¿ç¨‹ç»“æŸã€‚

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}

```

é€šè¿‡è°ƒç”¨ handle çš„ join ä¼šé˜»å¡å½“å‰çº¿ç¨‹ç›´åˆ° handle æ‰€ä»£è¡¨çš„çº¿ç¨‹ç»“æŸã€‚é˜»å¡ï¼ˆBlockingï¼‰ çº¿ç¨‹æ„å‘³ç€é˜»æ­¢è¯¥çº¿ç¨‹æ‰§è¡Œå·¥ä½œæˆ–é€€å‡ºã€‚å› ä¸ºå°† join è°ƒç”¨æ”¾åœ¨äº†ä¸»çº¿ç¨‹çš„ for å¾ªç¯ä¹‹å.

è¿™ä¸¤ä¸ªçº¿ç¨‹ä»ç„¶ä¼šäº¤æ›¿æ‰§è¡Œï¼Œä¸è¿‡ä¸»çº¿ç¨‹ä¼šç”±äº handle.join() è°ƒç”¨ä¼šç­‰å¾…ç›´åˆ°æ–°å»ºçº¿ç¨‹æ‰§è¡Œå®Œæ¯•ã€‚

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}

```

#### çº¿ç¨‹ä¸ move é—­åŒ…

move é—­åŒ…ï¼Œå…¶ç»å¸¸ä¸ thread::spawn ä¸€èµ·ä½¿ç”¨ï¼Œå› ä¸ºå®ƒå…è®¸åœ¨ä¸€ä¸ªçº¿ç¨‹ä¸­ä½¿ç”¨å¦ä¸€ä¸ªçº¿ç¨‹çš„æ•°æ®ã€‚

é€šè¿‡åœ¨é—­åŒ…ä¹‹å‰å¢åŠ  move å…³é”®å­—ï¼Œå¼ºåˆ¶é—­åŒ…è·å–å…¶ä½¿ç”¨çš„å€¼çš„æ‰€æœ‰æƒï¼Œè€Œä¸æ˜¯ä»»ç”± Rust æ¨æ–­å®ƒåº”è¯¥å€Ÿç”¨å€¼ã€‚

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}

```

#### ä½¿ç”¨æ¶ˆæ¯ä¼ é€’åœ¨çº¿ç¨‹é—´ä¼ é€æ•°æ®

ä¸€ä¸ªæ—¥ç›Šæµè¡Œçš„ç¡®ä¿å®‰å…¨å¹¶å‘çš„æ–¹å¼æ˜¯ æ¶ˆæ¯ä¼ é€’ï¼ˆmessage passingï¼‰ï¼Œè¿™é‡Œçº¿ç¨‹æˆ– actor é€šè¿‡å‘é€åŒ…å«æ•°æ®çš„æ¶ˆæ¯æ¥ç›¸äº’æ²Ÿé€šã€‚è¿™ä¸ªæ€æƒ³æ¥æºäº Go ç¼–ç¨‹è¯­è¨€æ–‡æ¡£ä¸­ çš„å£å·ï¼šâ€œä¸è¦å…±äº«å†…å­˜æ¥é€šè®¯ï¼›è€Œæ˜¯è¦é€šè®¯æ¥å…±äº«å†…å­˜ã€‚â€ï¼ˆâ€œDo not communicate by sharing memory; instead, share memory by communicating.â€ï¼‰

ç¼–ç¨‹ä¸­çš„é€šé“æœ‰ä¸¤éƒ¨åˆ†ç»„æˆï¼Œä¸€ä¸ªå‘é€è€…ï¼ˆtransmitterï¼‰å’Œä¸€ä¸ªæ¥æ”¶è€…ï¼ˆreceiverï¼‰ã€‚å‘é€è€…ä¸€ç«¯ä½äºä¸Šæ¸¸ä½ç½®ï¼Œåœ¨è¿™é‡Œå¯ä»¥å°†æ©¡çš®é¸­æ”¾å…¥æ²³ä¸­ï¼Œæ¥æ”¶è€…éƒ¨åˆ†åˆ™ä½äºä¸‹æ¸¸ï¼Œæ©¡çš®é¸­æœ€ç»ˆä¼šæ¼‚æµè‡³æ­¤ã€‚ä»£ç ä¸­çš„ä¸€éƒ¨åˆ†è°ƒç”¨å‘é€è€…çš„æ–¹æ³•ä»¥åŠå¸Œæœ›å‘é€çš„æ•°æ®ï¼Œå¦ä¸€éƒ¨åˆ†åˆ™æ£€æŸ¥æ¥æ”¶ç«¯æ”¶åˆ°åˆ°è¾¾çš„æ¶ˆæ¯ã€‚å½“å‘é€è€…æˆ–æ¥æ”¶è€…ä»»ä¸€è¢«ä¸¢å¼ƒæ—¶å¯ä»¥è®¤ä¸ºé€šé“è¢« å…³é—­ï¼ˆclosedï¼‰äº†

è¿™é‡Œï¼Œå°†å¼€å‘ä¸€ä¸ªç¨‹åºï¼Œå®ƒä¼šåœ¨ä¸€ä¸ªçº¿ç¨‹ç”Ÿæˆå€¼å‘é€šé“å‘é€ï¼Œè€Œåœ¨å¦ä¸€ä¸ªçº¿ç¨‹ä¼šæ¥æ”¶å€¼å¹¶æ‰“å°å‡ºæ¥ã€‚è¿™é‡Œä¼šé€šè¿‡é€šé“åœ¨çº¿ç¨‹é—´å‘é€ç®€å•å€¼æ¥æ¼”ç¤ºè¿™ä¸ªåŠŸèƒ½ã€‚ä¸€æ—¦ç†Ÿæ‚‰äº†è¿™é¡¹æŠ€æœ¯ï¼Œå°±èƒ½ä½¿ç”¨é€šé“æ¥å®ç°èŠå¤©ç³»ç»Ÿæˆ–åˆ©ç”¨å¾ˆå¤šçº¿ç¨‹è¿›è¡Œåˆ†å¸ƒå¼è®¡ç®—å¹¶å°†éƒ¨åˆ†è®¡ç®—ç»“æœå‘é€ç»™ä¸€ä¸ªçº¿ç¨‹è¿›è¡Œèšåˆã€‚

```rust
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}

```

è¿™é‡Œä½¿ç”¨ mpsc::channel å‡½æ•°åˆ›å»ºä¸€ä¸ªæ–°çš„é€šé“ï¼›mpsc æ˜¯ å¤šä¸ªç”Ÿäº§è€…ï¼Œå•ä¸ªæ¶ˆè´¹è€…ï¼ˆmultiple producer, single consumerï¼‰çš„ç¼©å†™ã€‚ç®€è€Œè¨€ä¹‹ï¼ŒRust æ ‡å‡†åº“å®ç°é€šé“çš„æ–¹å¼æ„å‘³ç€ä¸€ä¸ªé€šé“å¯ä»¥æœ‰å¤šä¸ªäº§ç”Ÿå€¼çš„ å‘é€ï¼ˆsendingï¼‰ç«¯ï¼Œä½†åªèƒ½æœ‰ä¸€ä¸ªæ¶ˆè´¹è¿™äº›å€¼çš„ æ¥æ”¶ï¼ˆreceivingï¼‰ç«¯ã€‚æƒ³è±¡ä¸€ä¸‹å¤šæ¡å°æ²³å°æºªæœ€ç»ˆæ±‡èšæˆå¤§æ²³ï¼šæ‰€æœ‰é€šè¿‡è¿™äº›å°æ²³å‘å‡ºçš„ä¸œè¥¿æœ€åéƒ½ä¼šæ¥åˆ°å¤§æ²³çš„ä¸‹æ¸¸ã€‚ç›®å‰ä»¥å•ä¸ªç”Ÿäº§è€…å¼€å§‹ï¼Œä½†æ˜¯å½“ç¤ºä¾‹å¯ä»¥å·¥ä½œåä¼šå¢åŠ å¤šä¸ªç”Ÿäº§è€…ã€‚

mpsc::channel å‡½æ•°è¿”å›ä¸€ä¸ªå…ƒç»„ï¼šç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯å‘é€ç«¯ï¼Œè€Œç¬¬äºŒä¸ªå…ƒç´ æ˜¯æ¥æ”¶ç«¯ã€‚ç”±äºå†å²åŸå› ï¼Œtx å’Œ rx é€šå¸¸ä½œä¸º å‘é€è€…ï¼ˆtransmitterï¼‰å’Œ æ¥æ”¶è€…ï¼ˆreceiverï¼‰çš„ç¼©å†™ï¼Œæ‰€ä»¥è¿™å°±æ˜¯å°†ç”¨æ¥ç»‘å®šè¿™ä¸¤ç«¯å˜é‡çš„åå­—ã€‚è¿™é‡Œä½¿ç”¨äº†ä¸€ä¸ª let è¯­å¥å’Œæ¨¡å¼æ¥è§£æ„äº†æ­¤å…ƒç»„ï¼›å¦‚æ­¤ä½¿ç”¨ let è¯­å¥æ˜¯ä¸€ä¸ªæ–¹ä¾¿æå– mpsc::channel è¿”å›çš„å…ƒç»„ä¸­ä¸€éƒ¨åˆ†çš„æ‰‹æ®µã€‚

å°†å‘é€ç«¯ç§»åŠ¨åˆ°ä¸€ä¸ªæ–°å»ºçº¿ç¨‹ä¸­å¹¶å‘é€ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¿™æ ·æ–°å»ºçº¿ç¨‹å°±å¯ä»¥å’Œä¸»çº¿ç¨‹é€šè®¯äº†ï¼Œ

```rust
use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });
}

```

é€šé“çš„æ¥æ”¶ç«¯æœ‰ä¸¤ä¸ªæœ‰ç”¨çš„æ–¹æ³•ï¼šrecv å’Œ try_recvã€‚è¿™é‡Œï¼Œä½¿ç”¨äº† recvï¼Œå®ƒæ˜¯ receive çš„ç¼©å†™ã€‚è¿™ä¸ªæ–¹æ³•ä¼šé˜»å¡ä¸»çº¿ç¨‹æ‰§è¡Œç›´åˆ°ä»é€šé“ä¸­æ¥æ”¶ä¸€ä¸ªå€¼ã€‚ä¸€æ—¦å‘é€äº†ä¸€ä¸ªå€¼ï¼Œrecv ä¼šåœ¨ä¸€ä¸ª Result<T, E> ä¸­è¿”å›å®ƒã€‚å½“é€šé“å‘é€ç«¯å…³é—­ï¼Œrecv ä¼šè¿”å›ä¸€ä¸ªé”™è¯¯è¡¨æ˜ä¸ä¼šå†æœ‰æ–°çš„å€¼åˆ°æ¥äº†ã€‚

try_recv ä¸ä¼šé˜»å¡ï¼Œç›¸åå®ƒç«‹åˆ»è¿”å›ä¸€ä¸ª Result<T, E>ï¼šOk å€¼åŒ…å«å¯ç”¨çš„ä¿¡æ¯ï¼Œè€Œ Err å€¼ä»£è¡¨æ­¤æ—¶æ²¡æœ‰ä»»ä½•æ¶ˆæ¯ã€‚å¦‚æœçº¿ç¨‹åœ¨ç­‰å¾…æ¶ˆæ¯è¿‡ç¨‹ä¸­è¿˜æœ‰å…¶ä»–å·¥ä½œæ—¶ä½¿ç”¨ try_recv å¾ˆæœ‰ç”¨ï¼šå¯ä»¥ç¼–å†™ä¸€ä¸ªå¾ªç¯æ¥é¢‘ç¹è°ƒç”¨ try_recvï¼Œå†æœ‰å¯ç”¨æ¶ˆæ¯æ—¶è¿›è¡Œå¤„ç†ï¼Œå…¶ä½™æ—¶å€™åˆ™å¤„ç†ä¸€ä¼šå…¶ä»–å·¥ä½œç›´åˆ°å†æ¬¡æ£€æŸ¥ã€‚

##### é€šé“ä¸æ‰€æœ‰æƒè½¬ç§»

æ‰€æœ‰æƒè§„åˆ™åœ¨æ¶ˆæ¯ä¼ é€’ä¸­æ‰®æ¼”äº†é‡è¦è§’è‰²ï¼Œå…¶æœ‰åŠ©äºç¼–å†™å®‰å…¨çš„å¹¶å‘ä»£ç ã€‚åœ¨å¹¶å‘ç¼–ç¨‹ä¸­é¿å…é”™è¯¯æ˜¯åœ¨æ•´ä¸ª Rust ç¨‹åºä¸­å¿…é¡»æ€è€ƒæ‰€æœ‰æƒæ‰€æ¢æ¥çš„ä¸€å¤§ä¼˜åŠ¿ã€‚ç°åœ¨åšä¸€ä¸ªè¯•éªŒæ¥çœ‹çœ‹é€šé“ä¸æ‰€æœ‰æƒå¦‚ä½•ä¸€åŒåä½œä»¥é¿å…äº§ç”Ÿé—®é¢˜ï¼šå°†å°è¯•åœ¨æ–°å»ºçº¿ç¨‹ä¸­çš„é€šé“ä¸­å‘é€å®Œ val å€¼ ä¹‹å å†ä½¿ç”¨å®ƒã€‚

##### å‘é€å¤šä¸ªå€¼å¹¶è§‚å¯Ÿæ¥æ”¶è€…çš„ç­‰å¾…

```rust
use std::thread;
use std::sync::mpsc;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {}", received);
    }
}

```

åœ¨æ–°å»ºçº¿ç¨‹ä¸­æœ‰ä¸€ä¸ªå­—ç¬¦ä¸² vector å¸Œæœ›å‘é€åˆ°ä¸»çº¿ç¨‹ã€‚éå†ä»–ä»¬ï¼Œå•ç‹¬çš„å‘é€æ¯ä¸€ä¸ªå­—ç¬¦ä¸²å¹¶é€šè¿‡ä¸€ä¸ª Duration å€¼è°ƒç”¨ thread::sleep å‡½æ•°æ¥æš‚åœä¸€ç§’ã€‚

åœ¨ä¸»çº¿ç¨‹ä¸­ï¼Œä¸å†æ˜¾å¼è°ƒç”¨ recv å‡½æ•°ï¼šè€Œæ˜¯å°† rx å½“ä½œä¸€ä¸ªè¿­ä»£å™¨ã€‚å¯¹äºæ¯ä¸€ä¸ªæ¥æ”¶åˆ°çš„å€¼ï¼Œå°†å…¶æ‰“å°å‡ºæ¥ã€‚å½“é€šé“è¢«å…³é—­æ—¶ï¼Œè¿­ä»£å™¨ä¹Ÿå°†ç»“æŸã€‚

##### é€šè¿‡å…‹éš†å‘é€è€…æ¥åˆ›å»ºå¤šä¸ªç”Ÿäº§è€…

```rust
use std::thread;
use std::sync::mpsc;
use std::time::Duration;

fn main() {
// --snip--

let (tx, rx) = mpsc::channel();

let tx1 = mpsc::Sender::clone(&tx);
thread::spawn(move || {
    let vals = vec![
        String::from("hi"),
        String::from("from"),
        String::from("the"),
        String::from("thread"),
    ];

    for val in vals {
        tx1.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

thread::spawn(move || {
    let vals = vec![
        String::from("more"),
        String::from("messages"),
        String::from("for"),
        String::from("you"),
    ];

    for val in vals {
        tx.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

for received in rx {
    println!("Got: {}", received);
}

// --snip--
}

```

è¿™ä¸€æ¬¡ï¼Œåœ¨åˆ›å»ºæ–°çº¿ç¨‹ä¹‹å‰ï¼Œå¯¹é€šé“çš„å‘é€ç«¯è°ƒç”¨äº† clone æ–¹æ³•ã€‚è¿™ä¼šç»™ä¸€ä¸ªå¯ä»¥ä¼ é€’ç»™ç¬¬ä¸€ä¸ªæ–°å»ºçº¿ç¨‹çš„å‘é€ç«¯å¥æŸ„ã€‚ä¼šå°†åŸå§‹çš„é€šé“å‘é€ç«¯ä¼ é€’ç»™ç¬¬äºŒä¸ªæ–°å»ºçº¿ç¨‹ã€‚è¿™æ ·å°±ä¼šæœ‰ä¸¤ä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªçº¿ç¨‹å°†å‘é€šé“çš„æ¥æ”¶ç«¯å‘é€ä¸åŒçš„æ¶ˆæ¯ã€‚

#### å…±äº«çŠ¶æ€å¹¶å‘

åœ¨æŸç§ç¨‹åº¦ä¸Šï¼Œä»»ä½•ç¼–ç¨‹è¯­è¨€ä¸­çš„é€šé“éƒ½ç±»ä¼¼äºå•æ‰€æœ‰æƒï¼Œå› ä¸ºä¸€æ—¦å°†ä¸€ä¸ªå€¼ä¼ é€åˆ°é€šé“ä¸­ï¼Œå°†æ— æ³•å†ä½¿ç”¨è¿™ä¸ªå€¼ã€‚å…±äº«å†…å­˜ç±»ä¼¼äºå¤šæ‰€æœ‰æƒï¼šå¤šä¸ªçº¿ç¨‹å¯ä»¥åŒæ—¶è®¿é—®ç›¸åŒçš„å†…å­˜ä½ç½®ã€‚

#### äº’æ–¥å™¨ä¸€æ¬¡åªå…è®¸ä¸€ä¸ªçº¿ç¨‹è®¿é—®æ•°æ®

äº’æ–¥å™¨ï¼ˆmutexï¼‰æ˜¯ mutual exclusion çš„ç¼©å†™ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œä»»æ„æ—¶åˆ»ï¼Œå…¶åªå…è®¸ä¸€ä¸ªçº¿ç¨‹è®¿é—®æŸäº›æ•°æ®ã€‚ä¸ºäº†è®¿é—®äº’æ–¥å™¨ä¸­çš„æ•°æ®ï¼Œçº¿ç¨‹é¦–å…ˆéœ€è¦é€šè¿‡è·å–äº’æ–¥å™¨çš„ é”ï¼ˆlockï¼‰æ¥è¡¨æ˜å…¶å¸Œæœ›è®¿é—®æ•°æ®ã€‚é”æ˜¯ä¸€ä¸ªä½œä¸ºäº’æ–¥å™¨ä¸€éƒ¨åˆ†çš„æ•°æ®ç»“æ„ï¼Œå®ƒè®°å½•è°æœ‰æ•°æ®çš„æ’ä»–è®¿é—®æƒã€‚å› æ­¤ï¼Œæè¿°äº’æ–¥å™¨ä¸ºé€šè¿‡é”ç³»ç»Ÿ ä¿æŠ¤ï¼ˆguardingï¼‰å…¶æ•°æ®ã€‚

mutexçš„ç¼ºç‚¹ï¼š

* åœ¨ä½¿ç”¨æ•°æ®ä¹‹å‰å°è¯•è·å–é”ã€‚
* å¤„ç†å®Œè¢«äº’æ–¥å™¨æ‰€ä¿æŠ¤çš„æ•°æ®ä¹‹åï¼Œå¿…é¡»è§£é”æ•°æ®ï¼Œè¿™æ ·å…¶ä»–çº¿ç¨‹æ‰èƒ½å¤Ÿè·å–é”ã€‚

##### `Mutex<T>`çš„ API 

```rust
use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!("m = {:?}", m);
}

```

åƒå¾ˆå¤šç±»å‹ä¸€æ ·ï¼Œä½¿ç”¨å…³è”å‡½æ•° new æ¥åˆ›å»ºä¸€ä¸ª `Mutex<T>`ã€‚ä½¿ç”¨ lock æ–¹æ³•è·å–é”ï¼Œä»¥è®¿é—®äº’æ–¥å™¨ä¸­çš„æ•°æ®ã€‚è¿™ä¸ªè°ƒç”¨ä¼šé˜»å¡å½“å‰çº¿ç¨‹ï¼Œç›´åˆ°æ‹¥æœ‰é”ä¸ºæ­¢ã€‚

å¦‚æœå¦ä¸€ä¸ªçº¿ç¨‹æ‹¥æœ‰é”ï¼Œå¹¶ä¸”é‚£ä¸ªçº¿ç¨‹ panic äº†ï¼Œåˆ™ lock è°ƒç”¨ä¼šå¤±è´¥ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ²¡äººèƒ½å¤Ÿå†è·å–é”ï¼Œæ‰€ä»¥è¿™é‡Œé€‰æ‹© unwrap å¹¶åœ¨é‡åˆ°è¿™ç§æƒ…å†µæ—¶ä½¿çº¿ç¨‹ panicã€‚

ä¸€æ—¦è·å–äº†é”ï¼Œå°±å¯ä»¥å°†è¿”å›å€¼ï¼ˆåœ¨è¿™é‡Œæ˜¯numï¼‰è§†ä¸ºä¸€ä¸ªå…¶å†…éƒ¨æ•°æ®çš„å¯å˜å¼•ç”¨äº†ã€‚ç±»å‹ç³»ç»Ÿç¡®ä¿äº†åœ¨ä½¿ç”¨ m ä¸­çš„å€¼ä¹‹å‰è·å–é”ï¼š`Mutex<i32>` å¹¶ä¸æ˜¯ä¸€ä¸ª i32ï¼Œæ‰€ä»¥ å¿…é¡» è·å–é”æ‰èƒ½ä½¿ç”¨è¿™ä¸ª i32 å€¼ã€‚æ˜¯ä¸ä¼šå¿˜è®°è¿™ä¹ˆåšçš„ï¼Œå› ä¸ºåä¹‹ç±»å‹ç³»ç»Ÿä¸å…è®¸è®¿é—®å†…éƒ¨çš„ i32 å€¼ã€‚

æ­£å¦‚æ‰€æ€€ç–‘çš„ï¼Œ`Mutex<T>` æ˜¯ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆã€‚æ›´å‡†ç¡®çš„è¯´ï¼Œlock è°ƒç”¨ è¿”å› ä¸€ä¸ªå«åš MutexGuard çš„æ™ºèƒ½æŒ‡é’ˆã€‚è¿™ä¸ªæ™ºèƒ½æŒ‡é’ˆå®ç°äº† Deref æ¥æŒ‡å‘å…¶å†…éƒ¨æ•°æ®ï¼›å…¶ä¹Ÿæä¾›äº†ä¸€ä¸ª Drop å®ç°å½“ MutexGuard ç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨é‡Šæ”¾é”ï¼Œ

##### å¤šçº¿ç¨‹å’Œå¤šæ‰€æœ‰æƒ

é€šè¿‡ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆ `Rc<T>` æ¥åˆ›å»ºå¼•ç”¨è®¡æ•°çš„å€¼ï¼Œä»¥ä¾¿æ‹¥æœ‰å¤šæ‰€æœ‰è€…ã€‚å°†ä¾‹å­ä¸­çš„ `Mutex<T>` å°è£…è¿› `Rc<T>` ä¸­å¹¶åœ¨å°†æ‰€æœ‰æƒç§»å…¥çº¿ç¨‹ä¹‹å‰å…‹éš†äº† `Rc<T>`ã€‚ç°åœ¨ç†è§£äº†æ‰€å‘ç”Ÿçš„é”™è¯¯ï¼ŒåŒæ—¶ä¹Ÿå°†ä»£ç æ”¹å›ä½¿ç”¨ for å¾ªç¯ï¼Œå¹¶ä¿ç•™é—­åŒ…çš„ move å…³é”®å­—ï¼š

```rust
use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}

```

å†ä¸€æ¬¡ç¼–è¯‘å¹¶å‡ºç°äº†ä¸åŒçš„é”™è¯¯ï¼

```rust
error[E0277]: `std::rc::Rc<std::sync::Mutex<i32>>` cannot be sent between threads safely
  --> src/main.rs:11:22
   |
11 |         let handle = thread::spawn(move || {
   |                      ^^^^^^^^^^^^^ `std::rc::Rc<std::sync::Mutex<i32>>`
cannot be sent between threads safely
   |
   = help: within `[closure@src/main.rs:11:36: 14:10
counter:std::rc::Rc<std::sync::Mutex<i32>>]`, the trait `std::marker::Send`
is not implemented for `std::rc::Rc<std::sync::Mutex<i32>>`
   = note: required because it appears within the type
`[closure@src/main.rs:11:36: 14:10 counter:std::rc::Rc<std::sync::Mutex<i32>>]`
   = note: required by `std::thread::spawn`

```

ä¸å¹¸çš„æ˜¯ï¼Œ`Rc<T>` å¹¶ä¸èƒ½å®‰å…¨çš„åœ¨çº¿ç¨‹é—´å…±äº«ã€‚å½“ `Rc<T>` ç®¡ç†å¼•ç”¨è®¡æ•°æ—¶ï¼Œå®ƒå¿…é¡»åœ¨æ¯ä¸€ä¸ª clone è°ƒç”¨æ—¶å¢åŠ è®¡æ•°ï¼Œå¹¶åœ¨æ¯ä¸€ä¸ªå…‹éš†è¢«ä¸¢å¼ƒæ—¶å‡å°‘è®¡æ•°ã€‚`Rc<T>` å¹¶æ²¡æœ‰ä½¿ç”¨ä»»ä½•å¹¶å‘åŸè¯­ï¼Œæ¥ç¡®ä¿æ”¹å˜è®¡æ•°çš„æ“ä½œä¸ä¼šè¢«å…¶ä»–çº¿ç¨‹æ‰“æ–­ã€‚åœ¨è®¡æ•°å‡ºé”™æ—¶å¯èƒ½ä¼šå¯¼è‡´è¯¡å¼‚çš„ bugï¼Œæ¯”å¦‚å¯èƒ½ä¼šé€ æˆå†…å­˜æ³„æ¼ï¼Œæˆ–åœ¨ä½¿ç”¨ç»“æŸä¹‹å‰å°±ä¸¢å¼ƒä¸€ä¸ªå€¼ã€‚æ‰€éœ€è¦çš„æ˜¯ä¸€ä¸ªå®Œå…¨ç±»ä¼¼ `Rc<T>`ï¼Œåˆä»¥ä¸€ç§çº¿ç¨‹å®‰å…¨çš„æ–¹å¼æ”¹å˜å¼•ç”¨è®¡æ•°çš„ç±»å‹ã€‚

##### åŸå­å¼•ç”¨è®¡æ•° Arc<T>

æ‰€å¹¸ `Arc<T>` æ­£æ˜¯ è¿™ä¹ˆä¸€ä¸ªç±»ä¼¼ `Rc<T>` å¹¶å¯ä»¥å®‰å…¨çš„ç”¨äºå¹¶å‘ç¯å¢ƒçš„ç±»å‹ã€‚å­—æ¯ â€œaâ€ ä»£è¡¨ åŸå­æ€§ï¼ˆatomicï¼‰ï¼Œæ‰€ä»¥è¿™æ˜¯ä¸€ä¸ªåŸå­å¼•ç”¨è®¡æ•°ï¼ˆatomically reference countedï¼‰ç±»å‹ã€‚åŸå­æ€§æ˜¯å¦ä¸€ç±»è¿™é‡Œè¿˜æœªæ¶‰åŠåˆ°çš„å¹¶å‘åŸè¯­ï¼šè¯·æŸ¥çœ‹æ ‡å‡†åº“ä¸­ std::sync::atomic çš„æ–‡æ¡£æ¥è·å–æ›´å¤šç»†èŠ‚ã€‚å…¶ä¸­çš„è¦ç‚¹å°±æ˜¯ï¼šåŸå­æ€§ç±»å‹å·¥ä½œèµ·æ¥ç±»ä¼¼åŸå§‹ç±»å‹ï¼Œä¸è¿‡å¯ä»¥å®‰å…¨çš„åœ¨çº¿ç¨‹é—´å…±äº«ã€‚

ä¸ºä»€ä¹ˆä¸æ˜¯æ‰€æœ‰æ ‡å‡†åº“ä¸­çš„ç±»å‹éƒ½é»˜è®¤ä½¿ç”¨ `Arc<T>` å®ç°ï¼ŸåŸå› åœ¨äºçº¿ç¨‹å®‰å…¨å¸¦æœ‰æ€§èƒ½æŸå¤±ã€‚

```rust
use std::sync::{Mutex, Arc};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}

```

##### `RefCell<T>`/`Rc<T>` ä¸ `Mutex<T>`/`Arc<T>` çš„ç›¸ä¼¼æ€§

å› ä¸º counter æ˜¯ä¸å¯å˜çš„ï¼Œä¸è¿‡å¯ä»¥è·å–å…¶å†…éƒ¨å€¼çš„å¯å˜å¼•ç”¨ï¼›è¿™æ„å‘³ç€ `Mutex<T>` æä¾›äº†å†…éƒ¨å¯å˜æ€§ï¼Œå°±åƒ Cell ç³»åˆ—ç±»å‹é‚£æ ·ã€‚æ­£å¦‚ä¸­ä½¿ç”¨ `RefCell<T>` å¯ä»¥æ”¹å˜ `Rc<T>` ä¸­çš„å†…å®¹é‚£æ ·ï¼ŒåŒæ ·çš„å¯ä»¥ä½¿ç”¨ `Mutex<T>` æ¥æ”¹å˜ `Arc<T>` ä¸­çš„å†…å®¹ã€‚

å¦ä¸€ä¸ªå€¼å¾—æ³¨æ„çš„ç»†èŠ‚æ˜¯ Rust ä¸èƒ½é¿å…ä½¿ç”¨ `Mutex<T>` çš„å…¨éƒ¨é€»è¾‘é”™è¯¯ã€‚å›å¿†ä¸€ä¸‹ä½¿ç”¨ `Rc<T>` å°±æœ‰é€ æˆå¼•ç”¨å¾ªç¯çš„é£é™©ï¼Œè¿™æ—¶ä¸¤ä¸ª `Rc<T>` å€¼ç›¸äº’å¼•ç”¨ï¼Œé€ æˆå†…å­˜æ³„éœ²ã€‚åŒç†ï¼Œ`Mutex<T>` ä¹Ÿæœ‰é€ æˆ æ­»é”ï¼ˆdeadlockï¼‰ çš„é£é™©ã€‚è¿™å‘ç”Ÿäºå½“ä¸€ä¸ªæ“ä½œéœ€è¦é”ä½ä¸¤ä¸ªèµ„æºè€Œä¸¤ä¸ªçº¿ç¨‹å„æŒä¸€ä¸ªé”ï¼Œè¿™ä¼šé€ æˆå®ƒä»¬æ°¸è¿œç›¸äº’ç­‰å¾…ã€‚å¦‚æœå¯¹è¿™ä¸ªä¸»é¢˜æ„Ÿå…´è¶£ï¼Œå°è¯•ç¼–å†™ä¸€ä¸ªå¸¦æœ‰æ­»é”çš„ Rust ç¨‹åºï¼Œæ¥ç€ç ”ç©¶ä»»ä½•å…¶ä»–è¯­è¨€ä¸­ä½¿ç”¨äº’æ–¥å™¨çš„æ­»é”è§„é¿ç­–ç•¥å¹¶å°è¯•åœ¨ Rust ä¸­å®ç°ä»–ä»¬ã€‚æ ‡å‡†åº“ä¸­ `Mutex<T>`å’Œ `MutexGuard` çš„ API æ–‡æ¡£ä¼šæä¾›æœ‰ç”¨çš„ä¿¡æ¯ã€‚

#### ä½¿ç”¨ Sync å’Œ Send trait çš„å¯æ‰©å±•å¹¶å‘

Rust çš„å¹¶å‘æ¨¡å‹ä¸­ä¸€ä¸ªæœ‰è¶£çš„æ–¹é¢æ˜¯ï¼šè¯­è¨€æœ¬èº«å¯¹å¹¶å‘çŸ¥ä¹‹ ç”šå°‘ã€‚ä¹‹å‰è®¨è®ºçš„å‡ ä¹æ‰€æœ‰å†…å®¹ï¼Œéƒ½å±äºæ ‡å‡†åº“ï¼Œè€Œä¸æ˜¯è¯­è¨€æœ¬èº«çš„å†…å®¹ã€‚ç”±äºä¸éœ€è¦è¯­è¨€æä¾›å¹¶å‘ç›¸å…³çš„åŸºç¡€è®¾æ–½ï¼Œå¹¶å‘æ–¹æ¡ˆä¸å—æ ‡å‡†åº“æˆ–è¯­è¨€æ‰€é™ï¼šå¯ä»¥ç¼–å†™è‡ªå·±çš„æˆ–ä½¿ç”¨åˆ«äººç¼–å†™çš„å¹¶å‘åŠŸèƒ½ã€‚

ç„¶è€Œæœ‰ä¸¤ä¸ªå¹¶å‘æ¦‚å¿µæ˜¯å†…åµŒäºè¯­è¨€ä¸­çš„ï¼šstd::marker ä¸­çš„ Sync å’Œ Send traitã€‚

##### é€šè¿‡ Send å…è®¸åœ¨çº¿ç¨‹é—´è½¬ç§»æ‰€æœ‰æƒ

Send æ ‡è®° trait è¡¨æ˜ç±»å‹çš„æ‰€æœ‰æƒå¯ä»¥åœ¨çº¿ç¨‹é—´ä¼ é€’ã€‚å‡ ä¹æ‰€æœ‰çš„ Rust ç±»å‹éƒ½æ˜¯Send çš„ï¼Œä¸è¿‡æœ‰ä¸€äº›ä¾‹å¤–ï¼ŒåŒ…æ‹¬ `Rc<T>`ï¼šè¿™æ˜¯ä¸èƒ½ Send çš„ï¼Œå› ä¸ºå¦‚æœå…‹éš†äº† `Rc<T>` çš„å€¼å¹¶å°è¯•å°†å…‹éš†çš„æ‰€æœ‰æƒè½¬ç§»åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ï¼Œè¿™ä¸¤ä¸ªçº¿ç¨‹éƒ½å¯èƒ½åŒæ—¶æ›´æ–°å¼•ç”¨è®¡æ•°ã€‚ä¸ºæ­¤ï¼Œ`Rc<T>` è¢«å®ç°ä¸ºç”¨äºå•çº¿ç¨‹åœºæ™¯ï¼Œè¿™æ—¶ä¸éœ€è¦ä¸ºæ‹¥æœ‰çº¿ç¨‹å®‰å…¨çš„å¼•ç”¨è®¡æ•°è€Œä»˜å‡ºæ€§èƒ½ä»£ä»·ã€‚

å› æ­¤ï¼ŒRust ç±»å‹ç³»ç»Ÿå’Œ trait bound ç¡®ä¿æ°¸è¿œä¹Ÿä¸ä¼šæ„å¤–çš„å°†ä¸å®‰å…¨çš„ `Rc<T>` åœ¨çº¿ç¨‹é—´å‘é€ã€‚å½“å°è¯•åœ¨ç¤ºä¾‹ 16-14 ä¸­è¿™ä¹ˆåšçš„æ—¶å€™ï¼Œä¼šå¾—åˆ°é”™è¯¯ `the trait Send is not implemented for Rc<Mutex<i32>>`ã€‚è€Œä½¿ç”¨æ ‡è®°ä¸º `Send` çš„ `Arc<T>` æ—¶ï¼Œå°±æ²¡æœ‰é—®é¢˜äº†ã€‚

ä»»ä½•å®Œå…¨ç”± `Send` çš„ç±»å‹ç»„æˆçš„ç±»å‹ä¹Ÿä¼šè‡ªåŠ¨è¢«æ ‡è®°ä¸º `Send`ã€‚å‡ ä¹æ‰€æœ‰åŸºæœ¬ç±»å‹éƒ½æ˜¯ `Send` çš„ï¼Œ

#### Sync å…è®¸å¤šçº¿ç¨‹è®¿é—®

Sync æ ‡è®° trait è¡¨æ˜ä¸€ä¸ªå®ç°äº† Sync çš„ç±»å‹å¯ä»¥å®‰å…¨çš„åœ¨å¤šä¸ªçº¿ç¨‹ä¸­æ‹¥æœ‰å…¶å€¼çš„å¼•ç”¨ã€‚æ¢ä¸€ç§æ–¹å¼æ¥è¯´ï¼Œå¯¹äºä»»æ„ç±»å‹ Tï¼Œå¦‚æœ &Tï¼ˆT çš„å¼•ç”¨ï¼‰æ˜¯ Send çš„è¯ T å°±æ˜¯ Sync çš„ï¼Œè¿™æ„å‘³ç€å…¶å¼•ç”¨å°±å¯ä»¥å®‰å…¨çš„å‘é€åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ã€‚ç±»ä¼¼äº Send çš„æƒ…å†µï¼ŒåŸºæœ¬ç±»å‹æ˜¯ Sync çš„ï¼Œå®Œå…¨ç”± Sync çš„ç±»å‹ç»„æˆçš„ç±»å‹ä¹Ÿæ˜¯ Sync çš„ã€‚

é€šå¸¸å¹¶ä¸éœ€è¦æ‰‹åŠ¨å®ç° Send å’Œ Sync traitï¼Œå› ä¸ºç”± Send å’Œ Sync çš„ç±»å‹ç»„æˆçš„ç±»å‹ï¼Œè‡ªåŠ¨å°±æ˜¯ Send å’Œ Sync çš„ã€‚å› ä¸ºä»–ä»¬æ˜¯æ ‡è®° traitï¼Œç”šè‡³éƒ½ä¸éœ€è¦å®ç°ä»»ä½•æ–¹æ³•ã€‚ä»–ä»¬åªæ˜¯ç”¨æ¥åŠ å¼ºå¹¶å‘ç›¸å…³çš„ä¸å¯å˜æ€§çš„ã€‚

### Rust çš„é¢å‘å¯¹è±¡ç‰¹æ€§

Rust è¢«å¾ˆå¤šä¸åŒçš„ç¼–ç¨‹èŒƒå¼å½±å“ï¼ŒåŒ…æ‹¬é¢å‘å¯¹è±¡ç¼–ç¨‹ï¼›å‡½æ•°å¼ç¼–ç¨‹çš„ç‰¹æ€§ã€‚

#### å¯¹è±¡åŒ…å«æ•°æ®å’Œè¡Œä¸º

é¢å‘å¯¹è±¡çš„ç¨‹åºæ˜¯ç”±å¯¹è±¡ç»„æˆçš„ã€‚ä¸€ä¸ª å¯¹è±¡ åŒ…å«æ•°æ®å’Œæ“ä½œè¿™äº›æ•°æ®çš„è¿‡ç¨‹ã€‚è¿™äº›è¿‡ç¨‹é€šå¸¸è¢«ç§°ä¸º æ–¹æ³• æˆ– æ“ä½œã€‚

Rust æ˜¯é¢å‘å¯¹è±¡çš„ï¼šç»“æ„ä½“å’Œæšä¸¾åŒ…å«æ•°æ®è€Œ impl å—æä¾›äº†åœ¨ç»“æ„ä½“å’Œæšä¸¾ä¹‹ä¸Šçš„æ–¹æ³•ã€‚è™½ç„¶å¸¦æœ‰æ–¹æ³•çš„ç»“æ„ä½“å’Œæšä¸¾å¹¶ä¸è¢« ç§°ä¸º å¯¹è±¡ï¼Œä½†æ˜¯ä»–ä»¬æä¾›äº†ä¸å¯¹è±¡ç›¸åŒçš„åŠŸèƒ½ï¼Œ

#### å°è£…éšè—äº†å®ç°ç»†èŠ‚

å¦ä¸€ä¸ªé€šå¸¸ä¸é¢å‘å¯¹è±¡ç¼–ç¨‹ç›¸å…³çš„æ–¹é¢æ˜¯ å°è£…ï¼ˆencapsulationï¼‰çš„æ€æƒ³ï¼šå¯¹è±¡çš„å®ç°ç»†èŠ‚ä¸èƒ½è¢«ä½¿ç”¨å¯¹è±¡çš„ä»£ç è·å–åˆ°ã€‚æ‰€ä»¥å”¯ä¸€ä¸å¯¹è±¡äº¤äº’çš„æ–¹å¼æ˜¯é€šè¿‡å¯¹è±¡æä¾›çš„å…¬æœ‰ APIï¼›ä½¿ç”¨å¯¹è±¡çš„ä»£ç æ— æ³•æ·±å…¥åˆ°å¯¹è±¡å†…éƒ¨å¹¶ç›´æ¥æ”¹å˜æ•°æ®æˆ–è€…è¡Œä¸ºã€‚å°è£…ä½¿å¾—æ”¹å˜å’Œé‡æ„å¯¹è±¡çš„å†…éƒ¨æ—¶æ— éœ€æ”¹å˜ä½¿ç”¨å¯¹è±¡çš„ä»£ç ã€‚

Rustå¯ä»¥ä½¿ç”¨ pub å…³é”®å­—æ¥å†³å®šæ¨¡å—ã€ç±»å‹ã€å‡½æ•°å’Œæ–¹æ³•æ˜¯å…¬æœ‰çš„ï¼Œè€Œé»˜è®¤æƒ…å†µä¸‹å…¶ä»–ä¸€åˆ‡éƒ½æ˜¯ç§æœ‰çš„ã€‚

æ¯”å¦‚ï¼Œå¯ä»¥å®šä¹‰ä¸€ä¸ªåŒ…å«ä¸€ä¸ª i32 ç±»å‹ vector çš„ç»“æ„ä½“ AveragedCollectionã€‚ç»“æ„ä½“ä¹Ÿå¯ä»¥æœ‰ä¸€ä¸ªå­—æ®µï¼Œè¯¥å­—æ®µä¿å­˜äº† vector ä¸­æ‰€æœ‰å€¼çš„å¹³å‡å€¼ã€‚è¿™æ ·ï¼Œå¸Œæœ›çŸ¥é“ç»“æ„ä½“ä¸­çš„ vector çš„å¹³å‡å€¼çš„äººå¯ä»¥éšæ—¶è·å–å®ƒï¼Œè€Œæ— éœ€è‡ªå·±è®¡ç®—ã€‚æ¢å¥è¯è¯´ï¼ŒAveragedCollection ä¼šä¸ºç¼“å­˜å¹³å‡å€¼ç»“æœã€‚

```rust

#![allow(unused_variables)]
fn main() {
pub struct AveragedCollection {
    list: Vec<i32>,
    average: f64,
}
}
```

æ³¨æ„ï¼Œç»“æ„ä½“è‡ªèº«è¢«æ ‡è®°ä¸º pubï¼Œè¿™æ ·å…¶ä»–ä»£ç å°±å¯ä»¥ä½¿ç”¨è¿™ä¸ªç»“æ„ä½“ï¼Œä½†æ˜¯åœ¨ç»“æ„ä½“å†…éƒ¨çš„å­—æ®µä»ç„¶æ˜¯ç§æœ‰çš„ã€‚è¿™æ˜¯éå¸¸é‡è¦çš„ï¼Œå› ä¸ºå¸Œæœ›ä¿è¯å˜é‡è¢«å¢åŠ åˆ°åˆ—è¡¨æˆ–è€…è¢«ä»åˆ—è¡¨åˆ é™¤æ—¶ï¼Œä¹Ÿä¼šåŒæ—¶æ›´æ–°å¹³å‡å€¼ã€‚å¯ä»¥é€šè¿‡åœ¨ç»“æ„ä½“ä¸Šå®ç° addã€remove å’Œ average æ–¹æ³•æ¥åšåˆ°è¿™ä¸€ç‚¹ï¼Œ

```rust

#![allow(unused_variables)]
fn main() {
pub struct AveragedCollection {
    list: Vec<i32>,
    average: f64,
}
impl AveragedCollection {
    pub fn add(&mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&mut self) -> Option<i32> {
        let result = self.list.pop();
        match result {
            Some(value) => {
                self.update_average();
                Some(value)
            },
            None => None,
        }
    }

    pub fn average(&self) -> f64 {
        self.average
    }

    fn update_average(&mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
}
```
å…¬æœ‰æ–¹æ³• addã€remove å’Œ average æ˜¯ä¿®æ”¹ AveragedCollection å®ä¾‹çš„å”¯ä¸€æ–¹å¼ã€‚å½“ä½¿ç”¨ add æ–¹æ³•æŠŠä¸€ä¸ªå…ƒç´ åŠ å…¥åˆ° list æˆ–è€…ä½¿ç”¨ remove æ–¹æ³•æ¥åˆ é™¤æ—¶ï¼Œè¿™äº›æ–¹æ³•çš„å®ç°åŒæ—¶ä¼šè°ƒç”¨ç§æœ‰çš„ update_average æ–¹æ³•æ¥æ›´æ–° average å­—æ®µã€‚

list å’Œ average æ˜¯ç§æœ‰çš„ï¼Œæ‰€ä»¥æ²¡æœ‰å…¶ä»–æ–¹å¼æ¥ä½¿å¾—å¤–éƒ¨çš„ä»£ç ç›´æ¥å‘ list å¢åŠ æˆ–è€…åˆ é™¤å…ƒç´ ï¼Œå¦åˆ™ list æ”¹å˜æ—¶å¯èƒ½ä¼šå¯¼è‡´ average å­—æ®µä¸åŒæ­¥ã€‚average æ–¹æ³•è¿”å› average å­—æ®µçš„å€¼ï¼Œè¿™ä½¿å¾—å¤–éƒ¨çš„ä»£ç åªèƒ½è¯»å– average è€Œä¸èƒ½ä¿®æ”¹å®ƒã€‚

å› ä¸ºå·²ç»å°è£…å¥½äº† AveragedCollection çš„å®ç°ç»†èŠ‚ï¼Œå°†æ¥å¯ä»¥è½»æ¾æ”¹å˜ç±»ä¼¼æ•°æ®ç»“æ„è¿™äº›æ–¹é¢çš„å†…å®¹ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥ä½¿ç”¨ `HashSet<i32>` ä»£æ›¿ `Vec<i32>` ä½œä¸º list å­—æ®µçš„ç±»å‹ã€‚åªè¦ addã€remove å’Œ average å…¬æœ‰å‡½æ•°çš„ç­¾åä¿æŒä¸å˜ï¼Œä½¿ç”¨ AveragedCollection çš„ä»£ç å°±æ— éœ€æ”¹å˜ã€‚ç›¸åå¦‚æœä½¿å¾— list ä¸ºå…¬æœ‰ï¼Œå°±æœªå¿…éƒ½ä¼šå¦‚æ­¤äº†ï¼š `HashSet<i32>` å’Œ `Vec<i32>` ä½¿ç”¨ä¸åŒçš„æ–¹æ³•å¢åŠ æˆ–ç§»é™¤é¡¹ï¼Œæ‰€ä»¥å¦‚æœè¦æƒ³ç›´æ¥ä¿®æ”¹ list çš„è¯ï¼Œå¤–éƒ¨çš„ä»£ç å¯èƒ½ä¸å¾—ä¸åšå‡ºä¿®æ”¹ã€‚

å¦‚æœå°è£…æ˜¯ä¸€ä¸ªè¯­è¨€è¢«è®¤ä¸ºæ˜¯é¢å‘å¯¹è±¡è¯­è¨€æ‰€å¿…è¦çš„æ–¹é¢çš„è¯ï¼Œé‚£ä¹ˆ Rust æ»¡è¶³è¿™ä¸ªè¦æ±‚ã€‚åœ¨ä»£ç ä¸­ä¸åŒçš„éƒ¨åˆ†ä½¿ç”¨ pub ä¸å¦å¯ä»¥å°è£…å…¶å®ç°ç»†èŠ‚ã€‚

#### ç»§æ‰¿ï¼Œä½œä¸ºç±»å‹ç³»ç»Ÿä¸ä»£ç å…±äº«

ç»§æ‰¿ï¼ˆInheritanceï¼‰æ˜¯ä¸€ä¸ªå¾ˆå¤šç¼–ç¨‹è¯­è¨€éƒ½æä¾›çš„æœºåˆ¶ï¼Œä¸€ä¸ªå¯¹è±¡å¯ä»¥å®šä¹‰ä¸ºç»§æ‰¿å¦ä¸€ä¸ªå¯¹è±¡çš„å®šä¹‰ï¼Œè¿™ä½¿å…¶å¯ä»¥è·å¾—çˆ¶å¯¹è±¡çš„æ•°æ®å’Œè¡Œä¸ºï¼Œè€Œæ— éœ€é‡æ–°å®šä¹‰ã€‚

å¦‚æœä¸€ä¸ªè¯­è¨€å¿…é¡»æœ‰ç»§æ‰¿æ‰èƒ½è¢«ç§°ä¸ºé¢å‘å¯¹è±¡è¯­è¨€çš„è¯ï¼Œé‚£ä¹ˆ Rust å°±ä¸æ˜¯é¢å‘å¯¹è±¡çš„ã€‚æ— æ³•å®šä¹‰ä¸€ä¸ªç»“æ„ä½“ç»§æ‰¿çˆ¶ç»“æ„ä½“çš„æˆå‘˜å’Œæ–¹æ³•ã€‚ç„¶è€Œï¼Œå¦‚æœè¿‡å»å¸¸å¸¸åœ¨çš„ç¼–ç¨‹å·¥å…·ç®±ä½¿ç”¨ç»§æ‰¿ï¼Œæ ¹æ®æœ€åˆè€ƒè™‘ç»§æ‰¿çš„åŸå› ï¼ŒRust ä¹Ÿæä¾›äº†å…¶ä»–çš„è§£å†³æ–¹æ¡ˆã€‚

é€‰æ‹©ç»§æ‰¿æœ‰ä¸¤ä¸ªä¸»è¦çš„åŸå› ã€‚ç¬¬ä¸€ä¸ªæ˜¯ä¸ºäº†é‡ç”¨ä»£ç ï¼šä¸€æ—¦ä¸ºä¸€ä¸ªç±»å‹å®ç°äº†ç‰¹å®šè¡Œä¸ºï¼Œç»§æ‰¿å¯ä»¥å¯¹ä¸€ä¸ªä¸åŒçš„ç±»å‹é‡ç”¨è¿™ä¸ªå®ç°ã€‚ç›¸å Rust ä»£ç å¯ä»¥ä½¿ç”¨é»˜è®¤ trait æ–¹æ³•å®ç°æ¥è¿›è¡Œå…±äº«ï¼Œåœ¨ä¹‹å‰çš„ä¾‹å­ä¸­è§è¿‡åœ¨ Summary trait ä¸Šå¢åŠ çš„ summarize æ–¹æ³•çš„é»˜è®¤å®ç°ã€‚ä»»ä½•å®ç°äº† Summary trait çš„ç±»å‹éƒ½å¯ä»¥ä½¿ç”¨ summarize æ–¹æ³•è€Œæ— é¡»è¿›ä¸€æ­¥å®ç°ã€‚è¿™ç±»ä¼¼äºçˆ¶ç±»æœ‰ä¸€ä¸ªæ–¹æ³•çš„å®ç°ï¼Œè€Œé€šè¿‡ç»§æ‰¿å­ç±»ä¹Ÿæ‹¥æœ‰è¿™ä¸ªæ–¹æ³•çš„å®ç°ã€‚å½“å®ç° Summary trait æ—¶ä¹Ÿå¯ä»¥é€‰æ‹©è¦†ç›– summarize çš„é»˜è®¤å®ç°ï¼Œè¿™ç±»ä¼¼äºå­ç±»è¦†ç›–ä»çˆ¶ç±»ç»§æ‰¿çš„æ–¹æ³•å®ç°ã€‚

ç¬¬äºŒä¸ªä½¿ç”¨ç»§æ‰¿çš„åŸå› ä¸ç±»å‹ç³»ç»Ÿæœ‰å…³ï¼šè¡¨ç°ä¸ºå­ç±»å‹å¯ä»¥ç”¨äºçˆ¶ç±»å‹è¢«ä½¿ç”¨çš„åœ°æ–¹ã€‚è¿™ä¹Ÿè¢«ç§°ä¸º å¤šæ€ï¼ˆpolymorphismï¼‰ï¼Œè¿™æ„å‘³ç€å¦‚æœå¤šç§å¯¹è±¡å…±äº«ç‰¹å®šçš„å±æ€§ï¼Œåˆ™å¯ä»¥ç›¸äº’æ›¿ä»£ä½¿ç”¨ã€‚

å¾ˆå¤šäººå°†å¤šæ€æè¿°ä¸ºç»§æ‰¿çš„åŒä¹‰è¯ã€‚ä¸è¿‡å®ƒæ˜¯ä¸€ä¸ªæœ‰å…³å¯ä»¥ç”¨äºå¤šç§ç±»å‹çš„ä»£ç çš„æ›´å¹¿æ³›çš„æ¦‚å¿µã€‚å¯¹äºç»§æ‰¿æ¥è¯´ï¼Œè¿™äº›ç±»å‹é€šå¸¸æ˜¯å­ç±»ã€‚ Rust åˆ™é€šè¿‡æ³›å‹æ¥å¯¹ä¸åŒçš„å¯èƒ½ç±»å‹è¿›è¡ŒæŠ½è±¡ï¼Œå¹¶é€šè¿‡ trait bounds å¯¹è¿™äº›ç±»å‹æ‰€å¿…é¡»æä¾›çš„å†…å®¹æ–½åŠ çº¦æŸã€‚è¿™æœ‰æ—¶è¢«ç§°ä¸º bounded parametric polymorphismã€‚

è¿‘æ¥ç»§æ‰¿ä½œä¸ºä¸€ç§è¯­è¨€è®¾è®¡çš„è§£å†³æ–¹æ¡ˆåœ¨å¾ˆå¤šè¯­è¨€ä¸­å¤±å® äº†ï¼Œå› ä¸ºå…¶æ—¶å¸¸å¸¦æœ‰å…±äº«å¤šäºæ‰€éœ€çš„ä»£ç çš„é£é™©ã€‚å­ç±»ä¸åº”æ€»æ˜¯å…±äº«å…¶çˆ¶ç±»çš„æ‰€æœ‰ç‰¹å¾ï¼Œä½†æ˜¯ç»§æ‰¿å´å§‹ç»ˆå¦‚æ­¤ã€‚å¦‚æ­¤ä¼šä½¿ç¨‹åºè®¾è®¡æ›´ä¸ºä¸çµæ´»ï¼Œå¹¶å¼•å…¥æ— æ„ä¹‰çš„å­ç±»æ–¹æ³•è°ƒç”¨ï¼Œæˆ–ç”±äºæ–¹æ³•å®é™…å¹¶ä¸é€‚ç”¨äºå­ç±»è€Œé€ æˆé”™è¯¯çš„å¯èƒ½æ€§ã€‚æŸäº›è¯­è¨€è¿˜åªå…è®¸å­ç±»ç»§æ‰¿ä¸€ä¸ªçˆ¶ç±»ï¼Œè¿›ä¸€æ­¥é™åˆ¶äº†ç¨‹åºè®¾è®¡çš„çµæ´»æ€§ã€‚

å› ä¸ºè¿™äº›åŸå› ï¼ŒRust é€‰æ‹©äº†ä¸€ä¸ªä¸åŒçš„é€”å¾„ï¼Œä½¿ç”¨ trait å¯¹è±¡è€Œä¸æ˜¯ç»§æ‰¿ã€‚çœ‹ä¸€ä¸‹ Rust ä¸­çš„ trait å¯¹è±¡æ˜¯å¦‚ä½•å®ç°å¤šæ€çš„ã€‚

#### ä¸ºä½¿ç”¨ä¸åŒç±»å‹çš„å€¼è€Œè®¾è®¡çš„ trait å¯¹è±¡


```rust

#![allow(unused_variables)]
fn main() {
pub trait Draw {
    fn draw(&self);
}

pub struct Screen {
    pub components: Vec<Box<dyn Draw>>,
}

impl Screen {
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
}
```

è¿™ä¸å®šä¹‰ä½¿ç”¨äº†å¸¦æœ‰ trait bound çš„æ³›å‹ç±»å‹å‚æ•°çš„ç»“æ„ä½“ä¸åŒã€‚æ³›å‹ç±»å‹å‚æ•°ä¸€æ¬¡åªèƒ½æ›¿ä»£ä¸€ä¸ªå…·ä½“ç±»å‹ï¼Œè€Œ trait å¯¹è±¡åˆ™å…è®¸åœ¨è¿è¡Œæ—¶æ›¿ä»£å¤šç§å…·ä½“ç±»å‹ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥å®šä¹‰ Screen ç»“æ„ä½“æ¥ä½¿ç”¨æ³›å‹å’Œ trait boundï¼Œå¦‚ä¸‹ä¾‹æ‰€ç¤ºï¼š

```rust

#![allow(unused_variables)]
fn main() {
pub trait Draw {
    fn draw(&self);
}

pub struct Screen<T: Draw> {
    pub components: Vec<T>,
}

impl<T> Screen<T>
    where T: Draw {
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
}
```

è¿™é™åˆ¶äº† Screen å®ä¾‹å¿…é¡»æ‹¥æœ‰ä¸€ä¸ªå…¨æ˜¯ Button ç±»å‹æˆ–è€…å…¨æ˜¯ TextField ç±»å‹çš„ç»„ä»¶åˆ—è¡¨ã€‚å¦‚æœåªéœ€è¦åŒè´¨ï¼ˆç›¸åŒç±»å‹ï¼‰é›†åˆï¼Œåˆ™å€¾å‘äºä½¿ç”¨æ³›å‹å’Œ trait boundï¼Œå› ä¸ºå…¶å®šä¹‰ä¼šåœ¨ç¼–è¯‘æ—¶é‡‡ç”¨å…·ä½“ç±»å‹è¿›è¡Œå•æ€åŒ–ã€‚

å¦ä¸€æ–¹é¢ï¼Œé€šè¿‡ä½¿ç”¨ trait å¯¹è±¡çš„æ–¹æ³•ï¼Œä¸€ä¸ª Screen å®ä¾‹å¯ä»¥å­˜æ”¾ä¸€ä¸ªæ—¢èƒ½åŒ…å« `Box<Button>`ï¼Œä¹Ÿèƒ½åŒ…å« `Box<TextField>` çš„ `Vec<T>`ã€‚çœ‹çœ‹å®ƒæ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Œæ¥ç€ä¼šè®²åˆ°å…¶è¿è¡Œæ—¶æ€§èƒ½å½±å“ã€‚

#### å®ç° trait

ç°åœ¨æ¥å¢åŠ ä¸€äº›å®ç°äº† Draw trait çš„ç±»å‹ã€‚å°†æä¾› Button ç±»å‹ã€‚å†ä¸€æ¬¡é‡ç”³ï¼ŒçœŸæ­£å®ç° GUI åº“è¶…å‡ºäº†æœ¬ä¹¦çš„èŒƒç•´ï¼Œæ‰€ä»¥ draw æ–¹æ³•ä½“ä¸­ä¸ä¼šæœ‰ä»»ä½•æœ‰æ„ä¹‰çš„å®ç°ã€‚ä¸ºäº†æƒ³è±¡ä¸€ä¸‹è¿™ä¸ªå®ç°çœ‹èµ·æ¥åƒä»€ä¹ˆï¼Œä¸€ä¸ª Button ç»“æ„ä½“å¯èƒ½ä¼šæ‹¥æœ‰ widthã€height å’Œ label å­—æ®µï¼Œ

```rust

#![allow(unused_variables)]
fn main() {
pub trait Draw {
    fn draw(&self);
}

pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&self) {
        // å®é™…ç»˜åˆ¶æŒ‰é’®çš„ä»£ç 
    }
}
}
```

åœ¨ Button ä¸Šçš„ widthã€height å’Œ label å­—æ®µä¼šå’Œå…¶ä»–ç»„ä»¶ä¸åŒï¼Œæ¯”å¦‚ TextField å¯èƒ½æœ‰ widthã€heightã€label ä»¥åŠ placeholder å­—æ®µã€‚æ¯ä¸€ä¸ªå¸Œæœ›èƒ½åœ¨å±å¹•ä¸Šç»˜åˆ¶çš„ç±»å‹éƒ½ä¼šä½¿ç”¨ä¸åŒçš„ä»£ç æ¥å®ç° Draw trait çš„ draw æ–¹æ³•æ¥å®šä¹‰å¦‚ä½•ç»˜åˆ¶ç‰¹å®šçš„ç±»å‹ï¼Œåƒè¿™é‡Œçš„ Button ç±»å‹ï¼ˆå¹¶ä¸åŒ…å«ä»»ä½•å®é™…çš„ GUI ä»£ç ï¼Œè¿™è¶…å‡ºäº†æœ¬ç« çš„èŒƒç•´ï¼‰ã€‚é™¤äº†å®ç° Draw trait ä¹‹å¤–ï¼Œæ¯”å¦‚ Button è¿˜å¯èƒ½æœ‰å¦ä¸€ä¸ªåŒ…å«æŒ‰é’®ç‚¹å‡»å¦‚ä½•å“åº”çš„æ–¹æ³•çš„ impl å—ã€‚è¿™ç±»æ–¹æ³•å¹¶ä¸é€‚ç”¨äºåƒ TextField è¿™æ ·çš„ç±»å‹ã€‚

å¦‚æœä¸€äº›åº“çš„ä½¿ç”¨è€…å†³å®šå®ç°ä¸€ä¸ªåŒ…å« widthã€height å’Œ options å­—æ®µçš„ç»“æ„ä½“ SelectBoxï¼Œå¹¶ä¸”ä¹Ÿä¸ºå…¶å®ç°äº† Draw traitï¼Œå¦‚ä¸‹ä¾‹æ‰€ç¤ºï¼š

```rust
use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec<String>,
}

impl Draw for SelectBox {
    fn draw(&self) {
        // code to actually draw a select box
    }
}

```

åº“ä½¿ç”¨è€…ç°åœ¨å¯ä»¥åœ¨ä»–ä»¬çš„ main å‡½æ•°ä¸­åˆ›å»ºä¸€ä¸ª Screen å®ä¾‹ã€‚è‡³æ­¤å¯ä»¥é€šè¿‡å°† SelectBox å’Œ Button æ”¾å…¥ `Box<T>` è½¬å˜ä¸º trait å¯¹è±¡æ¥å¢åŠ ç»„ä»¶ã€‚æ¥ç€å¯ä»¥è°ƒç”¨ Screen çš„ run æ–¹æ³•ï¼Œå®ƒä¼šè°ƒç”¨æ¯ä¸ªç»„ä»¶çš„ draw æ–¹æ³•ã€‚å¦‚ä¸‹æ‰€ç¤º:

```rust
use gui::{Screen, Button};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from("Yes"),
                    String::from("Maybe"),
                    String::from("No")
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from("OK"),
            }),
        ],
    };

    screen.run();
}

```

å½“ç¼–å†™åº“çš„æ—¶å€™ï¼Œä¸çŸ¥é“ä½•äººä¼šåœ¨ä½•æ—¶å¢åŠ  SelectBox ç±»å‹ï¼Œä¸è¿‡ Screen çš„å®ç°èƒ½å¤Ÿæ“ä½œå¹¶ç»˜åˆ¶è¿™ä¸ªæ–°ç±»å‹ï¼Œå› ä¸º SelectBox å®ç°äº† Draw traitï¼Œè¿™æ„å‘³ç€å®ƒå®ç°äº† draw æ–¹æ³•ã€‚

è¿™ä¸ªæ¦‚å¿µ â€”â€” åªå…³å¿ƒå€¼æ‰€åæ˜ çš„ä¿¡æ¯è€Œä¸æ˜¯å…¶å…·ä½“ç±»å‹ â€”â€” ç±»ä¼¼äºåŠ¨æ€ç±»å‹è¯­è¨€ä¸­ç§°ä¸º é¸­å­ç±»å‹ï¼ˆduck typingï¼‰çš„æ¦‚å¿µï¼šå¦‚æœå®ƒèµ°èµ·æ¥åƒä¸€åªé¸­å­ï¼Œå«èµ·æ¥åƒä¸€åªé¸­å­ï¼Œé‚£ä¹ˆå®ƒå°±æ˜¯ä¸€åªé¸­å­ï¼åœ¨ç¤ºä¾‹ 17-5 ä¸­ Screen ä¸Šçš„ run å®ç°ä¸­ï¼Œrun å¹¶ä¸éœ€è¦çŸ¥é“å„ä¸ªç»„ä»¶çš„å…·ä½“ç±»å‹æ˜¯ä»€ä¹ˆã€‚å®ƒå¹¶ä¸æ£€æŸ¥ç»„ä»¶æ˜¯ Button æˆ–è€… SelectBox çš„å®ä¾‹ã€‚é€šè¿‡æŒ‡å®š `Box<dyn Draw>` ä½œä¸º components vector ä¸­å€¼çš„ç±»å‹ï¼Œå°±å®šä¹‰äº† Screen ä¸ºéœ€è¦å¯ä»¥åœ¨å…¶ä¸Šè°ƒç”¨ draw æ–¹æ³•çš„å€¼ã€‚

ä½¿ç”¨ trait å¯¹è±¡å’Œ Rust ç±»å‹ç³»ç»Ÿæ¥è¿›è¡Œç±»ä¼¼é¸­å­ç±»å‹æ“ä½œçš„ä¼˜åŠ¿æ˜¯æ— éœ€åœ¨è¿è¡Œæ—¶æ£€æŸ¥ä¸€ä¸ªå€¼æ˜¯å¦å®ç°äº†ç‰¹å®šæ–¹æ³•æˆ–è€…æ‹…å¿ƒåœ¨è°ƒç”¨æ—¶å› ä¸ºå€¼æ²¡æœ‰å®ç°æ–¹æ³•è€Œäº§ç”Ÿé”™è¯¯ã€‚å¦‚æœå€¼æ²¡æœ‰å®ç° trait å¯¹è±¡æ‰€éœ€çš„ trait åˆ™ Rust ä¸ä¼šç¼–è¯‘è¿™äº›ä»£ç ã€‚

#### trait å¯¹è±¡æ‰§è¡ŒåŠ¨æ€åˆ†å‘

å½“å¯¹æ³›å‹ä½¿ç”¨ trait bound æ—¶ç¼–è¯‘å™¨æ‰€è¿›è¡Œå•æ€åŒ–å¤„ç†ï¼šç¼–è¯‘å™¨ä¸ºæ¯ä¸€ä¸ªè¢«æ³›å‹ç±»å‹å‚æ•°ä»£æ›¿çš„å…·ä½“ç±»å‹ç”Ÿæˆäº†éæ³›å‹çš„å‡½æ•°å’Œæ–¹æ³•å®ç°ã€‚å•æ€åŒ–æ‰€äº§ç”Ÿçš„ä»£ç è¿›è¡Œ é™æ€åˆ†å‘ï¼ˆstatic dispatchï¼‰ã€‚é™æ€åˆ†å‘å‘ç”Ÿäºç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶å°±çŸ¥æ™“è°ƒç”¨äº†ä»€ä¹ˆæ–¹æ³•çš„æ—¶å€™ã€‚è¿™ä¸ åŠ¨æ€åˆ†å‘ ï¼ˆdynamic dispatchï¼‰ç›¸å¯¹ï¼Œè¿™æ—¶ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶æ— æ³•çŸ¥æ™“è°ƒç”¨äº†ä»€ä¹ˆæ–¹æ³•ã€‚åœ¨åŠ¨æ€åˆ†å‘çš„æƒ…å†µä¸‹ï¼Œç¼–è¯‘å™¨ä¼šç”Ÿæˆåœ¨è¿è¡Œæ—¶ç¡®å®šè°ƒç”¨äº†ä»€ä¹ˆæ–¹æ³•çš„ä»£ç ã€‚

å½“ä½¿ç”¨ trait å¯¹è±¡æ—¶ï¼ŒRust å¿…é¡»ä½¿ç”¨åŠ¨æ€åˆ†å‘ã€‚ç¼–è¯‘å™¨æ— æ³•çŸ¥æ™“æ‰€æœ‰å¯èƒ½ç”¨äº trait å¯¹è±¡ä»£ç çš„ç±»å‹ï¼Œæ‰€ä»¥å®ƒä¹Ÿä¸çŸ¥é“åº”è¯¥è°ƒç”¨å“ªä¸ªç±»å‹çš„å“ªä¸ªæ–¹æ³•å®ç°ã€‚ä¸ºæ­¤ï¼ŒRust åœ¨è¿è¡Œæ—¶ä½¿ç”¨ trait å¯¹è±¡ä¸­çš„æŒ‡é’ˆæ¥çŸ¥æ™“éœ€è¦è°ƒç”¨å“ªä¸ªæ–¹æ³•ã€‚åŠ¨æ€åˆ†å‘ä¹Ÿé˜»æ­¢ç¼–è¯‘å™¨æœ‰é€‰æ‹©çš„å†…è”æ–¹æ³•ä»£ç ï¼Œè¿™ä¼šç›¸åº”çš„ç¦ç”¨ä¸€äº›ä¼˜åŒ–ã€‚

#### Trait å¯¹è±¡è¦æ±‚å¯¹è±¡å®‰å…¨

åªæœ‰ å¯¹è±¡å®‰å…¨ï¼ˆobject safeï¼‰çš„ trait æ‰å¯ä»¥ç»„æˆ trait å¯¹è±¡ã€‚å›´ç»•æ‰€æœ‰ä½¿å¾— trait å¯¹è±¡å®‰å…¨çš„å±æ€§å­˜åœ¨ä¸€äº›å¤æ‚çš„è§„åˆ™ï¼Œä¸è¿‡åœ¨å®è·µä¸­ï¼Œåªæ¶‰åŠåˆ°ä¸¤æ¡è§„åˆ™ã€‚å¦‚æœä¸€ä¸ª trait ä¸­æ‰€æœ‰çš„æ–¹æ³•æœ‰å¦‚ä¸‹å±æ€§æ—¶ï¼Œåˆ™è¯¥ trait æ˜¯å¯¹è±¡å®‰å…¨çš„ï¼š

* è¿”å›å€¼ç±»å‹ä¸ä¸º Self
* æ–¹æ³•æ²¡æœ‰ä»»ä½•æ³›å‹ç±»å‹å‚æ•°
* 
Self å…³é”®å­—æ˜¯è¦å®ç° trait æˆ–æ–¹æ³•çš„ç±»å‹çš„åˆ«åã€‚å¯¹è±¡å®‰å…¨å¯¹äº trait å¯¹è±¡æ˜¯å¿…é¡»çš„ï¼Œå› ä¸ºä¸€æ—¦æœ‰äº† trait å¯¹è±¡ï¼Œå°±ä¸å†çŸ¥æ™“å®ç°è¯¥ trait çš„å…·ä½“ç±»å‹æ˜¯ä»€ä¹ˆäº†ã€‚å¦‚æœ trait æ–¹æ³•è¿”å›å…·ä½“çš„ Self ç±»å‹ï¼Œä½†æ˜¯ trait å¯¹è±¡å¿˜è®°äº†å…¶çœŸæ­£çš„ç±»å‹ï¼Œé‚£ä¹ˆæ–¹æ³•ä¸å¯èƒ½ä½¿ç”¨å·²ç»å¿˜å´çš„åŸå§‹å…·ä½“ç±»å‹ã€‚åŒç†å¯¹äºæ³›å‹ç±»å‹å‚æ•°æ¥è¯´ï¼Œå½“ä½¿ç”¨ trait æ—¶å…¶ä¼šæ”¾å…¥å…·ä½“çš„ç±»å‹å‚æ•°ï¼šæ­¤å…·ä½“ç±»å‹å˜æˆäº†å®ç°è¯¥ trait çš„ç±»å‹çš„ä¸€éƒ¨åˆ†ã€‚å½“ä½¿ç”¨ trait å¯¹è±¡æ—¶å…¶å…·ä½“ç±»å‹è¢«æŠ¹å»äº†ï¼Œæ•…æ— ä»å¾—çŸ¥æ”¾å…¥æ³›å‹å‚æ•°ç±»å‹çš„ç±»å‹æ˜¯ä»€ä¹ˆã€‚

ä¸€ä¸ª trait çš„æ–¹æ³•ä¸æ˜¯å¯¹è±¡å®‰å…¨çš„ä¾‹å­æ˜¯æ ‡å‡†åº“ä¸­çš„ Clone traitã€‚Clone trait çš„ clone æ–¹æ³•çš„å‚æ•°ç­¾åçœ‹èµ·æ¥åƒè¿™æ ·ï¼š

```rust

#![allow(unused_variables)]
fn main() {
pub trait Clone {
    fn clone(&self) -> Self;
}
}
```

String å®ç°äº† Clone traitï¼Œå½“åœ¨ String å®ä¾‹ä¸Šè°ƒç”¨ clone æ–¹æ³•æ—¶ä¼šå¾—åˆ°ä¸€ä¸ª String å®ä¾‹ã€‚ç±»ä¼¼çš„ï¼Œå½“è°ƒç”¨ `Vec<T>` å®ä¾‹çš„ clone æ–¹æ³•ä¼šå¾—åˆ°ä¸€ä¸ª `Vec<T>` å®ä¾‹ã€‚clone çš„ç­¾åéœ€è¦çŸ¥é“ä»€ä¹ˆç±»å‹ä¼šä»£æ›¿ Selfï¼Œå› ä¸ºè¿™æ˜¯å®ƒçš„è¿”å›å€¼ã€‚

å¦‚æœå°è¯•åšä¸€äº›è¿åæœ‰å…³ trait å¯¹è±¡çš„å¯¹è±¡å®‰å…¨è§„åˆ™çš„äº‹æƒ…ï¼Œç¼–è¯‘å™¨ä¼šäº§ç”Ÿæç¤ºã€‚å¦‚

```rust
pub struct Screen {
    pub components: Vec<Box<dyn Clone>>,
}

```

å°†ä¼šå¾—åˆ°å¦‚ä¸‹é”™è¯¯ï¼š

```rust
error[E0038]: the trait `std::clone::Clone` cannot be made into an object
 --> src/lib.rs:2:5
  |
2 |     pub components: Vec<Box<dyn Clone>>,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone`
  cannot be made into an object
  |
  = note: the trait cannot require that `Self : Sized`

```

#### é¢å‘å¯¹è±¡è®¾è®¡æ¨¡å¼çš„å®ç°

çŠ¶æ€æ¨¡å¼ï¼ˆstate patternï¼‰æ˜¯ä¸€ä¸ªé¢å‘å¯¹è±¡è®¾è®¡æ¨¡å¼ã€‚è¯¥æ¨¡å¼çš„å…³é”®åœ¨äºä¸€ä¸ªå€¼æœ‰æŸäº›å†…éƒ¨çŠ¶æ€ï¼Œä½“ç°ä¸ºä¸€ç³»åˆ—çš„ çŠ¶æ€å¯¹è±¡ï¼ŒåŒæ—¶å€¼çš„è¡Œä¸ºéšç€å…¶å†…éƒ¨çŠ¶æ€è€Œæ”¹å˜ã€‚çŠ¶æ€å¯¹è±¡å…±äº«åŠŸèƒ½ï¼šå½“ç„¶ï¼Œåœ¨ Rust ä¸­ä½¿ç”¨ç»“æ„ä½“å’Œ trait è€Œä¸æ˜¯å¯¹è±¡å’Œç»§æ‰¿ã€‚æ¯ä¸€ä¸ªçŠ¶æ€å¯¹è±¡ä»£è¡¨è´Ÿè´£å…¶è‡ªèº«çš„è¡Œä¸ºå’Œå½“éœ€è¦æ”¹å˜ä¸ºå¦ä¸€ä¸ªçŠ¶æ€æ—¶çš„è§„åˆ™çš„çŠ¶æ€ã€‚æŒæœ‰ä»»ä½•ä¸€ä¸ªè¿™ç§çŠ¶æ€å¯¹è±¡çš„å€¼å¯¹äºä¸åŒçŠ¶æ€çš„è¡Œä¸ºä»¥åŠä½•æ—¶çŠ¶æ€è½¬ç§»æ¯«ä¸çŸ¥æƒ…ã€‚

ä½¿ç”¨çŠ¶æ€æ¨¡å¼æ„å‘³ç€å½“ç¨‹åºçš„ä¸šåŠ¡éœ€æ±‚æ”¹å˜æ—¶ï¼Œæ— éœ€æ”¹å˜å€¼æŒæœ‰çŠ¶æ€æˆ–è€…ä½¿ç”¨å€¼çš„ä»£ç ã€‚åªéœ€æ›´æ–°æŸä¸ªçŠ¶æ€å¯¹è±¡ä¸­çš„ä»£ç æ¥æ”¹å˜å…¶è§„åˆ™ï¼Œæˆ–è€…æ˜¯å¢åŠ æ›´å¤šçš„çŠ¶æ€å¯¹è±¡ã€‚

ä¸ºäº†æ¢ç´¢è¿™ä¸ªæ¦‚å¿µï¼Œå°†å®ç°ä¸€ä¸ªå¢é‡å¼çš„å‘å¸ƒåšæ–‡çš„å·¥ä½œæµã€‚è¿™ä¸ªåšå®¢çš„æœ€ç»ˆåŠŸèƒ½çœ‹èµ·æ¥åƒè¿™æ ·ï¼š

1. åšæ–‡ä»ç©ºç™½çš„è‰æ¡ˆå¼€å§‹ã€‚
2. ä¸€æ—¦è‰æ¡ˆå®Œæˆï¼Œè¯·æ±‚å®¡æ ¸åšæ–‡ã€‚
3. ä¸€æ—¦åšæ–‡è¿‡å®¡ï¼Œå®ƒå°†è¢«å‘è¡¨ã€‚
4. åªæœ‰è¢«å‘è¡¨çš„åšæ–‡çš„å†…å®¹ä¼šè¢«æ‰“å°ï¼Œè¿™æ ·å°±ä¸ä¼šæ„å¤–æ‰“å°å‡ºæ²¡æœ‰è¢«å®¡æ ¸çš„åšæ–‡çš„æ–‡æœ¬ã€‚
5. 
ä»»ä½•å…¶ä»–å¯¹åšæ–‡çš„ä¿®æ”¹å°è¯•éƒ½æ˜¯æ²¡æœ‰ä½œç”¨çš„ã€‚ä¾‹å¦‚ï¼Œå¦‚æœå°è¯•åœ¨è¯·æ±‚å®¡æ ¸ä¹‹å‰é€šè¿‡ä¸€ä¸ªè‰æ¡ˆåšæ–‡ï¼Œåšæ–‡åº”è¯¥ä¿æŒæœªå‘å¸ƒçš„çŠ¶æ€ã€‚

```rust
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());

    post.request_review();
    assert_eq!("", post.content());

    post.approve();
    assert_eq!("I ate a salad for lunch today", post.content());
}

```

å¸Œæœ›å…è®¸ç”¨æˆ·ä½¿ç”¨ Post::new åˆ›å»ºä¸€ä¸ªæ–°çš„åšæ–‡è‰æ¡ˆã€‚æ¥ç€å¸Œæœ›èƒ½åœ¨è‰æ¡ˆé˜¶æ®µä¸ºåšæ–‡ç¼–å†™ä¸€äº›æ–‡æœ¬ã€‚å¦‚æœå°è¯•åœ¨å®¡æ ¸ä¹‹å‰ç«‹å³æ‰“å°å‡ºåšæ–‡çš„å†…å®¹ï¼Œä»€ä¹ˆä¹Ÿä¸ä¼šå‘ç”Ÿå› ä¸ºåšæ–‡ä»ç„¶æ˜¯è‰æ¡ˆã€‚è¿™é‡Œå¢åŠ çš„ assert_eq! å‡ºäºæ¼”ç¤ºç›®çš„ã€‚ä¸€ä¸ªå¥½çš„å•å…ƒæµ‹è¯•å°†æ˜¯æ–­è¨€è‰æ¡ˆåšæ–‡çš„ content æ–¹æ³•è¿”å›ç©ºå­—ç¬¦ä¸²ï¼Œä¸è¿‡å¹¶ä¸å‡†å¤‡ä¸ºè¿™ä¸ªä¾‹å­ç¼–å†™å•å…ƒæµ‹è¯•ã€‚

æ¥ä¸‹æ¥ï¼Œå¸Œæœ›èƒ½å¤Ÿè¯·æ±‚å®¡æ ¸åšæ–‡ï¼Œè€Œåœ¨ç­‰å¾…å®¡æ ¸çš„é˜¶æ®µ content åº”è¯¥ä»ç„¶è¿”å›ç©ºå­—ç¬¦ä¸²ã€‚æœ€åå½“åšæ–‡å®¡æ ¸é€šè¿‡ï¼Œå®ƒåº”è¯¥è¢«å‘è¡¨ï¼Œè¿™æ„å‘³ç€å½“è°ƒç”¨ content æ—¶åšæ–‡çš„æ–‡æœ¬å°†è¢«è¿”å›ã€‚

æ³¨æ„ä¸ crate äº¤äº’çš„å”¯ä¸€çš„ç±»å‹æ˜¯ Postã€‚è¿™ä¸ªç±»å‹ä¼šä½¿ç”¨çŠ¶æ€æ¨¡å¼å¹¶ä¼šå­˜æ”¾å¤„äºä¸‰ç§åšæ–‡æ‰€å¯èƒ½çš„çŠ¶æ€ä¹‹ä¸€çš„å€¼ â€”â€” è‰æ¡ˆï¼Œç­‰å¾…å®¡æ ¸å’Œå‘å¸ƒã€‚çŠ¶æ€ä¸Šçš„æ”¹å˜ç”± Post ç±»å‹å†…éƒ¨è¿›è¡Œç®¡ç†ã€‚çŠ¶æ€ä¾åº“ç”¨æˆ·å¯¹ Post å®ä¾‹è°ƒç”¨çš„æ–¹æ³•è€Œæ”¹å˜ï¼Œä½†æ˜¯ä¸èƒ½ç›´æ¥ç®¡ç†çŠ¶æ€å˜åŒ–ã€‚è¿™ä¹Ÿæ„å‘³ç€ç”¨æˆ·ä¸ä¼šåœ¨çŠ¶æ€ä¸ŠçŠ¯é”™ï¼Œæ¯”å¦‚åœ¨è¿‡å®¡å‰å‘å¸ƒåšæ–‡ã€‚

##### å®šä¹‰ Post å¹¶æ–°å»ºä¸€ä¸ªè‰æ¡ˆçŠ¶æ€çš„å®ä¾‹

```rust

#![allow(unused_variables)]
fn main() {
pub struct Post {
    state: Option<Box<dyn State>>,
    content: String,
}

impl Post {
    pub fn new() -> Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
}
```

State trait å®šä¹‰äº†æ‰€æœ‰ä¸åŒçŠ¶æ€çš„åšæ–‡æ‰€å…±äº«çš„è¡Œä¸ºï¼ŒåŒæ—¶ Draftã€PendingReview å’Œ Published çŠ¶æ€éƒ½ä¼šå®ç° State çŠ¶æ€ã€‚ç°åœ¨è¿™ä¸ª trait å¹¶æ²¡æœ‰ä»»ä½•æ–¹æ³•ï¼ŒåŒæ—¶å¼€å§‹å°†åªå®šä¹‰ Draft çŠ¶æ€å› ä¸ºè¿™æ˜¯å¸Œæœ›åšæ–‡çš„åˆå§‹çŠ¶æ€ã€‚

å½“åˆ›å»ºæ–°çš„ Post æ—¶ï¼Œå°†å…¶ state å­—æ®µè®¾ç½®ä¸ºä¸€ä¸ªå­˜æ”¾äº† Box çš„ Some å€¼ã€‚è¿™ä¸ª Box æŒ‡å‘ä¸€ä¸ª Draft ç»“æ„ä½“æ–°å®ä¾‹ã€‚è¿™ç¡®ä¿äº†æ— è®ºä½•æ—¶æ–°å»ºä¸€ä¸ª Post å®ä¾‹ï¼Œå®ƒéƒ½ä¼šä»è‰æ¡ˆå¼€å§‹ã€‚å› ä¸º Post çš„ state å­—æ®µæ˜¯ç§æœ‰çš„ï¼Œä¹Ÿå°±æ— æ³•åˆ›å»ºä»»ä½•å…¶ä»–çŠ¶æ€çš„ Post äº†ï¼ã€‚Post::new å‡½æ•°ä¸­å°† content è®¾ç½®ä¸ºæ–°å»ºçš„ç©º Stringã€‚

##### å­˜æ”¾åšæ–‡å†…å®¹çš„æ–‡æœ¬

å¸Œæœ›èƒ½å¤Ÿè°ƒç”¨ä¸€ä¸ªå«åš add_text çš„æ–¹æ³•å¹¶å‘å…¶ä¼ é€’ä¸€ä¸ª &str æ¥å°†æ–‡æœ¬å¢åŠ åˆ°åšæ–‡çš„å†…å®¹ä¸­ã€‚é€‰æ‹©å®ç°ä¸ºä¸€ä¸ªæ–¹æ³•è€Œä¸æ˜¯å°† content å­—æ®µæš´éœ²ä¸º pub ã€‚è¿™æ„å‘³ç€ä¹‹åå¯ä»¥å®ç°ä¸€ä¸ªæ–¹æ³•æ¥æ§åˆ¶ content å­—æ®µå¦‚ä½•è¢«è¯»å–ã€‚add_text æ–¹æ³•æ˜¯éå¸¸ç›´è§‚çš„ï¼Œ

```rust

#![allow(unused_variables)]
fn main() {
pub struct Post {
    content: String,
}

impl Post {
    // --snip--
    pub fn add_text(&mut self, text: &str) {
        self.content.push_str(text);
    }
}
}
```

add_text è·å–ä¸€ä¸ª self çš„å¯å˜å¼•ç”¨ï¼Œå› ä¸ºéœ€è¦æ”¹å˜è°ƒç”¨ add_text çš„ Post å®ä¾‹ã€‚æ¥ç€è°ƒç”¨ content ä¸­çš„ String çš„ push_str å¹¶ä¼ é€’ text å‚æ•°æ¥ä¿å­˜åˆ° content ä¸­ã€‚è¿™ä¸æ˜¯çŠ¶æ€æ¨¡å¼çš„ä¸€éƒ¨åˆ†ï¼Œå› ä¸ºå®ƒçš„è¡Œä¸ºå¹¶ä¸ä¾èµ–åšæ–‡æ‰€å¤„çš„çŠ¶æ€ã€‚add_text æ–¹æ³•å®Œå…¨ä¸ä¸ state çŠ¶æ€äº¤äº’ï¼Œä¸è¿‡è¿™æ˜¯å¸Œæœ›æ”¯æŒçš„è¡Œä¸ºçš„ä¸€éƒ¨åˆ†ã€‚

##### ç¡®ä¿åšæ–‡è‰æ¡ˆçš„å†…å®¹æ˜¯ç©ºçš„

```rust

#![allow(unused_variables)]
fn main() {
pub struct Post {
    content: String,
}

impl Post {
    // --snip--
    pub fn content(&self) -> &str {
        ""
    }
}
}
```

##### è¯·æ±‚å®¡æ ¸åšæ–‡æ¥æ”¹å˜å…¶çŠ¶æ€

æ¥ä¸‹æ¥éœ€è¦å¢åŠ è¯·æ±‚å®¡æ ¸åšæ–‡çš„åŠŸèƒ½ï¼Œè¿™åº”å½“å°†å…¶çŠ¶æ€ç”± Draft æ”¹ä¸º PendingReviewã€‚

```rust

#![allow(unused_variables)]
fn main() {
pub struct Post {
    state: Option<Box<dyn State>>,
    content: String,
}

impl Post {
    // --snip--
    pub fn request_review(&mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box<Self>) -> Box<dyn State>;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }
}
}
```

è¿™é‡Œä¸º Post å¢åŠ ä¸€ä¸ªè·å– self å¯å˜å¼•ç”¨çš„å…¬æœ‰æ–¹æ³• request_reviewã€‚æ¥ç€åœ¨ Post çš„å½“å‰çŠ¶æ€ä¸‹è°ƒç”¨å†…éƒ¨çš„ request_review æ–¹æ³•ï¼Œå¹¶ä¸”ç¬¬äºŒä¸ª request_review æ–¹æ³•ä¼šæ¶ˆè´¹å½“å‰çš„çŠ¶æ€å¹¶è¿”å›ä¸€ä¸ªæ–°çŠ¶æ€ã€‚

è¿™é‡Œç»™ State trait å¢åŠ äº† request_review æ–¹æ³•ï¼›æ‰€æœ‰å®ç°äº†è¿™ä¸ª trait çš„ç±»å‹ç°åœ¨éƒ½éœ€è¦å®ç° request_review æ–¹æ³•ã€‚æ³¨æ„ä¸åŒäºä½¿ç”¨ selfã€ &self æˆ–è€… &mut self ä½œä¸ºæ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œè¿™é‡Œä½¿ç”¨äº† self: Box<Self>ã€‚è¿™ä¸ªè¯­æ³•æ„å‘³ç€è¿™ä¸ªæ–¹æ³•è°ƒç”¨åªå¯¹è¿™ä¸ªç±»å‹çš„ Box æœ‰æ•ˆã€‚è¿™ä¸ªè¯­æ³•è·å–äº† Box<Self> çš„æ‰€æœ‰æƒï¼Œä½¿è€çŠ¶æ€æ— æ•ˆåŒ–ä»¥ä¾¿ Post çš„çŠ¶æ€å€¼å¯ä»¥å°†è‡ªèº«è½¬æ¢ä¸ºæ–°çŠ¶æ€ã€‚

ä¸ºäº†æ¶ˆè´¹è€çŠ¶æ€ï¼Œrequest_review æ–¹æ³•éœ€è¦è·å–çŠ¶æ€å€¼çš„æ‰€æœ‰æƒã€‚è¿™ä¹Ÿå°±æ˜¯ Post çš„ state å­—æ®µä¸­ Option çš„æ¥å†ï¼šè°ƒç”¨ take æ–¹æ³•å°† state å­—æ®µä¸­çš„ Some å€¼å–å‡ºå¹¶ç•™ä¸‹ä¸€ä¸ª Noneï¼Œå› ä¸º Rust ä¸å…è®¸åœ¨ç»“æ„ä½“ä¸­å­˜åœ¨ç©ºçš„å­—æ®µã€‚è¿™ä½¿å¾—å°† state å€¼ç§»åŠ¨å‡º Post è€Œä¸æ˜¯å€Ÿç”¨å®ƒã€‚æ¥ç€å°†åšæ–‡çš„ state å€¼è®¾ç½®ä¸ºè¿™ä¸ªæ“ä½œçš„ç»“æœã€‚

è¿™é‡Œéœ€è¦å°† state ä¸´æ—¶è®¾ç½®ä¸º Noneï¼Œä¸åŒäºåƒ self.state = self.state.request_review(); è¿™æ ·çš„ä»£ç ç›´æ¥è®¾ç½® state å­—æ®µï¼Œæ¥è·å– state å€¼çš„æ‰€æœ‰æƒã€‚è¿™ç¡®ä¿äº†å½“ Post è¢«è½¬æ¢ä¸ºæ–°çŠ¶æ€åå…¶ä¸å†èƒ½ä½¿ç”¨è€çš„ state å€¼ã€‚

Draft çš„æ–¹æ³• request_review çš„å®ç°è¿”å›ä¸€ä¸ªæ–°çš„ï¼Œè£…ç®±çš„ PendingReview ç»“æ„ä½“çš„å®ä¾‹ï¼Œå…¶ç”¨æ¥ä»£è¡¨åšæ–‡å¤„äºç­‰å¾…å®¡æ ¸çŠ¶æ€ã€‚ç»“æ„ä½“ PendingReview åŒæ ·ä¹Ÿå®ç°äº† request_review æ–¹æ³•ï¼Œä¸è¿‡å®ƒä¸è¿›è¡Œä»»ä½•çŠ¶æ€è½¬æ¢ã€‚ç›¸åå®ƒè¿”å›è‡ªèº«ï¼Œå› ä¸ºè¯·æ±‚å®¡æ ¸å·²ç»å¤„äº PendingReview çŠ¶æ€çš„åšæ–‡åº”è¯¥ä¿æŒ PendingReview çŠ¶æ€ã€‚

ç°åœ¨å¼€å§‹èƒ½å¤Ÿçœ‹å‡ºçŠ¶æ€æ¨¡å¼çš„ä¼˜åŠ¿äº†ï¼šPost çš„ request_review æ–¹æ³•æ— è®º state æ˜¯ä½•å€¼éƒ½æ˜¯ä¸€æ ·çš„ã€‚æ¯ä¸ªçŠ¶æ€åªè´Ÿè´£å®ƒè‡ªå·±çš„è§„åˆ™ã€‚

å°†ç»§ç»­ä¿æŒ Post çš„ content æ–¹æ³•ä¸å˜ï¼Œè¿”å›ä¸€ä¸ªç©ºå­—ç¬¦ä¸² sliceã€‚ç°åœ¨å¯ä»¥æ‹¥æœ‰ PendingReview çŠ¶æ€è€Œä¸ä»…ä»…æ˜¯ Draft çŠ¶æ€çš„ Post äº†ï¼Œä¸è¿‡å¸Œæœ›åœ¨ PendingReview çŠ¶æ€ä¸‹å…¶ä¹Ÿæœ‰ç›¸åŒçš„è¡Œä¸ºã€‚

##### å¢åŠ æ”¹å˜ content è¡Œä¸ºçš„ approve æ–¹æ³•

approve æ–¹æ³•å°†ä¸ request_review æ–¹æ³•ç±»ä¼¼ï¼šå®ƒä¼šå°† state è®¾ç½®ä¸ºå®¡æ ¸é€šè¿‡æ—¶åº”å¤„äºçš„çŠ¶æ€

```rust

#![allow(unused_variables)]
fn main() {
pub struct Post {
    state: Option<Box<dyn State>>,
    content: String,
}

impl Post {
    // --snip--
    pub fn approve(&mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box<Self>) -> Box<dyn State>;
    fn approve(self: Box<Self>) -> Box<dyn State>;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        Box::new(PendingReview {})
    }

    // --snip--
    fn approve(self: Box<Self>) -> Box<dyn State> {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }

    // --snip--
    fn approve(self: Box<Self>) -> Box<dyn State> {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }

    fn approve(self: Box<Self>) -> Box<dyn State> {
        self
    }
}
}
```

è¿™é‡Œä¸º State trait å¢åŠ äº† approve æ–¹æ³•ï¼Œå¹¶æ–°å¢äº†ä¸€ä¸ªå®ç°äº† State çš„ç»“æ„ä½“ï¼ŒPublished çŠ¶æ€ã€‚

ç±»ä¼¼äº request_reviewï¼Œå¦‚æœå¯¹ Draft è°ƒç”¨ approve æ–¹æ³•ï¼Œå¹¶æ²¡æœ‰ä»»ä½•æ•ˆæœï¼Œå› ä¸ºå®ƒä¼šè¿”å› selfã€‚å½“å¯¹ PendingReview è°ƒç”¨ approve æ—¶ï¼Œå®ƒè¿”å›ä¸€ä¸ªæ–°çš„ã€è£…ç®±çš„ Published ç»“æ„ä½“çš„å®ä¾‹ã€‚Published ç»“æ„ä½“å®ç°äº† State traitï¼ŒåŒæ—¶å¯¹äº request_review å’Œ approve ä¸¤æ–¹æ³•æ¥è¯´ï¼Œå®ƒè¿”å›è‡ªèº«ï¼Œå› ä¸ºåœ¨è¿™ä¸¤ç§æƒ…å†µåšæ–‡åº”è¯¥ä¿æŒ Published çŠ¶æ€ã€‚

ç°åœ¨æ›´æ–° Post çš„ content æ–¹æ³•ï¼šå¦‚æœçŠ¶æ€ä¸º Published å¸Œæœ›è¿”å›åšæ–‡ content å­—æ®µçš„å€¼ï¼›å¦åˆ™å¸Œæœ›è¿”å›ç©ºå­—ç¬¦ä¸² sliceï¼Œ

```rust

#![allow(unused_variables)]
fn main() {
trait State {
    fn content<'a>(&self, post: &'a Post) -> &'a str;
}
pub struct Post {
    state: Option<Box<dyn State>>,
    content: String,
}

impl Post {
    // --snip--
    pub fn content(&self) -> &str {
        self.state.as_ref().unwrap().content(self)
    }
    // --snip--
}
}
```

å› ä¸ºç›®æ ‡æ˜¯å°†æ‰€æœ‰åƒè¿™æ ·çš„è§„åˆ™ä¿æŒåœ¨å®ç°äº† State çš„ç»“æ„ä½“ä¸­ï¼Œå°†è°ƒç”¨ state ä¸­çš„å€¼çš„ content æ–¹æ³•å¹¶ä¼ é€’åšæ–‡å®ä¾‹ï¼ˆä¹Ÿå°±æ˜¯ selfï¼‰ä½œä¸ºå‚æ•°ã€‚æ¥ç€è¿”å› state å€¼çš„ content æ–¹æ³•çš„è¿”å›å€¼ã€‚

è¿™é‡Œè°ƒç”¨ Option çš„ as_ref æ–¹æ³•æ˜¯å› ä¸ºéœ€è¦ Option ä¸­å€¼çš„å¼•ç”¨è€Œä¸æ˜¯è·å–å…¶æ‰€æœ‰æƒã€‚å› ä¸º state æ˜¯ä¸€ä¸ª `Option<Box<State>>`ï¼Œè°ƒç”¨ as_ref ä¼šè¿”å›ä¸€ä¸ª `Option<&Box<State>>`ã€‚å¦‚æœä¸è°ƒç”¨ as_refï¼Œå°†ä¼šå¾—åˆ°ä¸€ä¸ªé”™è¯¯ï¼Œå› ä¸ºä¸èƒ½å°† state ç§»åŠ¨å‡ºå€Ÿç”¨çš„ &self å‡½æ•°å‚æ•°ã€‚

æ¥ç€è°ƒç”¨ unwrap æ–¹æ³•ï¼Œè¿™é‡ŒçŸ¥é“å®ƒæ°¸è¿œä¹Ÿä¸ä¼š panicï¼Œå› ä¸º Post çš„æ‰€æœ‰æ–¹æ³•éƒ½ç¡®ä¿åœ¨ä»–ä»¬è¿”å›æ—¶ state ä¼šæœ‰ä¸€ä¸ª Some å€¼ã€‚è¿™å°±æ˜¯ä¸€ä¸ªç¬¬åäºŒç«  â€œå½“æ¯”ç¼–è¯‘å™¨çŸ¥é“æ›´å¤šçš„æƒ…å†µâ€ éƒ¨åˆ†è®¨è®ºè¿‡çš„çŸ¥é“ None æ˜¯ä¸å¯èƒ½çš„è€Œç¼–è¯‘å™¨å´ä¸èƒ½ç†è§£çš„æƒ…å†µã€‚

æ¥ç€å°±æœ‰äº†ä¸€ä¸ª `&Box<State>`ï¼Œå½“è°ƒç”¨å…¶ content æ—¶ï¼Œè§£å¼•ç”¨å¼ºåˆ¶å¤šæ€ä¼šä½œç”¨äº & å’Œ Box ï¼Œè¿™æ ·æœ€ç»ˆä¼šè°ƒç”¨å®ç°äº† State trait çš„ç±»å‹çš„ content æ–¹æ³•ã€‚è¿™æ„å‘³ç€éœ€è¦ä¸º State trait å®šä¹‰å¢åŠ  contentï¼Œè¿™ä¹Ÿæ˜¯æ”¾ç½®æ ¹æ®æ‰€å¤„çŠ¶æ€è¿”å›ä»€ä¹ˆå†…å®¹çš„é€»è¾‘çš„åœ°æ–¹ï¼Œ

```rust

#![allow(unused_variables)]
fn main() {
pub struct Post {
    content: String
}
trait State {
    // --snip--
    fn content<'a>(&self, post: &'a Post) -> &'a str {
        ""
    }
}

// --snip--
struct Published {}

impl State for Published {
    // --snip--
    fn content<'a>(&self, post: &'a Post) -> &'a str {
        &post.content
    }
}
}
```

è¿™é‡Œå¢åŠ äº†ä¸€ä¸ª content æ–¹æ³•çš„é»˜è®¤å®ç°æ¥è¿”å›ä¸€ä¸ªç©ºå­—ç¬¦ä¸² sliceã€‚è¿™æ„å‘³ç€æ— éœ€ä¸º Draft å’Œ PendingReview ç»“æ„ä½“å®ç° content äº†ã€‚Published ç»“æ„ä½“ä¼šè¦†ç›– content æ–¹æ³•å¹¶ä¼šè¿”å› post.content çš„å€¼ã€‚

æ³¨æ„è¿™ä¸ªæ–¹æ³•éœ€è¦ç”Ÿå‘½å‘¨æœŸæ³¨è§£ï¼Œå¦‚ç¬¬åç« æ‰€è®¨è®ºçš„ã€‚è¿™é‡Œè·å– post çš„å¼•ç”¨ä½œä¸ºå‚æ•°ï¼Œå¹¶è¿”å› post ä¸€éƒ¨åˆ†çš„å¼•ç”¨ï¼Œæ‰€ä»¥è¿”å›çš„å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸä¸ post å‚æ•°ç›¸å…³ã€‚

##### çŠ¶æ€æ¨¡å¼çš„æƒè¡¡å–èˆ

å±•ç¤ºäº† Rust æ˜¯èƒ½å¤Ÿå®ç°é¢å‘å¯¹è±¡çš„çŠ¶æ€æ¨¡å¼çš„ï¼Œä»¥ä¾¿èƒ½æ ¹æ®åšæ–‡æ‰€å¤„çš„çŠ¶æ€æ¥å°è£…ä¸åŒç±»å‹çš„è¡Œä¸ºã€‚Post çš„æ–¹æ³•å¹¶ä¸çŸ¥é“è¿™äº›ä¸åŒç±»å‹çš„è¡Œä¸ºã€‚é€šè¿‡è¿™ç§ç»„ç»‡ä»£ç çš„æ–¹å¼ï¼Œè¦æ‰¾åˆ°æ‰€æœ‰å·²å‘å¸ƒåšæ–‡çš„ä¸åŒè¡Œä¸ºåªéœ€æŸ¥çœ‹ä¸€å¤„ä»£ç ï¼šPublished çš„ State trait çš„å®ç°ã€‚

å¦‚æœè¦åˆ›å»ºä¸€ä¸ªä¸ä½¿ç”¨çŠ¶æ€æ¨¡å¼çš„æ›¿ä»£å®ç°ï¼Œåˆ™å¯èƒ½ä¼šåœ¨ Post çš„æ–¹æ³•ä¸­ï¼Œæˆ–è€…ç”šè‡³äºåœ¨ main ä»£ç ä¸­ç”¨åˆ° match è¯­å¥ï¼Œæ¥æ£€æŸ¥åšæ–‡çŠ¶æ€å¹¶åœ¨è¿™é‡Œæ”¹å˜å…¶è¡Œä¸ºã€‚è¿™æ„å‘³ç€éœ€è¦æŸ¥çœ‹å¾ˆå¤šä½ç½®æ¥ç†è§£å¤„äºå‘å¸ƒçŠ¶æ€çš„åšæ–‡çš„æ‰€æœ‰é€»è¾‘ï¼è¿™åœ¨å¢åŠ æ›´å¤šçŠ¶æ€æ—¶ä¼šå˜å¾—æ›´ç³Ÿï¼šæ¯ä¸€ä¸ª match è¯­å¥éƒ½ä¼šéœ€è¦å¦ä¸€ä¸ªåˆ†æ”¯ã€‚

å¯¹äºçŠ¶æ€æ¨¡å¼æ¥è¯´ï¼ŒPost çš„æ–¹æ³•å’Œä½¿ç”¨ Post çš„ä½ç½®æ— éœ€ match è¯­å¥ï¼ŒåŒæ—¶å¢åŠ æ–°çŠ¶æ€åªæ¶‰åŠåˆ°å¢åŠ ä¸€ä¸ªæ–° struct å’Œä¸ºå…¶å®ç° trait çš„æ–¹æ³•ã€‚

è¿™ä¸ªå®ç°æ˜“äºæ‰©å±•å¢åŠ æ›´å¤šåŠŸèƒ½ã€‚ä¸ºäº†ä½“ä¼šä½¿ç”¨æ­¤æ¨¡å¼ç»´æŠ¤ä»£ç çš„ç®€æ´æ€§ï¼Œè¯·å°è¯•å¦‚ä¸‹ä¸€äº›å»ºè®®ï¼š

* å¢åŠ  reject æ–¹æ³•å°†åšæ–‡çš„çŠ¶æ€ä» PendingReview å˜å› Draft
* åœ¨å°†çŠ¶æ€å˜ä¸º Published ä¹‹å‰éœ€è¦ä¸¤æ¬¡ approve è°ƒç”¨
* åªå…è®¸åšæ–‡å¤„äº Draft çŠ¶æ€æ—¶å¢åŠ æ–‡æœ¬å†…å®¹ã€‚æç¤ºï¼šè®©çŠ¶æ€å¯¹è±¡è´Ÿè´£ä»€ä¹ˆå¯èƒ½ä¼šä¿®æ”¹å†…å®¹è€Œä¸è´Ÿè´£ä¿®æ”¹ Postã€‚

çŠ¶æ€æ¨¡å¼çš„ä¸€ä¸ªç¼ºç‚¹æ˜¯å› ä¸ºçŠ¶æ€å®ç°äº†çŠ¶æ€ä¹‹é—´çš„è½¬æ¢ï¼Œä¸€äº›çŠ¶æ€ä¼šç›¸äº’è”ç³»ã€‚å¦‚æœåœ¨ PendingReview å’Œ Published ä¹‹é—´å¢åŠ å¦ä¸€ä¸ªçŠ¶æ€ï¼Œæ¯”å¦‚ Scheduledï¼Œåˆ™ä¸å¾—ä¸ä¿®æ”¹ PendingReview ä¸­çš„ä»£ç æ¥è½¬ç§»åˆ° Scheduledã€‚å¦‚æœ PendingReview æ— éœ€å› ä¸ºæ–°å¢çš„çŠ¶æ€è€Œæ”¹å˜å°±æ›´å¥½äº†ï¼Œä¸è¿‡è¿™æ„å‘³ç€åˆ‡æ¢åˆ°å¦ä¸€ç§è®¾è®¡æ¨¡å¼ã€‚

å¦ä¸€ä¸ªç¼ºç‚¹æ˜¯ä¼šå‘ç°ä¸€äº›é‡å¤çš„é€»è¾‘ã€‚ä¸ºäº†æ¶ˆé™¤ä»–ä»¬ï¼Œå¯ä»¥å°è¯•ä¸º State trait ä¸­è¿”å› self çš„ request_review å’Œ approve æ–¹æ³•å¢åŠ é»˜è®¤å®ç°ï¼Œä¸è¿‡è¿™ä¼šè¿åå¯¹è±¡å®‰å…¨æ€§ï¼Œå› ä¸º trait ä¸çŸ¥é“ self å…·ä½“æ˜¯ä»€ä¹ˆã€‚å¸Œæœ›èƒ½å¤Ÿå°† State ä½œä¸ºä¸€ä¸ª trait å¯¹è±¡ï¼Œæ‰€ä»¥éœ€è¦å…¶æ–¹æ³•æ˜¯å¯¹è±¡å®‰å…¨çš„ã€‚

å¦ä¸€ä¸ªé‡å¤æ˜¯ Post ä¸­ request_review å’Œ approve è¿™ä¸¤ä¸ªç±»ä¼¼çš„å®ç°ã€‚ä»–ä»¬éƒ½å§”æ‰˜è°ƒç”¨äº† state å­—æ®µä¸­ Option å€¼çš„åŒä¸€æ–¹æ³•ï¼Œå¹¶åœ¨ç»“æœä¸­ä¸º state å­—æ®µè®¾ç½®äº†æ–°å€¼ã€‚å¦‚æœ Post ä¸­çš„å¾ˆå¤šæ–¹æ³•éƒ½éµå¾ªè¿™ä¸ªæ¨¡å¼ï¼Œå¯èƒ½ä¼šè€ƒè™‘å®šä¹‰ä¸€ä¸ªå®æ¥æ¶ˆé™¤é‡å¤

å®Œå…¨æŒ‰ç…§é¢å‘å¯¹è±¡è¯­è¨€çš„å®šä¹‰å®ç°è¿™ä¸ªæ¨¡å¼å¹¶æ²¡æœ‰å°½å¯èƒ½åœ°åˆ©ç”¨ Rust çš„ä¼˜åŠ¿ã€‚çœ‹çœ‹ä¸€äº›ä»£ç ä¸­å¯ä»¥åšå‡ºçš„ä¿®æ”¹ï¼Œæ¥å°†æ— æ•ˆçš„çŠ¶æ€å’ŒçŠ¶æ€è½¬ç§»å˜ä¸ºç¼–è¯‘æ—¶é”™è¯¯ã€‚

### æ¨¡å¼ç”¨æ¥åŒ¹é…å€¼çš„ç»“æ„

æ¨¡å¼æ˜¯ Rust ä¸­ç‰¹æ®Šçš„è¯­æ³•ï¼Œå®ƒç”¨æ¥åŒ¹é…ç±»å‹ä¸­çš„ç»“æ„ï¼Œæ— è®ºç±»å‹æ˜¯ç®€å•è¿˜æ˜¯å¤æ‚ã€‚ç»“åˆä½¿ç”¨æ¨¡å¼å’Œ match è¡¨è¾¾å¼ä»¥åŠå…¶ä»–ç»“æ„å¯ä»¥æä¾›æ›´å¤šå¯¹ç¨‹åºæ§åˆ¶æµçš„æ”¯é…æƒã€‚æ¨¡å¼ç”±å¦‚ä¸‹ä¸€äº›å†…å®¹ç»„åˆè€Œæˆï¼š

* å­—é¢å€¼
* è§£æ„çš„æ•°ç»„ã€æšä¸¾ã€ç»“æ„ä½“æˆ–è€…å…ƒç»„
* å˜é‡
* é€šé…ç¬¦
* å ä½ç¬¦

#### match åˆ†æ”¯

ä¸€ä¸ªæ¨¡å¼å¸¸ç”¨çš„ä½ç½®æ˜¯ match è¡¨è¾¾å¼çš„åˆ†æ”¯ã€‚åœ¨å½¢å¼ä¸Š match è¡¨è¾¾å¼ç”± match å…³é”®å­—ã€ç”¨äºåŒ¹é…çš„å€¼å’Œä¸€ä¸ªæˆ–å¤šä¸ªåˆ†æ”¯æ„æˆï¼Œè¿™äº›åˆ†æ”¯åŒ…å«ä¸€ä¸ªæ¨¡å¼å’Œåœ¨å€¼åŒ¹é…åˆ†æ”¯çš„æ¨¡å¼æ—¶è¿è¡Œçš„è¡¨è¾¾å¼ï¼š

```rust
match VALUE {
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
}

```

match è¡¨è¾¾å¼å¿…é¡»æ˜¯ ç©·å°½ï¼ˆexhaustiveï¼‰çš„ï¼Œæ„ä¸º match è¡¨è¾¾å¼æ‰€æœ‰å¯èƒ½çš„å€¼éƒ½å¿…é¡»è¢«è€ƒè™‘åˆ°ã€‚ä¸€ä¸ªç¡®ä¿è¦†ç›–æ¯ä¸ªå¯èƒ½å€¼çš„æ–¹æ³•æ˜¯åœ¨æœ€åä¸€ä¸ªåˆ†æ”¯ä½¿ç”¨æ•è·æ‰€æœ‰çš„æ¨¡å¼ï¼šæ¯”å¦‚ï¼Œä¸€ä¸ªåŒ¹é…ä»»ä½•å€¼çš„åç§°æ°¸è¿œä¹Ÿä¸ä¼šå¤±è´¥ï¼Œå› æ­¤å¯ä»¥è¦†ç›–æ‰€æœ‰åŒ¹é…å‰©ä¸‹çš„æƒ…å†µã€‚

æœ‰ä¸€ä¸ªç‰¹å®šçš„æ¨¡å¼ _ å¯ä»¥åŒ¹é…æ‰€æœ‰æƒ…å†µï¼Œä¸è¿‡å®ƒä»ä¸ç»‘å®šä»»ä½•å˜é‡ã€‚è¿™åœ¨ä¾‹å¦‚å¸Œæœ›å¿½ç•¥ä»»ä½•æœªæŒ‡å®šå€¼çš„æƒ…å†µå¾ˆæœ‰ç”¨ã€‚

#### `if let` æ¡ä»¶è¡¨è¾¾å¼

ä¸‹ä¾‹ å±•ç¤ºäº†ä¹Ÿå¯ä»¥ç»„åˆå¹¶åŒ¹é… if letã€else if å’Œ else if let è¡¨è¾¾å¼ã€‚è¿™ç›¸æ¯” match è¡¨è¾¾å¼ä¸€æ¬¡åªèƒ½å°†ä¸€ä¸ªå€¼ä¸æ¨¡å¼æ¯”è¾ƒæä¾›äº†æ›´å¤šçµæ´»æ€§ï¼›ä¸€ç³»åˆ— if letã€else ifã€else if let åˆ†æ”¯å¹¶ä¸è¦æ±‚å…¶æ¡ä»¶ç›¸äº’å…³è”ã€‚

```rust
fn main() {
    let favorite_color: Option<&str> = None;
    let is_tuesday = false;
    let age: Result<u8, _> = "34".parse();

    if let Some(color) = favorite_color {
        println!("Using your favorite color, {}, as the background", color);
    } else if is_tuesday {
        println!("Tuesday is green day!");
    } else if let Ok(age) = age {
        if age > 30 {
            println!("Using purple as the background color");
        } else {
            println!("Using orange as the background color");
        }
    } else {
        println!("Using blue as the background color");
    }
}

```

#### while let æ¡ä»¶å¾ªç¯

ä¸€ä¸ªä¸ if let ç»“æ„ç±»ä¼¼çš„æ˜¯ while let æ¡ä»¶å¾ªç¯ï¼Œå®ƒå…è®¸åªè¦æ¨¡å¼åŒ¹é…å°±ä¸€ç›´è¿›è¡Œ while å¾ªç¯ã€‚

```rust

#![allow(unused_variables)]
fn main() {
let mut stack = Vec::new();

stack.push(1);
stack.push(2);
stack.push(3);

while let Some(top) = stack.pop() {
    println!("{}", top);
}
}
```

è¿™ä¸ªä¾‹å­ä¼šæ‰“å°å‡º 3ã€2 æ¥ç€æ˜¯ 1ã€‚pop æ–¹æ³•å–å‡º vector çš„æœ€åä¸€ä¸ªå…ƒç´ å¹¶è¿”å› Some(value)ã€‚å¦‚æœ vector æ˜¯ç©ºçš„ï¼Œå®ƒè¿”å› Noneã€‚while å¾ªç¯åªè¦ pop è¿”å› Some å°±ä¼šä¸€ç›´è¿è¡Œå…¶å—ä¸­çš„ä»£ç ã€‚ä¸€æ—¦å…¶è¿”å› Noneï¼Œwhile å¾ªç¯åœæ­¢ã€‚å¯ä»¥ä½¿ç”¨ while let æ¥å¼¹å‡ºæ ˆä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ ã€‚

#### for å¾ªç¯

å¦‚åŒç¬¬ä¸‰ç« æ‰€è®²çš„ï¼Œfor å¾ªç¯æ˜¯ Rust ä¸­æœ€å¸¸è§çš„å¾ªç¯ç»“æ„ï¼Œä¸è¿‡è¿˜æ²¡æœ‰è®²åˆ°çš„æ˜¯ for å¯ä»¥è·å–ä¸€ä¸ªæ¨¡å¼ã€‚åœ¨ for å¾ªç¯ä¸­ï¼Œæ¨¡å¼æ˜¯ for å…³é”®å­—ç›´æ¥è·Ÿéšçš„å€¼ï¼Œæ­£å¦‚ for x in y ä¸­çš„ xã€‚

ä¸‹ä¾‹ä¸­å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ for å¾ªç¯æ¥è§£æ„ï¼Œæˆ–æ‹†å¼€ä¸€ä¸ªå…ƒç»„ä½œä¸º for å¾ªç¯çš„ä¸€éƒ¨åˆ†ï¼š

```rust

#![allow(unused_variables)]
fn main() {
let v = vec!['a', 'b', 'c'];

for (index, value) in v.iter().enumerate() {
    println!("{} is at index {}", value, index);
}
}
```

ä¸Šä¾‹çš„ä»£ç ä¼šæ‰“å°å‡ºï¼š

```
a is at index 0
b is at index 1
c is at index 2
```

è¿™é‡Œä½¿ç”¨ enumerate æ–¹æ³•é€‚é…ä¸€ä¸ªè¿­ä»£å™¨æ¥äº§ç”Ÿä¸€ä¸ªå€¼å’Œå…¶åœ¨è¿­ä»£å™¨ä¸­çš„ç´¢å¼•ï¼Œä»–ä»¬ä½äºä¸€ä¸ªå…ƒç»„ä¸­ã€‚ç¬¬ä¸€ä¸ª enumerate è°ƒç”¨ä¼šäº§ç”Ÿå…ƒç»„ (0, 'a')ã€‚å½“è¿™ä¸ªå€¼åŒ¹é…æ¨¡å¼ (index, value)ï¼Œindex å°†ä¼šæ˜¯ 0 è€Œ value å°†ä¼šæ˜¯ 'a'ï¼Œå¹¶æ‰“å°å‡ºç¬¬ä¸€è¡Œè¾“å‡ºã€‚

#### letçš„æ¨¡å¼åŒ¹é…

ä¸ºäº†æ›´æ¸…æ¥šçš„ç†è§£ let çš„æ¨¡å¼åŒ¹é…æ–¹é¢çš„å†…å®¹ï¼Œè€ƒè™‘ä¸‹ä¾‹ ä¸­ä½¿ç”¨ let å’Œæ¨¡å¼è§£æ„ä¸€ä¸ªå…ƒç»„ï¼š

```rust

#![allow(unused_variables)]
fn main() {
let (x, y, z) = (1, 2, 3);
}
```

#### å‡½æ•°å‚æ•°

å‡½æ•°å‚æ•°ä¹Ÿå¯ä»¥æ˜¯æ¨¡å¼ã€‚ç±»ä¼¼äºä¹‹å‰å¯¹ let æ‰€åšçš„ï¼Œå¯ä»¥åœ¨å‡½æ•°å‚æ•°ä¸­åŒ¹é…å…ƒç»„ã€‚ä¸‹ä¾‹å°†ä¼ é€’ç»™å‡½æ•°çš„å…ƒç»„æ‹†åˆ†ä¸ºå€¼ï¼š

```rust
fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("Current location: ({}, {})", x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&point);
}

```

#### Refutabilityï¼ˆå¯åé©³æ€§ï¼‰: æ¨¡å¼æ˜¯å¦ä¼šåŒ¹é…å¤±æ•ˆ

æ¨¡å¼æœ‰ä¸¤ç§å½¢å¼ï¼šrefutableï¼ˆå¯åé©³çš„ï¼‰å’Œ irrefutableï¼ˆä¸å¯åé©³çš„ï¼‰ã€‚èƒ½åŒ¹é…ä»»ä½•ä¼ é€’çš„å¯èƒ½å€¼çš„æ¨¡å¼è¢«ç§°ä¸ºæ˜¯ ä¸å¯åé©³çš„ï¼ˆirrefutableï¼‰ã€‚ä¸€ä¸ªä¾‹å­å°±æ˜¯ let x = 5; è¯­å¥ä¸­çš„ xï¼Œå› ä¸º x å¯ä»¥åŒ¹é…ä»»ä½•å€¼æ‰€ä»¥ä¸å¯èƒ½ä¼šå¤±è´¥ã€‚å¯¹æŸäº›å¯èƒ½çš„å€¼è¿›è¡ŒåŒ¹é…ä¼šå¤±è´¥çš„æ¨¡å¼è¢«ç§°ä¸ºæ˜¯ å¯åé©³çš„ï¼ˆrefutableï¼‰ã€‚ä¸€ä¸ªè¿™æ ·çš„ä¾‹å­ä¾¿æ˜¯ if let Some(x) = a_value è¡¨è¾¾å¼ä¸­çš„ Some(x)ï¼›å¦‚æœå˜é‡ a_value ä¸­çš„å€¼æ˜¯ None è€Œä¸æ˜¯ Someï¼Œé‚£ä¹ˆ Some(x) æ¨¡å¼ä¸èƒ½åŒ¹é…ã€‚

å‡½æ•°å‚æ•°ã€ let è¯­å¥å’Œ for å¾ªç¯åªèƒ½æ¥å—ä¸å¯åé©³çš„æ¨¡å¼ï¼Œå› ä¸ºé€šè¿‡ä¸åŒ¹é…çš„å€¼ç¨‹åºæ— æ³•è¿›è¡Œæœ‰æ„ä¹‰çš„å·¥ä½œã€‚if let å’Œ while let è¡¨è¾¾å¼è¢«é™åˆ¶ä¸ºåªèƒ½æ¥å—å¯åé©³çš„æ¨¡å¼ï¼Œå› ä¸ºæ ¹æ®å®šä¹‰ä»–ä»¬æ„åœ¨å¤„ç†å¯èƒ½çš„å¤±è´¥ï¼šæ¡ä»¶è¡¨è¾¾å¼çš„åŠŸèƒ½å°±æ˜¯æ ¹æ®æˆåŠŸæˆ–å¤±è´¥æ‰§è¡Œä¸åŒçš„æ“ä½œã€‚

é€šå¸¸æ— éœ€æ‹…å¿ƒå¯åé©³å’Œä¸å¯åé©³æ¨¡å¼çš„åŒºåˆ«ï¼Œä¸è¿‡ç¡®å®éœ€è¦ç†Ÿæ‚‰å¯åé©³æ€§çš„æ¦‚å¿µï¼Œè¿™æ ·å½“åœ¨é”™è¯¯ä¿¡æ¯ä¸­çœ‹åˆ°æ—¶å°±çŸ¥é“å¦‚ä½•åº”å¯¹ã€‚é‡åˆ°è¿™äº›æƒ…å†µï¼Œæ ¹æ®ä»£ç è¡Œä¸ºçš„æ„å›¾ï¼Œéœ€è¦ä¿®æ”¹æ¨¡å¼æˆ–è€…ä½¿ç”¨æ¨¡å¼çš„ç»“æ„ã€‚

ä¸ºäº†ä¿®å¤åœ¨éœ€è¦ä¸å¯åé©³æ¨¡å¼çš„åœ°æ–¹ä½¿ç”¨å¯åé©³æ¨¡å¼çš„æƒ…å†µï¼Œå¯ä»¥ä¿®æ”¹ä½¿ç”¨æ¨¡å¼çš„ä»£ç ï¼šä¸åŒäºä½¿ç”¨ letï¼Œå¯ä»¥ä½¿ç”¨ if letã€‚å¦‚æ­¤ï¼Œå¦‚æœæ¨¡å¼ä¸åŒ¹é…ï¼Œå¤§æ‹¬å·ä¸­çš„ä»£ç å°†è¢«å¿½ç•¥ï¼Œå…¶ä½™ä»£ç ä¿æŒæœ‰æ•ˆã€‚

```rust

#![allow(unused_variables)]
fn main() {
let some_option_value: Option<i32> = None;
if let Some(x) = some_option_value {
    println!("{}", x);
}
}
```

åŒ¹é…åˆ†æ”¯å¿…é¡»ä½¿ç”¨å¯åé©³æ¨¡å¼ï¼Œé™¤äº†æœ€åä¸€ä¸ªåˆ†æ”¯éœ€è¦ä½¿ç”¨èƒ½åŒ¹é…ä»»ä½•å‰©ä½™å€¼çš„ä¸å¯åé©³æ¨¡å¼ã€‚å…è®¸å°†ä¸å¯åé©³æ¨¡å¼ç”¨äºåªæœ‰ä¸€ä¸ªåˆ†æ”¯çš„ matchï¼Œä¸è¿‡è¿™ä¹ˆåšä¸æ˜¯ç‰¹åˆ«æœ‰ç”¨ï¼Œå¹¶å¯ä»¥è¢«æ›´ç®€å•çš„ let è¯­å¥æ›¿ä»£ã€‚

#### æ¨¡å¼ç”¨æ³•ï¼šåŒ¹é…å­—é¢å€¼

```rust

#![allow(unused_variables)]
fn main() {
let x = 1;

match x {
    1 => println!("one"),
    2 => println!("two"),
    3 => println!("three"),
    _ => println!("anything"),
}
}
```

#### æ¨¡å¼ç”¨æ³•ï¼šåŒ¹é…å‘½åå˜é‡

å‘½åå˜é‡æ˜¯åŒ¹é…ä»»ä½•å€¼çš„ä¸å¯åé©³æ¨¡å¼ï¼Œè¿™åœ¨ä¹‹å‰å·²ç»ä½¿ç”¨è¿‡æ•°æ¬¡ã€‚ç„¶è€Œå½“å…¶ç”¨äº match è¡¨è¾¾å¼æ—¶æƒ…å†µä¼šæœ‰äº›å¤æ‚ã€‚å› ä¸º match ä¼šå¼€å§‹ä¸€ä¸ªæ–°ä½œç”¨åŸŸï¼Œmatch è¡¨è¾¾å¼ä¸­ä½œä¸ºæ¨¡å¼çš„ä¸€éƒ¨åˆ†å£°æ˜çš„å˜é‡ä¼šè¦†ç›– match ç»“æ„ä¹‹å¤–çš„åŒåå˜é‡ï¼Œä¸æ‰€æœ‰å˜é‡ä¸€æ ·ã€‚åœ¨ä¸‹ä¾‹ ä¸­ï¼Œå£°æ˜äº†ä¸€ä¸ªå€¼ä¸º Some(5) çš„å˜é‡ x å’Œä¸€ä¸ªå€¼ä¸º 10 çš„å˜é‡ yã€‚æ¥ç€åœ¨å€¼ x ä¸Šåˆ›å»ºäº†ä¸€ä¸ª match è¡¨è¾¾å¼ã€‚

```rust
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(y) => println!("Matched, y = {:?}", y),
        _ => println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {:?}", x, y);
}

```

çœ‹çœ‹å½“ match è¯­å¥è¿è¡Œçš„æ—¶å€™å‘ç”Ÿäº†ä»€ä¹ˆã€‚ç¬¬ä¸€ä¸ªåŒ¹é…åˆ†æ”¯çš„æ¨¡å¼å¹¶ä¸åŒ¹é… x ä¸­å®šä¹‰çš„å€¼ï¼Œæ‰€ä»¥ä»£ç ç»§ç»­æ‰§è¡Œã€‚

ç¬¬äºŒä¸ªåŒ¹é…åˆ†æ”¯ä¸­çš„æ¨¡å¼å¼•å…¥äº†ä¸€ä¸ªæ–°å˜é‡ yï¼Œå®ƒä¼šåŒ¹é…ä»»ä½• Some ä¸­çš„å€¼ã€‚å› ä¸ºæˆ‘ä»¬åœ¨ match è¡¨è¾¾å¼çš„æ–°ä½œç”¨åŸŸä¸­ï¼Œè¿™æ˜¯ä¸€ä¸ªæ–°å˜é‡ï¼Œè€Œä¸æ˜¯å¼€å¤´å£°æ˜ä¸ºå€¼ 10 çš„é‚£ä¸ª yã€‚è¿™ä¸ªæ–°çš„ y ç»‘å®šä¼šåŒ¹é…ä»»ä½• Some ä¸­çš„å€¼ï¼Œåœ¨è¿™é‡Œæ˜¯ x ä¸­çš„å€¼ã€‚å› æ­¤è¿™ä¸ª y ç»‘å®šäº† x ä¸­ Some å†…éƒ¨çš„å€¼ã€‚è¿™ä¸ªå€¼æ˜¯ 5ï¼Œæ‰€ä»¥è¿™ä¸ªåˆ†æ”¯çš„è¡¨è¾¾å¼å°†ä¼šæ‰§è¡Œå¹¶æ‰“å°å‡º Matched, y = 5ã€‚

å¦‚æœ x çš„å€¼æ˜¯ None è€Œä¸æ˜¯ Some(5)ï¼Œå¤´ä¸¤ä¸ªåˆ†æ”¯çš„æ¨¡å¼ä¸ä¼šåŒ¹é…ï¼Œæ‰€ä»¥ä¼šåŒ¹é…ä¸‹åˆ’çº¿ã€‚è¿™ä¸ªåˆ†æ”¯çš„æ¨¡å¼ä¸­æ²¡æœ‰å¼•å…¥å˜é‡ xï¼Œæ‰€ä»¥æ­¤æ—¶è¡¨è¾¾å¼ä¸­çš„ x ä¼šæ˜¯å¤–éƒ¨æ²¡æœ‰è¢«è¦†ç›–çš„ xã€‚åœ¨è¿™ä¸ªå‡æƒ³çš„ä¾‹å­ä¸­ï¼Œmatch å°†ä¼šæ‰“å° Default case, x = Noneã€‚

ä¸€æ—¦ match è¡¨è¾¾å¼æ‰§è¡Œå®Œæ¯•ï¼Œå…¶ä½œç”¨åŸŸä¹Ÿå°±ç»“æŸäº†ï¼ŒåŒç†å†…éƒ¨ y çš„ä½œç”¨åŸŸä¹Ÿç»“æŸäº†ã€‚æœ€åçš„ println! ä¼šæ‰“å° at the end: x = Some(5), y = 10ã€‚

ä¸ºäº†åˆ›å»ºèƒ½å¤Ÿæ¯”è¾ƒå¤–éƒ¨ x å’Œ y çš„å€¼ï¼Œè€Œä¸å¼•å…¥è¦†ç›–å˜é‡çš„ match è¡¨è¾¾å¼ï¼Œæˆ‘ä»¬éœ€è¦ç›¸åº”åœ°ä½¿ç”¨å¸¦æœ‰æ¡ä»¶çš„åŒ¹é…å®ˆå«ï¼ˆmatch guardï¼‰ã€‚

#### æ¨¡å¼ç”¨æ³•ï¼šå¤šä¸ªæ¨¡å¼

åœ¨ match è¡¨è¾¾å¼ä¸­ï¼Œå¯ä»¥ä½¿ç”¨ | è¯­æ³•åŒ¹é…å¤šä¸ªæ¨¡å¼ï¼Œå®ƒä»£è¡¨ æˆ–ï¼ˆorï¼‰çš„æ„æ€ã€‚ä¾‹å¦‚ï¼Œå¦‚ä¸‹ä»£ç å°† x çš„å€¼ä¸åŒ¹é…åˆ†æ”¯ç›¸æ¯”è¾ƒï¼Œç¬¬ä¸€ä¸ªåˆ†æ”¯æœ‰ æˆ– é€‰é¡¹ï¼Œæ„å‘³ç€å¦‚æœ x çš„å€¼åŒ¹é…æ­¤åˆ†æ”¯çš„ä»»ä¸€ä¸ªå€¼ï¼Œå®ƒå°±ä¼šè¿è¡Œï¼š

```rust

#![allow(unused_variables)]
fn main() {
let x = 1;

match x {
    1 | 2 => println!("one or two"),
    3 => println!("three"),
    _ => println!("anything"),
}
}
```

#### é€šè¿‡ `..=` åŒ¹é…å€¼çš„èŒƒå›´

`..=` è¯­æ³•å…è®¸ä½ åŒ¹é…ä¸€ä¸ªé—­åŒºé—´èŒƒå›´å†…çš„å€¼ã€‚åœ¨å¦‚ä¸‹ä»£ç ä¸­ï¼Œå½“æ¨¡å¼åŒ¹é…ä»»ä½•åœ¨æ­¤èŒƒå›´å†…çš„å€¼æ—¶ï¼Œè¯¥åˆ†æ”¯ä¼šæ‰§è¡Œï¼š

```rust

#![allow(unused_variables)]
fn main() {
let x = 5;

match x {
    1..=5 => println!("one through five"),
    _ => println!("something else"),
}
}
```

å¦‚æœ x æ˜¯ 1ã€2ã€3ã€4 æˆ– 5ï¼Œç¬¬ä¸€ä¸ªåˆ†æ”¯å°±ä¼šåŒ¹é…ã€‚è¿™ç›¸æ¯”ä½¿ç”¨ | è¿ç®—ç¬¦è¡¨è¾¾ç›¸åŒçš„æ„æ€æ›´ä¸ºæ–¹ä¾¿ï¼›ç›¸æ¯” 1..=5ï¼Œä½¿ç”¨ | åˆ™ä¸å¾—ä¸æŒ‡å®š 1 | 2 | 3 | 4 | 5ã€‚ç›¸åæŒ‡å®šèŒƒå›´å°±ç®€çŸ­çš„å¤šï¼Œç‰¹åˆ«æ˜¯åœ¨å¸Œæœ›åŒ¹é…æ¯”å¦‚ä» 1 åˆ° 1000 çš„æ•°å­—çš„æ—¶å€™ï¼

èŒƒå›´åªå…è®¸ç”¨äºæ•°å­—æˆ– char å€¼ï¼Œå› ä¸ºç¼–è¯‘å™¨ä¼šåœ¨ç¼–è¯‘æ—¶æ£€æŸ¥èŒƒå›´ä¸ä¸ºç©ºã€‚char å’Œ æ•°å­—å€¼æ˜¯ Rust ä»…æœ‰çš„å¯ä»¥åˆ¤æ–­èŒƒå›´æ˜¯å¦ä¸ºç©ºçš„ç±»å‹ã€‚

å¦‚ä¸‹æ˜¯ä¸€ä¸ªä½¿ç”¨ char ç±»å‹å€¼èŒƒå›´çš„ä¾‹å­ï¼š

```rust

#![allow(unused_variables)]
fn main() {
let x = 'c';

match x {
    'a'..='j' => println!("early ASCII letter"),
    'k'..='z' => println!("late ASCII letter"),
    _ => println!("something else"),
}
}
```

#### è§£æ„å¹¶åˆ†è§£å€¼

ä¹Ÿå¯ä»¥ä½¿ç”¨æ¨¡å¼æ¥è§£æ„ç»“æ„ä½“ã€æšä¸¾ã€å…ƒç»„å’Œå¼•ç”¨ï¼Œä»¥ä¾¿ä½¿ç”¨è¿™äº›å€¼çš„ä¸åŒéƒ¨åˆ†ã€‚

##### è§£æ„ç»“æ„ä½“

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}

```

è¿™æ®µä»£ç åˆ›å»ºäº†å˜é‡ a å’Œ b æ¥åŒ¹é…ç»“æ„ä½“ p ä¸­çš„ x å’Œ y å­—æ®µã€‚è¿™ä¸ªä¾‹å­å±•ç¤ºäº†æ¨¡å¼ä¸­çš„å˜é‡åä¸å¿…ä¸ç»“æ„ä½“ä¸­çš„å­—æ®µåä¸€è‡´ã€‚ä¸è¿‡é€šå¸¸å¸Œæœ›å˜é‡åä¸å­—æ®µåä¸€è‡´ä»¥ä¾¿äºç†è§£å˜é‡æ¥è‡ªäºå“ªäº›å­—æ®µã€‚

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}

```

è¿™æ®µä»£ç åˆ›å»ºäº†å˜é‡ x å’Œ yï¼Œä¸å˜é‡ p ä¸­çš„ x å’Œ y ç›¸åŒ¹é…ã€‚å…¶ç»“æœæ˜¯å˜é‡ x å’Œ y åŒ…å«ç»“æ„ä½“ p ä¸­çš„å€¼ã€‚

ä¹Ÿå¯ä»¥ä½¿ç”¨å­—é¢å€¼ä½œä¸ºç»“æ„ä½“æ¨¡å¼çš„ä¸€éƒ¨åˆ†è¿›è¡Œè¿›è¡Œè§£æ„ï¼Œè€Œä¸æ˜¯ä¸ºæ‰€æœ‰çš„å­—æ®µåˆ›å»ºå˜é‡ã€‚è¿™å…è®¸æˆ‘ä»¬æµ‹è¯•ä¸€äº›å­—æ®µä¸ºç‰¹å®šå€¼çš„åŒæ—¶åˆ›å»ºå…¶ä»–å­—æ®µçš„å˜é‡ã€‚

ä¸‹ä¾‹ å±•ç¤ºäº†ä¸€ä¸ª match è¯­å¥å°† Point å€¼åˆ†æˆäº†ä¸‰ç§æƒ…å†µï¼šç›´æ¥ä½äº x è½´ä¸Šï¼ˆæ­¤æ—¶ y = 0 ä¸ºçœŸï¼‰ã€ä½äº y è½´ä¸Šï¼ˆx = 0ï¼‰æˆ–ä¸åœ¨ä»»ä½•è½´ä¸Šçš„ç‚¹ã€‚

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } => println!("On the x axis at {}", x),
        Point { x: 0, y } => println!("On the y axis at {}", y),
        Point { x, y } => println!("On neither axis: ({}, {})", x, y),
    }
}

```

ç¬¬ä¸€ä¸ªåˆ†æ”¯é€šè¿‡æŒ‡å®šå­—æ®µ y åŒ¹é…å­—é¢å€¼ 0 æ¥åŒ¹é…ä»»ä½•ä½äº x è½´ä¸Šçš„ç‚¹ã€‚æ­¤æ¨¡å¼ä»ç„¶åˆ›å»ºäº†å˜é‡ x ä»¥ä¾¿åœ¨åˆ†æ”¯çš„ä»£ç ä¸­ä½¿ç”¨ã€‚

ç±»ä¼¼çš„ï¼Œç¬¬äºŒä¸ªåˆ†æ”¯é€šè¿‡æŒ‡å®šå­—æ®µ x åŒ¹é…å­—é¢å€¼ 0 æ¥åŒ¹é…ä»»ä½•ä½äº y è½´ä¸Šçš„ç‚¹ï¼Œå¹¶ä¸ºå­—æ®µ y åˆ›å»ºäº†å˜é‡ yã€‚ç¬¬ä¸‰ä¸ªåˆ†æ”¯æ²¡æœ‰æŒ‡å®šä»»ä½•å­—é¢å€¼ï¼Œæ‰€ä»¥å…¶ä¼šåŒ¹é…ä»»ä½•å…¶ä»–çš„ Point å¹¶ä¸º x å’Œ y ä¸¤ä¸ªå­—æ®µåˆ›å»ºå˜é‡ã€‚

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå€¼ p å› ä¸ºå…¶ x åŒ…å« 0 è€ŒåŒ¹é…ç¬¬äºŒä¸ªåˆ†æ”¯ï¼Œå› æ­¤ä¼šæ‰“å°å‡º On the y axis at 7ã€‚

##### è§£æ„æšä¸¾

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit => {
            println!("The Quit variant has no data to destructure.")
        }
        Message::Move { x, y } => {
            println!(
                "Move in the x direction {} and in the y direction {}",
                x,
                y
            );
        }
        Message::Write(text) => println!("Text message: {}", text),
        Message::ChangeColor(r, g, b) => {
            println!(
                "Change the color to red {}, green {}, and blue {}",
                r,
                g,
                b
            )
        }
    }
}

```

##### è§£æ„åµŒå¥—çš„ç»“æ„ä½“å’Œæšä¸¾

```rust
enum Color {
   Rgb(i32, i32, i32),
   Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) => {
            println!(
                "Change the color to red {}, green {}, and blue {}",
                r,
                g,
                b
            )
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) => {
            println!(
                "Change the color to hue {}, saturation {}, and value {}",
                h,
                s,
                v
            )
        }
        _ => ()
    }
}

```

match è¡¨è¾¾å¼ç¬¬ä¸€ä¸ªåˆ†æ”¯çš„æ¨¡å¼åŒ¹é…ä¸€ä¸ªåŒ…å« Color::Rgb æšä¸¾æˆå‘˜çš„ Message::ChangeColor æšä¸¾æˆå‘˜ï¼Œç„¶åæ¨¡å¼ç»‘å®šäº† 3 ä¸ªå†…éƒ¨çš„ i32 å€¼ã€‚ç¬¬äºŒä¸ªåˆ†æ”¯çš„æ¨¡å¼ä¹ŸåŒ¹é…ä¸€ä¸ª Message::ChangeColor æšä¸¾æˆå‘˜ï¼Œ ä½†æ˜¯å…¶å†…éƒ¨çš„æšä¸¾ä¼šåŒ¹é… Color::Hsv æšä¸¾æˆå‘˜ã€‚å¯ä»¥åœ¨ä¸€ä¸ª match è¡¨è¾¾å¼ä¸­æŒ‡å®šè¿™äº›å¤æ‚æ¡ä»¶ï¼Œå³ä½¿ä¼šæ¶‰åŠåˆ°ä¸¤ä¸ªæšä¸¾ã€‚

##### è§£æ„ç»“æ„ä½“å’Œå…ƒç»„

ç”šè‡³å¯ä»¥ç”¨å¤æ‚çš„æ–¹å¼æ¥æ··åˆã€åŒ¹é…å’ŒåµŒå¥—è§£æ„æ¨¡å¼ã€‚

```rust

#![allow(unused_variables)]
fn main() {
struct Point {
    x: i32,
    y: i32,
}

let ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });
}
```

#### å¿½ç•¥æ¨¡å¼ä¸­çš„å€¼

æœ‰æ—¶å¿½ç•¥æ¨¡å¼ä¸­çš„ä¸€äº›å€¼æ˜¯æœ‰ç”¨çš„ï¼Œæ¯”å¦‚ match ä¸­æœ€åæ•è·å…¨éƒ¨æƒ…å†µçš„åˆ†æ”¯å®é™…ä¸Šæ²¡æœ‰åšä»»ä½•äº‹ï¼Œä½†æ˜¯å®ƒç¡®å®å¯¹æ‰€æœ‰å‰©ä½™æƒ…å†µè´Ÿè´£ã€‚æœ‰ä¸€äº›ç®€å•çš„æ–¹æ³•å¯ä»¥å¿½ç•¥æ¨¡å¼ä¸­å…¨éƒ¨æˆ–éƒ¨åˆ†å€¼ï¼šä½¿ç”¨ _ æ¨¡å¼ï¼Œåœ¨å¦ä¸€ä¸ªæ¨¡å¼ä¸­ä½¿ç”¨ _ æ¨¡å¼ï¼Œä½¿ç”¨ä¸€ä¸ªä»¥ä¸‹åˆ’çº¿å¼€å§‹çš„åç§°ï¼Œæˆ–è€…ä½¿ç”¨ .. å¿½ç•¥æ‰€å‰©éƒ¨åˆ†çš„å€¼ã€‚è®©æˆ‘ä»¬æ¥åˆ†åˆ«æ¢ç´¢å¦‚ä½•ä»¥åŠä¸ºä»€ä¹ˆè¦è¿™ä¹ˆåšã€‚

##### ä½¿ç”¨ _ å¿½ç•¥æ•´ä¸ªå€¼

å·²ç»ä½¿ç”¨è¿‡ä¸‹åˆ’çº¿ï¼ˆ_ï¼‰ä½œä¸ºåŒ¹é…ä½†ä¸ç»‘å®šä»»ä½•å€¼çš„é€šé…ç¬¦æ¨¡å¼äº†ã€‚è™½ç„¶ _ æ¨¡å¼ä½œä¸º match è¡¨è¾¾å¼æœ€åçš„åˆ†æ”¯ç‰¹åˆ«æœ‰ç”¨ï¼Œä¹Ÿå¯ä»¥å°†å…¶ç”¨äºä»»æ„æ¨¡å¼ï¼ŒåŒ…æ‹¬å‡½æ•°å‚æ•°ä¸­

```rust
fn foo(_: i32, y: i32) {
    println!("This code only uses the y parameter: {}", y);
}

fn main() {
    foo(3, 4);
}

```

è¿™æ®µä»£ç ä¼šå®Œå…¨å¿½ç•¥ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ä¼ é€’çš„å€¼ 3ï¼Œå¹¶ä¼šæ‰“å°å‡º This code only uses the y parameter: 4ã€‚

å¤§éƒ¨åˆ†æƒ…å†µå½“ä½ ä¸å†éœ€è¦ç‰¹å®šå‡½æ•°å‚æ•°æ—¶ï¼Œæœ€å¥½ä¿®æ”¹ç­¾åä¸å†åŒ…å«æ— ç”¨çš„å‚æ•°ã€‚åœ¨ä¸€äº›æƒ…å†µä¸‹å¿½ç•¥å‡½æ•°å‚æ•°ä¼šå˜å¾—ç‰¹åˆ«æœ‰ç”¨ï¼Œæ¯”å¦‚å®ç° trait æ—¶ï¼Œå½“ä½ éœ€è¦ç‰¹å®šç±»å‹ç­¾åä½†æ˜¯å‡½æ•°å®ç°å¹¶ä¸éœ€è¦æŸä¸ªå‚æ•°æ—¶ã€‚æ­¤æ—¶ç¼–è¯‘å™¨å°±ä¸ä¼šè­¦å‘Šè¯´å­˜åœ¨æœªä½¿ç”¨çš„å‡½æ•°å‚æ•°ï¼Œå°±è·Ÿä½¿ç”¨å‘½åå‚æ•°ä¸€æ ·ã€‚

##### ä½¿ç”¨åµŒå¥—çš„ _ å¿½ç•¥éƒ¨åˆ†å€¼

ä¹Ÿå¯ä»¥åœ¨ä¸€ä¸ªæ¨¡å¼å†…éƒ¨ä½¿ç”¨_ å¿½ç•¥éƒ¨åˆ†å€¼ï¼Œä¾‹å¦‚ï¼Œå½“åªéœ€è¦æµ‹è¯•éƒ¨åˆ†å€¼ä½†åœ¨æœŸæœ›è¿è¡Œçš„ä»£ç ä¸­æ²¡æœ‰ç”¨åˆ°å…¶ä»–éƒ¨åˆ†æ—¶ã€‚ä¸‹ä¾‹  å±•ç¤ºäº†è´Ÿè´£ç®¡ç†è®¾ç½®å€¼çš„ä»£ç ã€‚ä¸šåŠ¡éœ€æ±‚æ˜¯ç”¨æˆ·ä¸å…è®¸è¦†ç›–ç°æœ‰çš„è‡ªå®šä¹‰è®¾ç½®ï¼Œä½†æ˜¯å¯ä»¥å–æ¶ˆè®¾ç½®ï¼Œä¹Ÿå¯ä»¥åœ¨å½“å‰æœªè®¾ç½®æ—¶ä¸ºå…¶æä¾›è®¾ç½®ã€‚

```rust

#![allow(unused_variables)]
fn main() {
let mut setting_value = Some(5);
let new_setting_value = Some(10);

match (setting_value, new_setting_value) {
    (Some(_), Some(_)) => {
        println!("Can't overwrite an existing customized value");
    }
    _ => {
        setting_value = new_setting_value;
    }
}

println!("setting is {:?}", setting_value);
}
```

è¿™æ®µä»£ç ä¼šæ‰“å°å‡º Can't overwrite an existing customized value æ¥ç€æ˜¯ setting is Some(5)ã€‚åœ¨ç¬¬ä¸€ä¸ªåŒ¹é…åˆ†æ”¯ï¼Œæˆ‘ä»¬ä¸éœ€è¦åŒ¹é…æˆ–ä½¿ç”¨ä»»ä¸€ä¸ª Some æˆå‘˜ä¸­çš„å€¼ï¼›é‡è¦çš„éƒ¨åˆ†æ˜¯éœ€è¦æµ‹è¯• setting_value å’Œ new_setting_value éƒ½ä¸º Some æˆå‘˜çš„æƒ…å†µã€‚åœ¨è¿™ç§æƒ…å†µï¼Œæˆ‘ä»¬æ‰“å°å‡ºä¸ºä½•ä¸æ”¹å˜ setting_valueï¼Œå¹¶ä¸”ä¸ä¼šæ”¹å˜å®ƒã€‚

å¯¹äºæ‰€æœ‰å…¶ä»–æƒ…å†µï¼ˆsetting_value æˆ– new_setting_value ä»»ä¸€ä¸º Noneï¼‰ï¼Œè¿™ç”±ç¬¬äºŒä¸ªåˆ†æ”¯çš„ _ æ¨¡å¼ä½“ç°ï¼Œè¿™æ—¶ç¡®å®å¸Œæœ›å…è®¸ new_setting_value å˜ä¸º setting_valueã€‚

ä¹Ÿå¯ä»¥åœ¨ä¸€ä¸ªæ¨¡å¼ä¸­çš„å¤šå¤„ä½¿ç”¨ä¸‹åˆ’çº¿æ¥å¿½ç•¥ç‰¹å®šå€¼ï¼Œ

```rust

#![allow(unused_variables)]
fn main() {
let numbers = (2, 4, 8, 16, 32);

match numbers {
    (first, _, third, _, fifth) => {
        println!("Some numbers: {}, {}, {}", first, third, fifth)
    },
}
}
```

##### é€šè¿‡åœ¨åå­—å‰ä»¥ä¸€ä¸ªä¸‹åˆ’çº¿å¼€å¤´æ¥å¿½ç•¥æœªä½¿ç”¨çš„å˜é‡

å¦‚æœåˆ›å»ºäº†ä¸€ä¸ªå˜é‡å´ä¸åœ¨ä»»ä½•åœ°æ–¹ä½¿ç”¨å®ƒ, Rust é€šå¸¸ä¼šç»™ä½ ä¸€ä¸ªè­¦å‘Šï¼Œå› ä¸ºè¿™å¯èƒ½ä¼šæ˜¯ä¸ª bugã€‚ä½†æ˜¯æœ‰æ—¶åˆ›å»ºä¸€ä¸ªè¿˜æœªä½¿ç”¨çš„å˜é‡æ˜¯æœ‰ç”¨çš„ï¼Œæ¯”å¦‚ä½ æ­£åœ¨è®¾è®¡åŸå‹æˆ–åˆšåˆšå¼€å§‹ä¸€ä¸ªé¡¹ç›®ã€‚è¿™æ—¶ä½ å¸Œæœ›å‘Šè¯‰ Rust ä¸è¦è­¦å‘Šæœªä½¿ç”¨çš„å˜é‡ï¼Œä¸ºæ­¤å¯ä»¥ç”¨ä¸‹åˆ’çº¿ä½œä¸ºå˜é‡åçš„å¼€å¤´ã€‚

```rust
fn main() {
    let _x = 5;
    let y = 10;
}

```

è¿™é‡Œå¾—åˆ°äº†è­¦å‘Šè¯´æœªä½¿ç”¨å˜é‡ yï¼Œä¸è¿‡æ²¡æœ‰è­¦å‘Šè¯´æœªä½¿ç”¨ä¸‹åˆ’çº¿å¼€å¤´çš„å˜é‡ã€‚

æ³¨æ„, åªä½¿ç”¨ _ å’Œä½¿ç”¨ä»¥ä¸‹åˆ’çº¿å¼€å¤´çš„åç§°æœ‰äº›å¾®å¦™çš„ä¸åŒï¼šæ¯”å¦‚ _x ä»ä¼šå°†å€¼ç»‘å®šåˆ°å˜é‡ï¼Œè€Œ _ åˆ™å®Œå…¨ä¸ä¼šç»‘å®šã€‚ä¸ºäº†å±•ç¤ºè¿™ä¸ªåŒºåˆ«çš„æ„ä¹‰ã€‚

```rust

#![allow(unused_variables)]
fn main() {
let s = Some(String::from("Hello!"));

if let Some(_) = s {
    println!("found a string");
}

println!("{:?}", s);
}
```

##### ç”¨ .. å¿½ç•¥å‰©ä½™å€¼

å¯¹äºæœ‰å¤šä¸ªéƒ¨åˆ†çš„å€¼ï¼Œå¯ä»¥ä½¿ç”¨ .. è¯­æ³•æ¥åªä½¿ç”¨éƒ¨åˆ†å¹¶å¿½ç•¥å…¶å®ƒå€¼ï¼ŒåŒæ—¶é¿å…ä¸å¾—ä¸æ¯ä¸€ä¸ªå¿½ç•¥å€¼åˆ—å‡ºä¸‹åˆ’çº¿ã€‚.. æ¨¡å¼ä¼šå¿½ç•¥æ¨¡å¼ä¸­å‰©ä½™çš„ä»»ä½•æ²¡æœ‰æ˜¾å¼åŒ¹é…çš„å€¼éƒ¨åˆ†ã€‚

```rust

#![allow(unused_variables)]
fn main() {
struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x, .. } => println!("x is {}", x),
}
}
```

```rust
fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) => {
            println!("Some numbers: {}, {}", first, last);
        },
    }
}

```

è¿™é‡Œç”¨ first å’Œ last æ¥åŒ¹é…ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªå€¼ã€‚.. å°†åŒ¹é…å¹¶å¿½ç•¥ä¸­é—´çš„æ‰€æœ‰å€¼ã€‚

ç„¶è€Œä½¿ç”¨ .. å¿…é¡»æ˜¯æ— æ­§ä¹‰çš„ã€‚å¦‚æœæœŸæœ›åŒ¹é…å’Œå¿½ç•¥çš„å€¼æ˜¯ä¸æ˜ç¡®çš„ï¼ŒRust ä¼šæŠ¥é”™ã€‚

#### åŒ¹é…å®ˆå«æä¾›çš„é¢å¤–æ¡ä»¶

åŒ¹é…å®ˆå«ï¼ˆmatch guardï¼‰æ˜¯ä¸€ä¸ªæŒ‡å®šäº match åˆ†æ”¯æ¨¡å¼ä¹‹åçš„é¢å¤– if æ¡ä»¶ï¼Œå®ƒä¹Ÿå¿…é¡»è¢«æ»¡è¶³æ‰èƒ½é€‰æ‹©æ­¤åˆ†æ”¯ã€‚åŒ¹é…å®ˆå«ç”¨äºè¡¨è¾¾æ¯”å•ç‹¬çš„æ¨¡å¼æ‰€èƒ½å…è®¸çš„æ›´ä¸ºå¤æ‚çš„æƒ…å†µã€‚

```rust

#![allow(unused_variables)]
fn main() {
let num = Some(4);

match num {
    Some(x) if x < 5 => println!("less than five: {}", x),
    Some(x) => println!("{}", x),
    None => (),
}
}
```

å¦‚ä½•ä½¿ç”¨åŒ¹é…å®ˆå«ä¿®å¤å˜é‡è¦†ç›–é—®é¢˜ã€‚

```rust
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        Some(n) if n == y => println!("Matched, n = {}", n),
        _ => println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {}", x, y);
}

```

ç°åœ¨è¿™ä¼šæ‰“å°å‡º Default case, x = Some(5)ã€‚ç°åœ¨ç¬¬äºŒä¸ªåŒ¹é…åˆ†æ”¯ä¸­çš„æ¨¡å¼ä¸ä¼šå¼•å…¥ä¸€ä¸ªè¦†ç›–å¤–éƒ¨ y çš„æ–°å˜é‡ yï¼Œè¿™æ„å‘³ç€å¯ä»¥åœ¨åŒ¹é…å®ˆå«ä¸­ä½¿ç”¨å¤–éƒ¨çš„ yã€‚ç›¸æ¯”æŒ‡å®šä¼šè¦†ç›–å¤–éƒ¨ y çš„æ¨¡å¼ Some(y)ï¼Œè¿™é‡ŒæŒ‡å®šä¸º Some(n)ã€‚æ­¤æ–°å»ºçš„å˜é‡ n å¹¶æ²¡æœ‰è¦†ç›–ä»»ä½•å€¼ï¼Œå› ä¸º match å¤–éƒ¨æ²¡æœ‰å˜é‡ nã€‚

åŒ¹é…å®ˆå« if n == y å¹¶ä¸æ˜¯ä¸€ä¸ªæ¨¡å¼æ‰€ä»¥æ²¡æœ‰å¼•å…¥æ–°å˜é‡ã€‚è¿™ä¸ª y æ­£æ˜¯ å¤–éƒ¨çš„ y è€Œä¸æ˜¯æ–°çš„è¦†ç›–å˜é‡ yï¼Œè¿™æ ·å°±å¯ä»¥é€šè¿‡æ¯”è¾ƒ n å’Œ y æ¥è¡¨è¾¾å¯»æ‰¾ä¸€ä¸ªä¸å¤–éƒ¨ y ç›¸åŒçš„å€¼çš„æ¦‚å¿µäº†ã€‚

ä¹Ÿå¯ä»¥åœ¨åŒ¹é…å®ˆå«ä¸­ä½¿ç”¨ æˆ– è¿ç®—ç¬¦ | æ¥æŒ‡å®šå¤šä¸ªæ¨¡å¼ï¼ŒåŒæ—¶åŒ¹é…å®ˆå«çš„æ¡ä»¶ä¼šä½œç”¨äºæ‰€æœ‰çš„æ¨¡å¼ã€‚ä¸‹ä¾‹  å±•ç¤ºäº†ç»“åˆåŒ¹é…å®ˆå«ä¸ä½¿ç”¨äº† | çš„æ¨¡å¼çš„ä¼˜å…ˆçº§ã€‚è¿™ä¸ªä¾‹å­ä¸­é‡è¦çš„éƒ¨åˆ†æ˜¯åŒ¹é…å®ˆå« if y ä½œç”¨äº 4ã€5 å’Œ 6ï¼Œå³ä½¿è¿™çœ‹èµ·æ¥å¥½åƒ if y åªä½œç”¨äº 6ï¼š

```rust

#![allow(unused_variables)]
fn main() {
let x = 4;
let y = false;

match x {
    4 | 5 | 6 if y => println!("yes"),
    _ => println!("no"),
}
}
```

è¿™ä¸ªåŒ¹é…æ¡ä»¶è¡¨æ˜æ­¤åˆ†æ”¯å€¼åŒ¹é… x å€¼ä¸º 4ã€5 æˆ– 6 åŒæ—¶ y ä¸º true çš„æƒ…å†µã€‚è¿è¡Œè¿™æ®µä»£ç æ—¶ä¼šå‘ç”Ÿçš„æ˜¯ç¬¬ä¸€ä¸ªåˆ†æ”¯çš„æ¨¡å¼å›  x ä¸º 4 è€ŒåŒ¹é…ï¼Œä¸è¿‡åŒ¹é…å®ˆå« if y ä¸ºå‡ï¼Œæ‰€ä»¥ç¬¬ä¸€ä¸ªåˆ†æ”¯ä¸ä¼šè¢«é€‰æ‹©ã€‚ä»£ç ç§»åŠ¨åˆ°ç¬¬äºŒä¸ªåˆ†æ”¯ï¼Œè¿™ä¼šåŒ¹é…ï¼Œæ­¤ç¨‹åºä¼šæ‰“å°å‡º noã€‚è¿™æ˜¯å› ä¸º if æ¡ä»¶ä½œç”¨äºæ•´ä¸ª 4 | 5 | 6 æ¨¡å¼ï¼Œè€Œä¸ä»…æ˜¯æœ€åçš„å€¼ 6ã€‚æ¢å¥è¯è¯´ï¼ŒåŒ¹é…å®ˆå«ä¸æ¨¡å¼çš„ä¼˜å…ˆçº§å…³ç³»çœ‹èµ·æ¥åƒè¿™æ ·ï¼š

```
(4 | 5 | 6) if y => ...
```

è€Œä¸æ˜¯

```
4 | 5 | (6 if y) => ...
```

å¯ä»¥é€šè¿‡è¿è¡Œä»£ç æ—¶çš„æƒ…å†µçœ‹å‡ºè¿™ä¸€ç‚¹ï¼šå¦‚æœåŒ¹é…å®ˆå«åªä½œç”¨äºç”± | è¿ç®—ç¬¦æŒ‡å®šçš„å€¼åˆ—è¡¨çš„æœ€åä¸€ä¸ªå€¼ï¼Œè¿™ä¸ªåˆ†æ”¯å°±ä¼šåŒ¹é…ä¸”ç¨‹åºä¼šæ‰“å°å‡º yesã€‚

#### @ ç»‘å®š

at è¿ç®—ç¬¦ï¼ˆ@ï¼‰å…è®¸æˆ‘ä»¬åœ¨åˆ›å»ºä¸€ä¸ªå­˜æ”¾å€¼çš„å˜é‡çš„åŒæ—¶æµ‹è¯•å…¶å€¼æ˜¯å¦åŒ¹é…æ¨¡å¼ã€‚ä¸‹ä¾‹ å±•ç¤ºäº†ä¸€ä¸ªä¾‹å­ï¼Œè¿™é‡Œæˆ‘ä»¬å¸Œæœ›æµ‹è¯• Message::Hello çš„ id å­—æ®µæ˜¯å¦ä½äº 3...7 èŒƒå›´å†…ï¼ŒåŒæ—¶ä¹Ÿå¸Œæœ›èƒ½å°†å…¶å€¼ç»‘å®šåˆ° id_variable å˜é‡ä¸­ä»¥ä¾¿æ­¤åˆ†æ”¯ç›¸å…³è”çš„ä»£ç å¯ä»¥ä½¿ç”¨å®ƒã€‚å¯ä»¥å°† id_variable å‘½åä¸º idï¼Œä¸å­—æ®µåŒåï¼Œä¸è¿‡å‡ºäºç¤ºä¾‹çš„ç›®çš„è¿™é‡Œé€‰æ‹©äº†ä¸åŒçš„åç§°ã€‚

```rust

#![allow(unused_variables)]
fn main() {
enum Message {
    Hello { id: i32 },
}

let msg = Message::Hello { id: 5 };

match msg {
    Message::Hello { id: id_variable @ 3..=7 } => {
        println!("Found an id in range: {}", id_variable)
    },
    Message::Hello { id: 10..=12 } => {
        println!("Found an id in another range")
    },
    Message::Hello { id } => {
        println!("Found some other id: {}", id)
    },
}
}
```

ä¸Šä¾‹ä¼šæ‰“å°å‡º Found an id in range: 5ã€‚é€šè¿‡åœ¨ 3...7 ä¹‹å‰æŒ‡å®š id_variable @ï¼Œæˆ‘ä»¬æ•è·äº†ä»»ä½•åŒ¹é…æ­¤èŒƒå›´çš„å€¼å¹¶åŒæ—¶æµ‹è¯•å…¶å€¼åŒ¹é…è¿™ä¸ªèŒƒå›´æ¨¡å¼ã€‚

ç¬¬äºŒä¸ªåˆ†æ”¯åªåœ¨æ¨¡å¼ä¸­æŒ‡å®šäº†ä¸€ä¸ªèŒƒå›´ï¼Œåˆ†æ”¯ç›¸å…³ä»£ç ä»£ç æ²¡æœ‰ä¸€ä¸ªåŒ…å« id å­—æ®µå®é™…å€¼çš„å˜é‡ã€‚id å­—æ®µçš„å€¼å¯ä»¥æ˜¯ 10ã€11 æˆ– 12ï¼Œä¸è¿‡è¿™ä¸ªæ¨¡å¼çš„ä»£ç å¹¶ä¸çŸ¥æƒ…ä¹Ÿä¸èƒ½ä½¿ç”¨ id å­—æ®µä¸­çš„å€¼ï¼Œå› ä¸ºæ²¡æœ‰å°† id å€¼ä¿å­˜è¿›ä¸€ä¸ªå˜é‡ã€‚

æœ€åä¸€ä¸ªåˆ†æ”¯æŒ‡å®šäº†ä¸€ä¸ªæ²¡æœ‰èŒƒå›´çš„å˜é‡ï¼Œæ­¤æ—¶ç¡®å®æ‹¥æœ‰å¯ä»¥ç”¨äºåˆ†æ”¯ä»£ç çš„å˜é‡ idï¼Œå› ä¸ºè¿™é‡Œä½¿ç”¨äº†ç»“æ„ä½“å­—æ®µç®€å†™è¯­æ³•ã€‚ä¸è¿‡æ­¤åˆ†æ”¯ä¸­æ²¡æœ‰åƒå¤´ä¸¤ä¸ªåˆ†æ”¯é‚£æ ·å¯¹ id å­—æ®µçš„å€¼è¿›è¡Œæµ‹è¯•ï¼šä»»ä½•å€¼éƒ½ä¼šåŒ¹é…æ­¤åˆ†æ”¯ã€‚

ä½¿ç”¨ @ å¯ä»¥åœ¨ä¸€ä¸ªæ¨¡å¼ä¸­åŒæ—¶æµ‹è¯•å’Œä¿å­˜å˜é‡å€¼ã€‚

### Rusté«˜çº§ç‰¹æ€§

* ä¸å®‰å…¨ Rustï¼šç”¨äºå½“éœ€è¦èˆå¼ƒ Rust çš„æŸäº›ä¿è¯å¹¶è´Ÿè´£æ‰‹åŠ¨ç»´æŒè¿™äº›ä¿è¯
é«˜çº§ traitï¼šä¸ trait ç›¸å…³çš„å…³è”ç±»å‹ï¼Œé»˜è®¤ç±»å‹å‚æ•°ï¼Œå®Œå…¨é™å®šè¯­æ³•ï¼ˆfully qualified syntaxï¼‰ï¼Œè¶…ï¼ˆçˆ¶ï¼‰traitï¼ˆsupertraitsï¼‰å’Œ newtype æ¨¡å¼
* é«˜çº§ç±»å‹ï¼šå…³äº newtype æ¨¡å¼çš„æ›´å¤šå†…å®¹ï¼Œç±»å‹åˆ«åï¼Œnever ç±»å‹å’ŒåŠ¨æ€å¤§å°ç±»å‹

* é«˜çº§å‡½æ•°å’Œé—­åŒ…ï¼šå‡½æ•°æŒ‡é’ˆå’Œè¿”å›é—­åŒ…
* å®ï¼šå®šä¹‰åœ¨ç¼–è¯‘æ—¶å®šä¹‰æ›´å¤šæ›´å¤šä»£ç çš„æ–¹å¼

#### ä¸å®‰å…¨ Rust

ç›®å‰ä¸ºæ­¢è®¨è®ºè¿‡çš„ä»£ç éƒ½æœ‰ Rust åœ¨ç¼–è¯‘æ—¶ä¼šå¼ºåˆ¶æ‰§è¡Œçš„å†…å­˜å®‰å…¨ä¿è¯ã€‚ç„¶è€Œï¼ŒRust è¿˜éšè—æœ‰ç¬¬äºŒç§è¯­è¨€ï¼Œå®ƒä¸ä¼šå¼ºåˆ¶æ‰§è¡Œè¿™ç±»å†…å­˜å®‰å…¨ä¿è¯ï¼šè¿™è¢«ç§°ä¸º ä¸å®‰å…¨ Rustï¼ˆunsafe Rustï¼‰ã€‚å®ƒä¸å¸¸è§„ Rust ä»£ç æ— å¼‚ï¼Œä½†æ˜¯ä¼šæä¾›é¢å¤–çš„è¶…çº§åŠ›é‡ã€‚

ä¸å®‰å…¨ Rust ä¹‹æ‰€ä»¥å­˜åœ¨ï¼Œæ˜¯å› ä¸ºé™æ€åˆ†ææœ¬è´¨ä¸Šæ˜¯ä¿å®ˆçš„ã€‚å½“ç¼–è¯‘å™¨å°è¯•ç¡®å®šä¸€æ®µä»£ç æ˜¯å¦æ”¯æŒæŸä¸ªä¿è¯æ—¶ï¼Œæ‹’ç»ä¸€äº›æœ‰æ•ˆçš„ç¨‹åºæ¯”æ¥å—æ— æ•ˆç¨‹åºè¦å¥½ä¸€äº›ã€‚è¿™å¿…ç„¶æ„å‘³ç€æœ‰æ—¶ä»£ç å¯èƒ½æ˜¯åˆæ³•çš„ï¼Œä½†æ˜¯ Rust ä¸è¿™ä¹ˆè®¤ä¸ºï¼åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯ä»¥ä½¿ç”¨ä¸å®‰å…¨ä»£ç å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œâ€œç›¸ä¿¡æˆ‘ï¼Œæˆ‘çŸ¥é“æˆ‘åœ¨å¹²ä»€ä¹ˆã€‚â€è¿™ä¹ˆåšçš„ç¼ºç‚¹å°±æ˜¯ä½ åªèƒ½é è‡ªå·±äº†ï¼šå¦‚æœä¸å®‰å…¨ä»£ç å‡ºé”™äº†ï¼Œæ¯”å¦‚è§£å¼•ç”¨ç©ºæŒ‡é’ˆï¼Œå¯èƒ½ä¼šå¯¼è‡´ä¸å®‰å…¨çš„å†…å­˜ä½¿ç”¨ã€‚

å¦ä¸€ä¸ª Rust å­˜åœ¨ä¸å®‰å…¨ä¸€é¢çš„åŸå› æ˜¯ï¼šåº•å±‚è®¡ç®—æœºç¡¬ä»¶å›ºæœ‰çš„ä¸å®‰å…¨æ€§ã€‚å¦‚æœ Rust ä¸å…è®¸è¿›è¡Œä¸å®‰å…¨æ“ä½œï¼Œé‚£ä¹ˆæœ‰äº›ä»»åŠ¡åˆ™æ ¹æœ¬å®Œæˆä¸äº†ã€‚Rust éœ€è¦èƒ½å¤Ÿè¿›è¡Œåƒç›´æ¥ä¸æ“ä½œç³»ç»Ÿäº¤äº’ï¼Œç”šè‡³äºç¼–å†™ä½ è‡ªå·±çš„æ“ä½œç³»ç»Ÿè¿™æ ·çš„åº•å±‚ç³»ç»Ÿç¼–ç¨‹ï¼è¿™ä¹Ÿæ˜¯ Rust è¯­è¨€çš„ç›®æ ‡ä¹‹ä¸€ã€‚

##### ä¸å®‰å…¨çš„è¶…çº§åŠ›é‡

å¯ä»¥é€šè¿‡ unsafe å…³é”®å­—æ¥åˆ‡æ¢åˆ°ä¸å®‰å…¨ Rustï¼Œæ¥ç€å¯ä»¥å¼€å¯ä¸€ä¸ªæ–°çš„å­˜æ”¾ä¸å®‰å…¨ä»£ç çš„å—ã€‚è¿™é‡Œæœ‰å››ç±»å¯ä»¥åœ¨ä¸å®‰å…¨ Rust ä¸­è¿›è¡Œè€Œä¸èƒ½ç”¨äºå®‰å…¨ Rust çš„æ“ä½œï¼Œå®ƒä»¬ç§°ä¹‹ä¸º â€œä¸å®‰å…¨çš„è¶…çº§åŠ›é‡ã€‚â€ è¿™äº›è¶…çº§åŠ›é‡æ˜¯ï¼š

* è§£å¼•ç”¨è£¸æŒ‡é’ˆ
* è°ƒç”¨ä¸å®‰å…¨çš„å‡½æ•°æˆ–æ–¹æ³•
* è®¿é—®æˆ–ä¿®æ”¹å¯å˜é™æ€å˜é‡
* å®ç°ä¸å®‰å…¨ trait
* è®¿é—® union çš„å­—æ®µ

æœ‰ä¸€ç‚¹å¾ˆé‡è¦ï¼Œunsafe å¹¶ä¸ä¼šå…³é—­å€Ÿç”¨æ£€æŸ¥å™¨æˆ–ç¦ç”¨ä»»ä½•å…¶ä»– Rust å®‰å…¨æ£€æŸ¥ï¼šå¦‚æœåœ¨ä¸å®‰å…¨ä»£ç ä¸­ä½¿ç”¨å¼•ç”¨ï¼Œå®ƒä»ä¼šè¢«æ£€æŸ¥ã€‚unsafe å…³é”®å­—åªæ˜¯æä¾›äº†é‚£å››ä¸ªä¸ä¼šè¢«ç¼–è¯‘å™¨æ£€æŸ¥å†…å­˜å®‰å…¨çš„åŠŸèƒ½ã€‚ä½ ä»ç„¶èƒ½åœ¨ä¸å®‰å…¨å—ä¸­è·å¾—æŸç§ç¨‹åº¦çš„å®‰å…¨ã€‚

å†è€…ï¼Œunsafe ä¸æ„å‘³ç€å—ä¸­çš„ä»£ç å°±ä¸€å®šæ˜¯å±é™©çš„æˆ–è€…å¿…ç„¶å¯¼è‡´å†…å­˜å®‰å…¨é—®é¢˜ï¼šå…¶æ„å›¾åœ¨äºä½œä¸ºç¨‹åºå‘˜ä½ å°†ä¼šç¡®ä¿ unsafe å—ä¸­çš„ä»£ç ä»¥æœ‰æ•ˆçš„æ–¹å¼è®¿é—®å†…å­˜ã€‚

äººæ˜¯ä¼šçŠ¯é”™è¯¯çš„ï¼Œé”™è¯¯æ€»ä¼šå‘ç”Ÿï¼Œä¸è¿‡é€šè¿‡è¦æ±‚è¿™å››ç±»æ“ä½œå¿…é¡»ä½äºæ ‡è®°ä¸º unsafe çš„å—ä¸­ï¼Œå°±èƒ½å¤ŸçŸ¥é“ä»»ä½•ä¸å†…å­˜å®‰å…¨ç›¸å…³çš„é”™è¯¯å¿…å®šä½äº unsafe å—å†…ã€‚ä¿æŒ unsafe å—å°½å¯èƒ½å°ï¼Œå¦‚æ­¤å½“ä¹‹åè°ƒæŸ¥å†…å­˜ bug æ—¶å°±ä¼šæ„Ÿè°¢ä½ è‡ªå·±äº†ã€‚

ä¸ºäº†å°½å¯èƒ½éš”ç¦»ä¸å®‰å…¨ä»£ç ï¼Œå°†ä¸å®‰å…¨ä»£ç å°è£…è¿›ä¸€ä¸ªå®‰å…¨çš„æŠ½è±¡å¹¶æä¾›å®‰å…¨ API æ˜¯ä¸€ä¸ªå¥½ä¸»æ„ï¼Œå½“æˆ‘ä»¬å­¦ä¹ ä¸å®‰å…¨å‡½æ•°å’Œæ–¹æ³•æ—¶ä¼šè®¨è®ºåˆ°ã€‚æ ‡å‡†åº“çš„ä¸€éƒ¨åˆ†è¢«å®ç°ä¸ºåœ¨è¢«è¯„å®¡è¿‡çš„ä¸å®‰å…¨ä»£ç ä¹‹ä¸Šçš„å®‰å…¨æŠ½è±¡ã€‚è¿™ä¸ªæŠ€æœ¯é˜²æ­¢äº† unsafe æ³„éœ²åˆ°æ‰€æœ‰ä½ æˆ–è€…ç”¨æˆ·å¸Œæœ›ä½¿ç”¨ç”± unsafe ä»£ç å®ç°çš„åŠŸèƒ½çš„åœ°æ–¹ï¼Œå› ä¸ºä½¿ç”¨å…¶å®‰å…¨æŠ½è±¡æ˜¯å®‰å…¨çš„ã€‚

è®©æˆ‘ä»¬æŒ‰é¡ºåºä¾æ¬¡ä»‹ç»ä¸Šè¿°å››ä¸ªè¶…çº§åŠ›é‡ï¼ŒåŒæ—¶æˆ‘ä»¬ä¼šçœ‹åˆ°ä¸€äº›æä¾›ä¸å®‰å…¨ä»£ç çš„å®‰å…¨æ¥å£çš„æŠ½è±¡ã€‚

###### è§£å¼•ç”¨è£¸æŒ‡é’ˆ

é‚£é‡Œæåˆ°äº†ç¼–è¯‘å™¨ä¼šç¡®ä¿å¼•ç”¨æ€»æ˜¯æœ‰æ•ˆçš„ã€‚ä¸å®‰å…¨ Rust æœ‰ä¸¤ä¸ªè¢«ç§°ä¸º è£¸æŒ‡é’ˆï¼ˆraw pointersï¼‰çš„ç±»ä¼¼äºå¼•ç”¨çš„æ–°ç±»å‹ã€‚å’Œå¼•ç”¨ä¸€æ ·ï¼Œè£¸æŒ‡é’ˆæ˜¯å¯å˜æˆ–ä¸å¯å˜çš„ï¼Œåˆ†åˆ«å†™ä½œ *const T å’Œ *mut Tã€‚è¿™é‡Œçš„æ˜Ÿå·ä¸æ˜¯è§£å¼•ç”¨è¿ç®—ç¬¦ï¼›å®ƒæ˜¯ç±»å‹åç§°çš„ä¸€éƒ¨åˆ†ã€‚åœ¨è£¸æŒ‡é’ˆçš„ä¸Šä¸‹æ–‡ä¸­ï¼Œä¸å¯å˜ æ„å‘³ç€æŒ‡é’ˆè§£å¼•ç”¨ä¹‹åä¸èƒ½ç›´æ¥èµ‹å€¼ã€‚

ä¸å¼•ç”¨å’Œæ™ºèƒ½æŒ‡é’ˆçš„åŒºåˆ«åœ¨äºï¼Œè®°ä½è£¸æŒ‡é’ˆ

* å…è®¸å¿½ç•¥å€Ÿç”¨è§„åˆ™ï¼Œå¯ä»¥åŒæ—¶æ‹¥æœ‰ä¸å¯å˜å’Œå¯å˜çš„æŒ‡é’ˆï¼Œæˆ–å¤šä¸ªæŒ‡å‘ç›¸åŒä½ç½®çš„å¯å˜æŒ‡é’ˆ
* ä¸ä¿è¯æŒ‡å‘æœ‰æ•ˆçš„å†…å­˜
* å…è®¸ä¸ºç©º
* ä¸èƒ½å®ç°ä»»ä½•è‡ªåŠ¨æ¸…ç†åŠŸèƒ½

é€šè¿‡å»æ‰ Rust å¼ºåŠ çš„ä¿è¯ï¼Œä½ å¯ä»¥æ”¾å¼ƒå®‰å…¨ä¿è¯ä»¥æ¢å–æ€§èƒ½æˆ–ä½¿ç”¨å¦ä¸€ä¸ªè¯­è¨€æˆ–ç¡¬ä»¶æ¥å£çš„èƒ½åŠ›ï¼Œæ­¤æ—¶ Rust çš„ä¿è¯å¹¶ä¸é€‚ç”¨ã€‚

ä¸‹ä¾‹å±•ç¤ºäº†å¦‚ä½•ä»å¼•ç”¨åŒæ—¶åˆ›å»ºä¸å¯å˜å’Œå¯å˜è£¸æŒ‡é’ˆã€‚

```rust

#![allow(unused_variables)]
fn main() {
let mut num = 5;

let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;
}
```

æ³¨æ„è¿™é‡Œæ²¡æœ‰å¼•å…¥ unsafe å…³é”®å­—ã€‚å¯ä»¥åœ¨å®‰å…¨ä»£ç ä¸­ åˆ›å»º è£¸æŒ‡é’ˆï¼Œåªæ˜¯ä¸èƒ½åœ¨ä¸å®‰å…¨å—ä¹‹å¤– è§£å¼•ç”¨ è£¸æŒ‡é’ˆï¼Œç¨åä¾¿ä¼šçœ‹åˆ°ã€‚

è¿™é‡Œä½¿ç”¨ as å°†ä¸å¯å˜å’Œå¯å˜å¼•ç”¨å¼ºè½¬ä¸ºå¯¹åº”çš„è£¸æŒ‡é’ˆç±»å‹ã€‚å› ä¸ºç›´æ¥ä»ä¿è¯å®‰å…¨çš„å¼•ç”¨æ¥åˆ›å»ºä»–ä»¬ï¼Œå¯ä»¥çŸ¥é“è¿™äº›ç‰¹å®šçš„è£¸æŒ‡é’ˆæ˜¯æœ‰æ•ˆï¼Œä½†æ˜¯ä¸èƒ½å¯¹ä»»ä½•è£¸æŒ‡é’ˆåšå‡ºå¦‚æ­¤å‡è®¾ã€‚

æ¥ä¸‹æ¥ä¼šåˆ›å»ºä¸€ä¸ªä¸èƒ½ç¡®å®šå…¶æœ‰æ•ˆæ€§çš„è£¸æŒ‡é’ˆï¼Œç¤ºä¾‹ 19-2 å±•ç¤ºäº†å¦‚ä½•åˆ›å»ºä¸€ä¸ªæŒ‡å‘ä»»æ„å†…å­˜åœ°å€çš„è£¸æŒ‡é’ˆã€‚å°è¯•ä½¿ç”¨ä»»æ„å†…å­˜æ˜¯æœªå®šä¹‰è¡Œä¸ºï¼šæ­¤åœ°å€å¯èƒ½æœ‰æ•°æ®ä¹Ÿå¯èƒ½æ²¡æœ‰ï¼Œç¼–è¯‘å™¨å¯èƒ½ä¼šä¼˜åŒ–æ‰è¿™ä¸ªå†…å­˜è®¿é—®ï¼Œæˆ–è€…ç¨‹åºå¯èƒ½ä¼šå‡ºç°æ®µé”™è¯¯ï¼ˆsegmentation faultï¼‰ã€‚é€šå¸¸æ²¡æœ‰å¥½çš„ç†ç”±ç¼–å†™è¿™æ ·çš„ä»£ç ï¼Œä¸è¿‡å´æ˜¯å¯è¡Œçš„ï¼š

```rust

#![allow(unused_variables)]
fn main() {
let address = 0x012345usize;
let r = address as *const i32;
}
```

è¯´è¿‡å¯ä»¥åœ¨å®‰å…¨ä»£ç ä¸­åˆ›å»ºè£¸æŒ‡é’ˆï¼Œä¸è¿‡ä¸èƒ½ è§£å¼•ç”¨ è£¸æŒ‡é’ˆå’Œè¯»å–å…¶æŒ‡å‘çš„æ•°æ®ã€‚ç°åœ¨æˆ‘ä»¬è¦åšçš„å°±æ˜¯å¯¹è£¸æŒ‡é’ˆä½¿ç”¨è§£å¼•ç”¨è¿ç®—ç¬¦ *ï¼Œè¿™éœ€è¦ä¸€ä¸ª unsafe å—ï¼Œå¦‚ä¸‹ä¾‹æ‰€ç¤ºï¼š

```rust

#![allow(unused_variables)]
fn main() {
let mut num = 5;

let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;

unsafe {
    println!("r1 is: {}", *r1);
    println!("r2 is: {}", *r2);
}
}
```

åˆ›å»ºä¸€ä¸ªæŒ‡é’ˆä¸ä¼šé€ æˆä»»ä½•å±é™©ï¼›åªæœ‰å½“è®¿é—®å…¶æŒ‡å‘çš„å€¼æ—¶æ‰æœ‰å¯èƒ½é‡åˆ°æ— æ•ˆçš„å€¼ã€‚

è¿˜éœ€æ³¨æ„ç¤ºä¾‹ 19-1 å’Œ 19-3 ä¸­åˆ›å»ºäº†åŒæ—¶æŒ‡å‘ç›¸åŒå†…å­˜ä½ç½® num çš„è£¸æŒ‡é’ˆ *const i32 å’Œ *mut i32ã€‚ç›¸åå¦‚æœå°è¯•åˆ›å»º num çš„ä¸å¯å˜å’Œå¯å˜å¼•ç”¨ï¼Œè¿™å°†æ— æ³•ç¼–è¯‘å› ä¸º Rust çš„æ‰€æœ‰æƒè§„åˆ™ä¸å…è®¸æ‹¥æœ‰å¯å˜å¼•ç”¨çš„åŒæ—¶æ‹¥æœ‰ä¸å¯å˜å¼•ç”¨ã€‚é€šè¿‡è£¸æŒ‡é’ˆï¼Œå°±èƒ½å¤ŸåŒæ—¶åˆ›å»ºåŒä¸€åœ°å€çš„å¯å˜æŒ‡é’ˆå’Œä¸å¯å˜æŒ‡é’ˆï¼Œè‹¥é€šè¿‡å¯å˜æŒ‡é’ˆä¿®æ”¹æ•°æ®ï¼Œåˆ™å¯èƒ½æ½œåœ¨é€ æˆæ•°æ®ç«äº‰ã€‚è¯·å¤šåŠ å°å¿ƒï¼

æ—¢ç„¶å­˜åœ¨è¿™ä¹ˆå¤šçš„å±é™©ï¼Œä¸ºä½•è¿˜è¦ä½¿ç”¨è£¸æŒ‡é’ˆå‘¢ï¼Ÿä¸€ä¸ªä¸»è¦çš„åº”ç”¨åœºæ™¯ä¾¿æ˜¯è°ƒç”¨ C ä»£ç æ¥å£ï¼Œè¿™åœ¨ä¸‹ä¸€éƒ¨åˆ† â€œè°ƒç”¨ä¸å®‰å…¨å‡½æ•°æˆ–æ–¹æ³•â€ ä¸­ä¼šè®²åˆ°ã€‚å¦ä¸€ä¸ªåœºæ™¯æ˜¯æ„å»ºå€Ÿç”¨æ£€æŸ¥å™¨æ— æ³•ç†è§£çš„å®‰å…¨æŠ½è±¡ã€‚

###### è°ƒç”¨ä¸å®‰å…¨å‡½æ•°æˆ–æ–¹æ³•

ç¬¬äºŒç±»è¦æ±‚ä½¿ç”¨ä¸å®‰å…¨å—çš„æ“ä½œæ˜¯è°ƒç”¨ä¸å®‰å…¨å‡½æ•°ã€‚ä¸å®‰å…¨å‡½æ•°å’Œæ–¹æ³•ä¸å¸¸è§„å‡½æ•°æ–¹æ³•ååˆ†ç±»ä¼¼ï¼Œé™¤äº†å…¶å¼€å¤´æœ‰ä¸€ä¸ªé¢å¤–çš„ unsafeã€‚unsafe è¡¨æ˜æˆ‘ä»¬ä½œä¸ºç¨‹åºéœ€è¦æ»¡è¶³å…¶è¦æ±‚ï¼Œå› ä¸º Rust ä¸ä¼šä¿è¯æ»¡è¶³è¿™äº›è¦æ±‚ã€‚é€šè¿‡åœ¨ unsafe å—ä¸­è°ƒç”¨ä¸å®‰å…¨å‡½æ•°ï¼Œæˆ‘ä»¬è¡¨æ˜å·²ç»é˜…è¯»è¿‡æ­¤å‡½æ•°çš„æ–‡æ¡£å¹¶å¯¹å…¶æ˜¯å¦æ»¡è¶³å‡½æ•°è‡ªèº«çš„å¥‘çº¦è´Ÿè´£ã€‚

```rust

#![allow(unused_variables)]
fn main() {
unsafe fn dangerous() {}

unsafe {
    dangerous();
}
}
```

###### åˆ›å»ºä¸å®‰å…¨ä»£ç çš„å®‰å…¨æŠ½è±¡

ä»…ä»…å› ä¸ºå‡½æ•°åŒ…å«ä¸å®‰å…¨ä»£ç å¹¶ä¸æ„å‘³ç€æ•´ä¸ªå‡½æ•°éƒ½éœ€è¦æ ‡è®°ä¸ºä¸å®‰å…¨çš„ã€‚äº‹å®ä¸Šï¼Œå°†ä¸å®‰å…¨ä»£ç å°è£…è¿›å®‰å…¨å‡½æ•°æ˜¯ä¸€ä¸ªå¸¸è§çš„æŠ½è±¡ã€‚ä½œä¸ºä¸€ä¸ªä¾‹å­ï¼Œæ ‡å‡†åº“ä¸­çš„å‡½æ•°ï¼Œsplit_at_mutï¼Œå®ƒéœ€è¦ä¸€äº›ä¸å®‰å…¨ä»£ç ï¼Œè®©æˆ‘ä»¬æ¢ç´¢å¦‚ä½•å¯ä»¥å®ç°å®ƒã€‚è¿™ä¸ªå®‰å…¨å‡½æ•°å®šä¹‰äºå¯å˜ slice ä¹‹ä¸Šï¼šå®ƒè·å–ä¸€ä¸ª slice å¹¶ä»ç»™å®šçš„ç´¢å¼•å‚æ•°å¼€å§‹å°†å…¶åˆ†ä¸ºä¸¤ä¸ª sliceã€‚split_at_mut çš„ç”¨æ³•å¦‚ä¸‹ä¾‹ æ‰€ç¤ºï¼š

```rust

#![allow(unused_variables)]
fn main() {
let mut v = vec![1, 2, 3, 4, 5, 6];

let r = &mut v[..];

let (a, b) = r.split_at_mut(3);

assert_eq!(a, &mut [1, 2, 3]);
assert_eq!(b, &mut [4, 5, 6]);
}
```

Rust çš„å€Ÿç”¨æ£€æŸ¥å™¨ä¸èƒ½ç†è§£æˆ‘ä»¬è¦å€Ÿç”¨è¿™ä¸ª slice çš„ä¸¤ä¸ªä¸åŒéƒ¨åˆ†ï¼šå®ƒåªçŸ¥é“æˆ‘ä»¬å€Ÿç”¨äº†åŒä¸€ä¸ª slice ä¸¤æ¬¡ã€‚æœ¬è´¨ä¸Šå€Ÿç”¨ slice çš„ä¸åŒéƒ¨åˆ†æ˜¯å¯ä»¥çš„ï¼Œå› ä¸ºç»“æœä¸¤ä¸ª slice ä¸ä¼šé‡å ï¼Œä¸è¿‡ Rust è¿˜æ²¡æœ‰æ™ºèƒ½åˆ°èƒ½å¤Ÿç†è§£è¿™äº›ã€‚å½“æˆ‘ä»¬çŸ¥é“æŸäº›äº‹æ˜¯å¯ä»¥çš„è€Œ Rust ä¸çŸ¥é“çš„æ—¶å€™ï¼Œå°±æ˜¯è§¦åŠä¸å®‰å…¨ä»£ç çš„æ—¶å€™äº†

ä¸‹ä¾‹ å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ unsafe å—ï¼Œè£¸æŒ‡é’ˆå’Œä¸€äº›ä¸å®‰å…¨å‡½æ•°è°ƒç”¨æ¥å®ç° split_at_mutï¼š

```rust

#![allow(unused_variables)]
fn main() {
use std::slice;

fn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid <= len);

    unsafe {
        (slice::from_raw_parts_mut(ptr, mid),
         slice::from_raw_parts_mut(ptr.offset(mid as isize), len - mid))
    }
}
}
```

slice æ˜¯ä¸€ä¸ªæŒ‡å‘ä¸€äº›æ•°æ®çš„æŒ‡é’ˆï¼Œå¹¶å¸¦æœ‰è¯¥ slice çš„é•¿åº¦ã€‚å¯ä»¥ä½¿ç”¨ len æ–¹æ³•è·å– slice çš„é•¿åº¦ï¼Œä½¿ç”¨ as_mut_ptr æ–¹æ³•è®¿é—® slice çš„è£¸æŒ‡é’ˆã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå› ä¸ºæœ‰ä¸€ä¸ª i32 å€¼çš„å¯å˜ sliceï¼Œas_mut_ptr è¿”å›ä¸€ä¸ª *mut i32 ç±»å‹çš„è£¸æŒ‡é’ˆï¼Œå‚¨å­˜åœ¨ ptr å˜é‡ä¸­ã€‚

æˆ‘ä»¬ä¿æŒç´¢å¼• mid ä½äº slice ä¸­çš„æ–­è¨€ã€‚æ¥ç€æ˜¯ä¸å®‰å…¨ä»£ç ï¼šslice::from_raw_parts_mut å‡½æ•°è·å–ä¸€ä¸ªè£¸æŒ‡é’ˆå’Œä¸€ä¸ªé•¿åº¦æ¥åˆ›å»ºä¸€ä¸ª sliceã€‚è¿™é‡Œä½¿ç”¨æ­¤å‡½æ•°ä» ptr ä¸­åˆ›å»ºäº†ä¸€ä¸ªæœ‰ mid ä¸ªé¡¹çš„ sliceã€‚ä¹‹ååœ¨ ptr ä¸Šè°ƒç”¨ offset æ–¹æ³•å¹¶ä½¿ç”¨ mid ä½œä¸ºå‚æ•°æ¥è·å–ä¸€ä¸ªä» mid å¼€å§‹çš„è£¸æŒ‡é’ˆï¼Œä½¿ç”¨è¿™ä¸ªè£¸æŒ‡é’ˆå¹¶ä»¥ mid ä¹‹åé¡¹çš„æ•°é‡ä¸ºé•¿åº¦åˆ›å»ºä¸€ä¸ª sliceã€‚

slice::from_raw_parts_mut å‡½æ•°æ˜¯ä¸å®‰å…¨çš„å› ä¸ºå®ƒè·å–ä¸€ä¸ªè£¸æŒ‡é’ˆï¼Œå¹¶å¿…é¡»ç¡®ä¿¡è¿™ä¸ªæŒ‡é’ˆæ˜¯æœ‰æ•ˆçš„ã€‚è£¸æŒ‡é’ˆä¸Šçš„ offset æ–¹æ³•ä¹Ÿæ˜¯ä¸å®‰å…¨çš„ï¼Œå› ä¸ºå…¶å¿…é¡»ç¡®ä¿¡æ­¤åœ°å€åç§»é‡ä¹Ÿæ˜¯æœ‰æ•ˆçš„æŒ‡é’ˆã€‚å› æ­¤å¿…é¡»å°† slice::from_raw_parts_mut å’Œ offset æ”¾å…¥ unsafe å—ä¸­ä»¥ä¾¿èƒ½è°ƒç”¨å®ƒä»¬ã€‚é€šè¿‡è§‚å¯Ÿä»£ç ï¼Œå’Œå¢åŠ  mid å¿…ç„¶å°äºç­‰äº len çš„æ–­è¨€ï¼Œæˆ‘ä»¬å¯ä»¥è¯´ unsafe å—ä¸­æ‰€æœ‰çš„è£¸æŒ‡é’ˆå°†æ˜¯æœ‰æ•ˆçš„ slice ä¸­æ•°æ®çš„æŒ‡é’ˆã€‚è¿™æ˜¯ä¸€ä¸ªå¯ä»¥æ¥å—çš„ unsafe çš„æ°å½“ç”¨æ³•ã€‚

æ³¨æ„æ— éœ€å°† split_at_mut å‡½æ•°çš„ç»“æœæ ‡è®°ä¸º unsafeï¼Œå¹¶å¯ä»¥åœ¨å®‰å…¨ Rust ä¸­è°ƒç”¨æ­¤å‡½æ•°ã€‚æˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªä¸å®‰å…¨ä»£ç çš„å®‰å…¨æŠ½è±¡ï¼Œå…¶ä»£ç ä»¥ä¸€ç§å®‰å…¨çš„æ–¹å¼ä½¿ç”¨äº† unsafe ä»£ç ï¼Œå› ä¸ºå…¶åªä»è¿™ä¸ªå‡½æ•°è®¿é—®çš„æ•°æ®ä¸­åˆ›å»ºäº†æœ‰æ•ˆçš„æŒ‡é’ˆã€‚

ä¸æ­¤ç›¸å¯¹ï¼Œä¸‹ä¾‹ ä¸­çš„ slice::from_raw_parts_mut åœ¨ä½¿ç”¨ slice æ—¶å¾ˆæœ‰å¯èƒ½ä¼šå´©æºƒã€‚è¿™æ®µä»£ç è·å–ä»»æ„å†…å­˜åœ°å€å¹¶åˆ›å»ºäº†ä¸€ä¸ªé•¿ä¸ºä¸€ä¸‡çš„ sliceï¼š

```rust

#![allow(unused_variables)]
fn main() {
use std::slice;

let address = 0x01234usize;
let r = address as *mut i32;

let slice: &[i32] = unsafe {
    slice::from_raw_parts_mut(r, 10000)
};
}
```

å¹¶ä¸æ‹¥æœ‰è¿™ä¸ªä»»æ„åœ°å€çš„å†…å­˜ï¼Œä¹Ÿä¸èƒ½ä¿è¯è¿™æ®µä»£ç åˆ›å»ºçš„ slice åŒ…å«æœ‰æ•ˆçš„ i32 å€¼ã€‚è¯•å›¾ä½¿ç”¨è‡†æµ‹ä¸ºæœ‰æ•ˆçš„ slice ä¼šå¯¼è‡´æœªå®šä¹‰çš„è¡Œä¸ºã€‚

###### ä½¿ç”¨ extern å‡½æ•°è°ƒç”¨å¤–éƒ¨ä»£ç 

æœ‰æ—¶ Rust ä»£ç å¯èƒ½éœ€è¦ä¸å…¶ä»–è¯­è¨€ç¼–å†™çš„ä»£ç äº¤äº’ã€‚ä¸ºæ­¤ Rust æœ‰ä¸€ä¸ªå…³é”®å­—ï¼Œexternï¼Œæœ‰åŠ©äºåˆ›å»ºå’Œä½¿ç”¨ å¤–éƒ¨å‡½æ•°æ¥å£ï¼ˆForeign Function Interfaceï¼Œ FFIï¼‰ã€‚å¤–éƒ¨å‡½æ•°æ¥å£æ˜¯ä¸€ä¸ªç¼–ç¨‹è¯­è¨€ç”¨ä»¥å®šä¹‰å‡½æ•°çš„æ–¹å¼ï¼Œå…¶å…è®¸ä¸åŒï¼ˆå¤–éƒ¨ï¼‰ç¼–ç¨‹è¯­è¨€è°ƒç”¨è¿™äº›å‡½æ•°ã€‚

ç¤ºä¾‹ 19-8 å±•ç¤ºäº†å¦‚ä½•é›†æˆ C æ ‡å‡†åº“ä¸­çš„ abs å‡½æ•°ã€‚extern å—ä¸­å£°æ˜çš„å‡½æ•°åœ¨ Rust ä»£ç ä¸­æ€»æ˜¯ä¸å®‰å…¨çš„ã€‚å› ä¸ºå…¶ä»–è¯­è¨€ä¸ä¼šå¼ºåˆ¶æ‰§è¡Œ Rust çš„è§„åˆ™ä¸” Rust æ— æ³•æ£€æŸ¥å®ƒä»¬ï¼Œæ‰€ä»¥ç¡®ä¿å…¶å®‰å…¨æ˜¯ç¨‹åºå‘˜çš„è´£ä»»ï¼š

```rust
extern "C" {
    fn abs(input: i32) -> i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}

```

åœ¨ extern "C" å—ä¸­ï¼Œåˆ—å‡ºäº†æˆ‘ä»¬å¸Œæœ›èƒ½å¤Ÿè°ƒç”¨çš„å¦ä¸€ä¸ªè¯­è¨€ä¸­çš„å¤–éƒ¨å‡½æ•°çš„ç­¾åå’Œåç§°ã€‚"C" éƒ¨åˆ†å®šä¹‰äº†å¤–éƒ¨å‡½æ•°æ‰€ä½¿ç”¨çš„ åº”ç”¨ç¨‹åºæ¥å£ï¼ˆapplication binary interfaceï¼ŒABIï¼‰ â€”â€” ABI å®šä¹‰äº†å¦‚ä½•åœ¨æ±‡ç¼–è¯­è¨€å±‚é¢è°ƒç”¨æ­¤å‡½æ•°ã€‚"C" ABI æ˜¯æœ€å¸¸è§çš„ï¼Œå¹¶éµå¾ª C ç¼–ç¨‹è¯­è¨€çš„ ABIã€‚

##### è®¿é—®æˆ–ä¿®æ”¹å¯å˜é™æ€å˜é‡

ç›®å‰ä¸ºæ­¢éƒ½å°½é‡é¿å…è®¨è®º å…¨å±€å˜é‡ï¼ˆglobal variablesï¼‰ï¼ŒRust ç¡®å®æ”¯æŒä»–ä»¬ï¼Œä¸è¿‡è¿™å¯¹äº Rust çš„æ‰€æœ‰æƒè§„åˆ™æ¥è¯´æ˜¯æœ‰é—®é¢˜çš„ã€‚å¦‚æœæœ‰ä¸¤ä¸ªçº¿ç¨‹è®¿é—®ç›¸åŒçš„å¯å˜å…¨å±€å˜é‡ï¼Œåˆ™å¯èƒ½ä¼šé€ æˆæ•°æ®ç«äº‰ã€‚

å…¨å±€å˜é‡åœ¨ Rust ä¸­è¢«ç§°ä¸º é™æ€ï¼ˆstaticï¼‰å˜é‡ã€‚ç¤ºä¾‹ 19-9 å±•ç¤ºäº†ä¸€ä¸ªæ‹¥æœ‰å­—ç¬¦ä¸² slice å€¼çš„é™æ€å˜é‡çš„å£°æ˜å’Œåº”ç”¨ï¼š

```rust
static HELLO_WORLD: &str = "Hello, world!";

fn main() {
    println!("name is: {}", HELLO_WORLD);
}

```

static å˜é‡ç±»ä¼¼äº â€œå˜é‡å’Œå¸¸é‡çš„åŒºåˆ«â€ éƒ¨åˆ†è®¨è®ºçš„å¸¸é‡ã€‚é€šå¸¸é™æ€å˜é‡çš„åç§°é‡‡ç”¨ SCREAMING_SNAKE_CASE å†™æ³•ï¼Œå¹¶ å¿…é¡» æ ‡æ³¨å˜é‡çš„ç±»å‹ï¼Œåœ¨è¿™ä¸ªä¾‹å­ä¸­æ˜¯ &'static strã€‚é™æ€å˜é‡åªèƒ½å‚¨å­˜æ‹¥æœ‰ 'static ç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨ï¼Œè¿™æ„å‘³ç€ Rust ç¼–è¯‘å™¨å¯ä»¥è‡ªå·±è®¡ç®—å‡ºå…¶ç”Ÿå‘½å‘¨æœŸè€Œæ— éœ€æ˜¾å¼æ ‡æ³¨ã€‚è®¿é—®ä¸å¯å˜é™æ€å˜é‡æ˜¯å®‰å…¨çš„ã€‚

å¸¸é‡ä¸ä¸å¯å˜é™æ€å˜é‡å¯èƒ½çœ‹èµ·æ¥å¾ˆç±»ä¼¼ï¼Œä¸è¿‡ä¸€ä¸ªå¾®å¦™çš„åŒºåˆ«æ˜¯é™æ€å˜é‡ä¸­çš„å€¼æœ‰ä¸€ä¸ªå›ºå®šçš„å†…å­˜åœ°å€ã€‚ä½¿ç”¨è¿™ä¸ªå€¼æ€»æ˜¯ä¼šè®¿é—®ç›¸åŒçš„åœ°å€ã€‚å¦ä¸€æ–¹é¢ï¼Œå¸¸é‡åˆ™å…è®¸åœ¨ä»»ä½•è¢«ç”¨åˆ°çš„æ—¶å€™å¤åˆ¶å…¶æ•°æ®ã€‚

å¸¸é‡ä¸é™æ€å˜é‡çš„å¦ä¸€ä¸ªåŒºåˆ«åœ¨äºé™æ€å˜é‡å¯ä»¥æ˜¯å¯å˜çš„ã€‚è®¿é—®å’Œä¿®æ”¹å¯å˜é™æ€å˜é‡éƒ½æ˜¯ ä¸å®‰å…¨ çš„ã€‚ä¸‹ä¾‹ å±•ç¤ºäº†å¦‚ä½•å£°æ˜ã€è®¿é—®å’Œä¿®æ”¹åä¸º COUNTER çš„å¯å˜é™æ€å˜é‡ï¼š

```rust
static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!("COUNTER: {}", COUNTER);
    }
}

```

å°±åƒå¸¸è§„å˜é‡ä¸€æ ·ï¼Œæˆ‘ä»¬ä½¿ç”¨ mut å…³é”®æ¥æŒ‡å®šå¯å˜æ€§ã€‚ä»»ä½•è¯»å†™ COUNTER çš„ä»£ç éƒ½å¿…é¡»ä½äº unsafe å—ä¸­ã€‚è¿™æ®µä»£ç å¯ä»¥ç¼–è¯‘å¹¶å¦‚æœŸæ‰“å°å‡º COUNTER: 3ï¼Œå› ä¸ºè¿™æ˜¯å•çº¿ç¨‹çš„ã€‚æ‹¥æœ‰å¤šä¸ªçº¿ç¨‹è®¿é—® COUNTER åˆ™å¯èƒ½å¯¼è‡´æ•°æ®ç«äº‰ã€‚

æ‹¥æœ‰å¯ä»¥å…¨å±€è®¿é—®çš„å¯å˜æ•°æ®ï¼Œéš¾ä»¥ä¿è¯ä¸å­˜åœ¨æ•°æ®ç«äº‰ï¼Œè¿™å°±æ˜¯ä¸ºä½• Rust è®¤ä¸ºå¯å˜é™æ€å˜é‡æ˜¯ä¸å®‰å…¨çš„ã€‚ä»»ä½•å¯èƒ½çš„æƒ…å†µï¼Œè¯·ä¼˜å…ˆä½¿ç”¨ç¬¬åå…­ç« è®¨è®ºçš„å¹¶å‘æŠ€æœ¯å’Œçº¿ç¨‹å®‰å…¨æ™ºèƒ½æŒ‡é’ˆï¼Œè¿™æ ·ç¼–è¯‘å™¨å°±èƒ½æ£€æµ‹ä¸åŒçº¿ç¨‹é—´çš„æ•°æ®è®¿é—®æ˜¯å¦æ˜¯å®‰å…¨çš„ã€‚

##### å®ç°ä¸å®‰å…¨ trait

æœ€åä¸€ä¸ªåªèƒ½ç”¨åœ¨ unsafe ä¸­çš„æ“ä½œæ˜¯å®ç°ä¸å®‰å…¨ traitã€‚å½“è‡³å°‘æœ‰ä¸€ä¸ªæ–¹æ³•ä¸­åŒ…å«ç¼–è¯‘å™¨ä¸èƒ½éªŒè¯çš„ä¸å˜é‡æ—¶ trait æ˜¯ä¸å®‰å…¨çš„ã€‚å¯ä»¥åœ¨ trait ä¹‹å‰å¢åŠ  unsafe å…³é”®å­—å°† trait å£°æ˜ä¸º unsafeï¼ŒåŒæ—¶ trait çš„å®ç°ä¹Ÿå¿…é¡»æ ‡è®°ä¸º unsafeï¼Œ

```rust

#![allow(unused_variables)]
fn main() {
unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}
}
```

#### é«˜çº§ trait

##### å…³è”ç±»å‹åœ¨ trait å®šä¹‰ä¸­æŒ‡å®šå ä½ç¬¦ç±»å‹

å…³è”ç±»å‹ï¼ˆassociated typesï¼‰æ˜¯ä¸€ä¸ªå°†ç±»å‹å ä½ç¬¦ä¸ trait ç›¸å…³è”çš„æ–¹å¼ï¼Œè¿™æ · trait çš„æ–¹æ³•ç­¾åä¸­å°±å¯ä»¥ä½¿ç”¨è¿™äº›å ä½ç¬¦ç±»å‹ã€‚trait çš„å®ç°è€…ä¼šé’ˆå¯¹ç‰¹å®šçš„å®ç°åœ¨è¿™ä¸ªç±»å‹çš„ä½ç½®æŒ‡å®šç›¸åº”çš„å…·ä½“ç±»å‹ã€‚å¦‚æ­¤å¯ä»¥å®šä¹‰ä¸€ä¸ªä½¿ç”¨å¤šç§ç±»å‹çš„ traitï¼Œç›´åˆ°å®ç°æ­¤ trait æ—¶éƒ½æ— éœ€çŸ¥é“è¿™äº›ç±»å‹å…·ä½“æ˜¯ä»€ä¹ˆã€‚

æœ¬ç« æ‰€æè¿°çš„å¤§éƒ¨åˆ†å†…å®¹éƒ½éå¸¸å°‘è§ã€‚å…³è”ç±»å‹åˆ™æ¯”è¾ƒé€‚ä¸­ï¼›å®ƒä»¬æ¯”æœ¬ä¹¦å…¶ä»–çš„å†…å®¹è¦å°‘è§ï¼Œä¸è¿‡æ¯”æœ¬ç« ä¸­çš„å¾ˆå¤šå†…å®¹è¦æ›´å¸¸è§ã€‚

ä¸€ä¸ªå¸¦æœ‰å…³è”ç±»å‹çš„ trait çš„ä¾‹å­æ˜¯æ ‡å‡†åº“æä¾›çš„ Iterator traitã€‚å®ƒæœ‰ä¸€ä¸ªå«åš Item çš„å…³è”ç±»å‹æ¥æ›¿ä»£éå†çš„å€¼çš„ç±»å‹ã€‚

```rust

#![allow(unused_variables)]
fn main() {
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}
}
```

Item æ˜¯ä¸€ä¸ªå ä½ç±»å‹ï¼ŒåŒæ—¶ next æ–¹æ³•å®šä¹‰è¡¨æ˜å®ƒè¿”å› Option<Self::Item> ç±»å‹çš„å€¼ã€‚è¿™ä¸ª trait çš„å®ç°è€…ä¼šæŒ‡å®š Item çš„å…·ä½“ç±»å‹ï¼Œç„¶è€Œä¸ç®¡å®ç°è€…æŒ‡å®šä½•ç§ç±»å‹, next æ–¹æ³•éƒ½ä¼šè¿”å›ä¸€ä¸ªåŒ…å«äº†æ­¤å…·ä½“ç±»å‹å€¼çš„ Optionã€‚

å…³è”ç±»å‹çœ‹èµ·æ¥åƒä¸€ä¸ªç±»ä¼¼æ³›å‹çš„æ¦‚å¿µï¼Œå› ä¸ºå®ƒå…è®¸å®šä¹‰ä¸€ä¸ªå‡½æ•°è€Œä¸æŒ‡å®šå…¶å¯ä»¥å¤„ç†çš„ç±»å‹ã€‚é‚£ä¹ˆä¸ºä»€ä¹ˆè¦ä½¿ç”¨å…³è”ç±»å‹å‘¢ï¼Ÿ

è®©æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªåœ¨ç¬¬åä¸‰ç« ä¸­å‡ºç°çš„ Counter ç»“æ„ä½“ä¸Šå®ç° Iterator trait çš„ä¾‹å­æ¥æ£€è§†å…¶ä¸­çš„åŒºåˆ«ã€‚åœ¨ä¸‹ä¾‹ä¸­ï¼ŒæŒ‡å®šäº† Item çš„ç±»å‹ä¸º u32ï¼š

```rust
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        // --snip--

```

##### é»˜è®¤æ³›å‹ç±»å‹å‚æ•°å’Œè¿ç®—ç¬¦é‡è½½

å½“ä½¿ç”¨æ³›å‹ç±»å‹å‚æ•°æ—¶ï¼Œå¯ä»¥ä¸ºæ³›å‹æŒ‡å®šä¸€ä¸ªé»˜è®¤çš„å…·ä½“ç±»å‹ã€‚å¦‚æœé»˜è®¤ç±»å‹å°±è¶³å¤Ÿçš„è¯ï¼Œè¿™æ¶ˆé™¤äº†ä¸ºå…·ä½“ç±»å‹å®ç° trait çš„éœ€è¦ã€‚ä¸ºæ³›å‹ç±»å‹æŒ‡å®šé»˜è®¤ç±»å‹çš„è¯­æ³•æ˜¯åœ¨å£°æ˜æ³›å‹ç±»å‹æ—¶ä½¿ç”¨ `<PlaceholderType=ConcreteType>`ã€‚

è¿™ç§æƒ…å†µçš„ä¸€ä¸ªéå¸¸å¥½çš„ä¾‹å­æ˜¯ç”¨äºè¿ç®—ç¬¦é‡è½½ã€‚è¿ç®—ç¬¦é‡è½½ï¼ˆOperator overloadingï¼‰æ˜¯æŒ‡åœ¨ç‰¹å®šæƒ…å†µä¸‹è‡ªå®šä¹‰è¿ç®—ç¬¦ï¼ˆæ¯”å¦‚ +ï¼‰è¡Œä¸ºçš„æ“ä½œã€‚

Rust å¹¶ä¸å…è®¸åˆ›å»ºè‡ªå®šä¹‰è¿ç®—ç¬¦æˆ–é‡è½½ä»»æ„è¿ç®—ç¬¦ï¼Œä¸è¿‡ std::ops ä¸­æ‰€åˆ—å‡ºçš„è¿ç®—ç¬¦å’Œç›¸åº”çš„ trait å¯ä»¥é€šè¿‡å®ç°è¿ç®—ç¬¦ç›¸å…³ trait æ¥é‡è½½ã€‚ä¾‹å¦‚ï¼Œä¸‹ä¾‹ ä¸­å±•ç¤ºäº†å¦‚ä½•åœ¨ Point ç»“æ„ä½“ä¸Šå®ç° Add trait æ¥é‡è½½ + è¿ç®—ç¬¦ï¼Œè¿™æ ·å°±å¯ä»¥å°†ä¸¤ä¸ª Point å®ä¾‹ç›¸åŠ äº†ï¼š

```rust
use std::ops::Add;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
               Point { x: 3, y: 3 });
}

```

add æ–¹æ³•å°†ä¸¤ä¸ª Point å®ä¾‹çš„ x å€¼å’Œ y å€¼åˆ†åˆ«ç›¸åŠ æ¥åˆ›å»ºä¸€ä¸ªæ–°çš„ Pointã€‚Add trait æœ‰ä¸€ä¸ªå«åš Output çš„å…³è”ç±»å‹ï¼Œå®ƒç”¨æ¥å†³å®š add æ–¹æ³•çš„è¿”å›å€¼ç±»å‹ã€‚

è¿™é‡Œé»˜è®¤æ³›å‹ç±»å‹ä½äº Add trait ä¸­ã€‚è¿™é‡Œæ˜¯å…¶å®šä¹‰ï¼š

```rust

#![allow(unused_variables)]
fn main() {
trait Add<RHS=Self> {
    type Output;

    fn add(self, rhs: RHS) -> Self::Output;
}
}
```

è¿™çœ‹æ¥åº”è¯¥å¾ˆç†Ÿæ‚‰ï¼Œè¿™æ˜¯ä¸€ä¸ªå¸¦æœ‰ä¸€ä¸ªæ–¹æ³•å’Œä¸€ä¸ªå…³è”ç±»å‹çš„ traitã€‚æ¯”è¾ƒé™Œç”Ÿçš„éƒ¨åˆ†æ˜¯å°–æ‹¬å·ä¸­çš„ RHS=Selfï¼šè¿™ä¸ªè¯­æ³•å«åš é»˜è®¤ç±»å‹å‚æ•°ï¼ˆdefault type parametersï¼‰ã€‚RHS æ˜¯ä¸€ä¸ªæ³›å‹ç±»å‹å‚æ•°ï¼ˆâ€œright hand sideâ€ çš„ç¼©å†™ï¼‰ï¼Œå®ƒç”¨äºå®šä¹‰ add æ–¹æ³•ä¸­çš„ rhs å‚æ•°ã€‚å¦‚æœå®ç° Add trait æ—¶ä¸æŒ‡å®š RHS çš„å…·ä½“ç±»å‹ï¼ŒRHS çš„ç±»å‹å°†æ˜¯é»˜è®¤çš„ Self ç±»å‹ï¼Œä¹Ÿå°±æ˜¯åœ¨å…¶ä¸Šå®ç° Add çš„ç±»å‹ã€‚

å½“ä¸º Point å®ç° Add æ—¶ï¼Œä½¿ç”¨äº†é»˜è®¤çš„ RHSï¼Œå› ä¸ºæˆ‘ä»¬å¸Œæœ›å°†ä¸¤ä¸ª Point å®ä¾‹ç›¸åŠ ã€‚è®©æˆ‘ä»¬çœ‹çœ‹ä¸€ä¸ªå®ç° Add trait æ—¶å¸Œæœ›è‡ªå®šä¹‰ RHS ç±»å‹è€Œä¸æ˜¯ä½¿ç”¨é»˜è®¤ç±»å‹çš„ä¾‹å­

è¿™é‡Œæœ‰ä¸¤ä¸ªå­˜æ”¾ä¸åŒå•å…ƒå€¼çš„ç»“æ„ä½“ï¼ŒMillimeters å’Œ Metersã€‚æˆ‘ä»¬å¸Œæœ›èƒ½å¤Ÿå°†æ¯«ç±³å€¼ä¸ç±³å€¼ç›¸åŠ ï¼Œå¹¶è®© Add çš„å®ç°æ­£ç¡®å¤„ç†è½¬æ¢ã€‚å¯ä»¥ä¸º Millimeters å®ç° Add å¹¶ä»¥ Meters ä½œä¸º RHSï¼Œå¦‚ä¸‹é¢æ‰€ç¤º

```rust

#![allow(unused_variables)]
fn main() {
use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add<Meters> for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -> Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
}
```

ä¸ºäº†ä½¿ Millimeters å’Œ Meters èƒ½å¤Ÿç›¸åŠ ï¼Œæˆ‘ä»¬æŒ‡å®š `impl Add<Meters>` æ¥è®¾å®š RHS ç±»å‹å‚æ•°çš„å€¼è€Œä¸æ˜¯ä½¿ç”¨é»˜è®¤çš„ Selfã€‚

é»˜è®¤å‚æ•°ç±»å‹ä¸»è¦ç”¨äºå¦‚ä¸‹ä¸¤ä¸ªæ–¹é¢ï¼š

* æ‰©å±•ç±»å‹è€Œä¸ç ´åç°æœ‰ä»£ç ã€‚
* åœ¨å¤§éƒ¨åˆ†ç”¨æˆ·éƒ½ä¸éœ€è¦çš„ç‰¹å®šæƒ…å†µè¿›è¡Œè‡ªå®šä¹‰ã€‚

æ ‡å‡†åº“çš„ Add trait å°±æ˜¯ä¸€ä¸ªç¬¬äºŒä¸ªç›®çš„ä¾‹å­ï¼šå¤§éƒ¨åˆ†æ—¶å€™ä½ ä¼šå°†ä¸¤ä¸ªç›¸ä¼¼çš„ç±»å‹ç›¸åŠ ï¼Œä¸è¿‡å®ƒæä¾›äº†è‡ªå®šä¹‰é¢å¤–è¡Œä¸ºçš„èƒ½åŠ›ã€‚åœ¨ Add trait å®šä¹‰ä¸­ä½¿ç”¨é»˜è®¤ç±»å‹å‚æ•°æ„å‘³ç€å¤§éƒ¨åˆ†æ—¶å€™æ— éœ€æŒ‡å®šé¢å¤–çš„å‚æ•°ã€‚æ¢å¥è¯è¯´ï¼Œä¸€å°éƒ¨åˆ†å®ç°çš„æ ·æ¿ä»£ç æ˜¯ä¸å¿…è¦çš„ï¼Œè¿™æ ·ä½¿ç”¨ trait å°±æ›´å®¹æ˜“äº†ã€‚

ç¬¬ä¸€ä¸ªç›®çš„æ˜¯ç›¸ä¼¼çš„ï¼Œä½†è¿‡ç¨‹æ˜¯åè¿‡æ¥çš„ï¼šå¦‚æœéœ€è¦ä¸ºç°æœ‰ trait å¢åŠ ç±»å‹å‚æ•°ï¼Œä¸ºå…¶æä¾›ä¸€ä¸ªé»˜è®¤ç±»å‹å°†å…è®¸æˆ‘ä»¬åœ¨ä¸ç ´åç°æœ‰å®ç°ä»£ç çš„åŸºç¡€ä¸Šæ‰©å±• trait çš„åŠŸèƒ½ã€‚

###### å®Œå…¨é™å®šè¯­æ³•ä¸æ¶ˆæ­§ä¹‰ï¼šè°ƒç”¨ç›¸åŒåç§°çš„æ–¹æ³•

Rust æ—¢ä¸èƒ½é¿å…ä¸€ä¸ª trait ä¸å¦ä¸€ä¸ª trait æ‹¥æœ‰ç›¸åŒåç§°çš„æ–¹æ³•ï¼Œä¹Ÿä¸èƒ½é˜»æ­¢ä¸ºåŒä¸€ç±»å‹åŒæ—¶å®ç°è¿™ä¸¤ä¸ª traitã€‚ç”šè‡³ç›´æ¥åœ¨ç±»å‹ä¸Šå®ç°å¼€å§‹å·²ç»æœ‰çš„åŒåæ–¹æ³•ä¹Ÿæ˜¯å¯èƒ½çš„ï¼

```rust

#![allow(unused_variables)]
fn main() {
trait Pilot {
    fn fly(&self);
}

trait Wizard {
    fn fly(&self);
}

struct Human;

impl Pilot for Human {
    fn fly(&self) {
        println!("This is your captain speaking.");
    }
}

impl Wizard for Human {
    fn fly(&self) {
        println!("Up!");
    }
}

impl Human {
    fn fly(&self) {
        println!("*waving arms furiously*");
    }
}
}
```

 ä¸¤ä¸ª trait å®šä¹‰ä¸ºæ‹¥æœ‰ fly æ–¹æ³•ï¼Œå¹¶åœ¨ç›´æ¥å®šä¹‰æœ‰ fly æ–¹æ³•çš„ Human ç±»å‹ä¸Šå®ç°è¿™ä¸¤ä¸ª trait

å½“è°ƒç”¨ Human å®ä¾‹çš„ fly æ—¶ï¼Œç¼–è¯‘å™¨é»˜è®¤è°ƒç”¨ç›´æ¥æ˜¯ç°åœ¨ç±»å‹ä¸Šçš„æ–¹æ³•

ç„¶è€Œï¼Œå…³è”å‡½æ•°æ˜¯ trait çš„ä¸€éƒ¨åˆ†ï¼Œä½†æ²¡æœ‰ self å‚æ•°ã€‚å½“åŒä¸€ä½œç”¨åŸŸçš„ä¸¤ä¸ªç±»å‹å®ç°äº†åŒä¸€ traitï¼ŒRust å°±ä¸èƒ½è®¡ç®—å‡ºæˆ‘ä»¬æœŸæœ›çš„æ˜¯å“ªä¸€ä¸ªç±»å‹ï¼Œé™¤éä½¿ç”¨ å®Œå…¨é™å®šè¯­æ³•ï¼ˆfully qualified syntaxï¼‰ã€‚ä¾‹å¦‚ï¼Œæ‹¿ä¸‹ä¾‹ ä¸­çš„ Animal trait æ¥è¯´ï¼Œå®ƒæœ‰å…³è”å‡½æ•° baby_nameï¼Œç»“æ„ä½“ Dog å®ç°äº† Animalï¼ŒåŒæ—¶æœ‰å…³è”å‡½æ•° baby_name ç›´æ¥å®šä¹‰äº Dog ä¹‹ä¸Šï¼š

```rust
trait Animal {
    fn baby_name() -> String;
}

struct Dog;

impl Dog {
    fn baby_name() -> String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -> String {
        String::from("puppy")
    }
}

fn main() {
    println!("A baby dog is called a {}", Dog::baby_name());
}

```

è¿™æ®µä»£ç ç”¨äºä¸€ä¸ªåŠ¨ç‰©æ”¶å®¹æ‰€ï¼Œä»–ä»¬å°†æ‰€æœ‰çš„å°ç‹—èµ·åä¸º Spotï¼Œè¿™å®ç°ä¸ºå®šä¹‰äº Dog ä¹‹ä¸Šçš„å…³è”å‡½æ•° baby_nameã€‚Dog ç±»å‹è¿˜å®ç°äº† Animal traitï¼Œå®ƒæè¿°äº†æ‰€æœ‰åŠ¨ç‰©çš„å…±æœ‰çš„ç‰¹å¾ã€‚å°ç‹—è¢«ç§°ä¸º puppyï¼Œè¿™è¡¨ç°ä¸º Dog çš„ Animal trait å®ç°ä¸­ä¸ Animal trait ç›¸å…³è”çš„å‡½æ•° baby_nameã€‚

åœ¨ main è°ƒç”¨äº† Dog::baby_name å‡½æ•°ï¼Œå®ƒç›´æ¥è°ƒç”¨äº†å®šä¹‰äº Dog ä¹‹ä¸Šçš„å…³è”å‡½æ•°ã€‚è¿™æ®µä»£ç ä¼šæ‰“å°å‡ºï¼š

```
A baby dog is called a Spot
```

å¯¹äºå…³è”å‡½æ•°ï¼Œå…¶æ²¡æœ‰ä¸€ä¸ª receiverï¼Œæ•…åªä¼šæœ‰å…¶ä»–å‚æ•°çš„åˆ—è¡¨ã€‚å¯ä»¥é€‰æ‹©åœ¨ä»»ä½•å‡½æ•°æˆ–æ–¹æ³•è°ƒç”¨å¤„ä½¿ç”¨å®Œå…¨é™å®šè¯­æ³•ã€‚ç„¶è€Œï¼Œå…è®¸çœç•¥ä»»ä½• Rust èƒ½å¤Ÿä»ç¨‹åºä¸­çš„å…¶ä»–ä¿¡æ¯ä¸­è®¡ç®—å‡ºçš„éƒ¨åˆ†ã€‚åªæœ‰å½“å­˜åœ¨å¤šä¸ªåŒåå®ç°è€Œ Rust éœ€è¦å¸®åŠ©ä»¥ä¾¿çŸ¥é“æˆ‘ä»¬å¸Œæœ›è°ƒç”¨å“ªä¸ªå®ç°æ—¶ï¼Œæ‰éœ€è¦ä½¿ç”¨è¿™ä¸ªè¾ƒä¸ºå†—é•¿çš„è¯­æ³•ã€‚

###### çˆ¶ trait ç”¨äºåœ¨å¦ä¸€ä¸ª trait ä¸­ä½¿ç”¨æŸ trait çš„åŠŸèƒ½

æœ‰æ—¶æˆ‘ä»¬å¯èƒ½ä¼šéœ€è¦æŸä¸ª trait ä½¿ç”¨å¦ä¸€ä¸ª trait çš„åŠŸèƒ½ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œéœ€è¦èƒ½å¤Ÿä¾èµ–ç›¸å…³çš„ trait ä¹Ÿè¢«å®ç°ã€‚è¿™ä¸ªæ‰€éœ€çš„ trait æ˜¯æˆ‘ä»¬å®ç°çš„ trait çš„ çˆ¶ï¼ˆè¶…ï¼‰ traitï¼ˆsupertraitï¼‰ã€‚

```rust

#![allow(unused_variables)]
fn main() {
use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {} *", output);
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}
}
```

å› ä¸ºæŒ‡å®šäº† OutlinePrint éœ€è¦ Display traitï¼Œåˆ™å¯ä»¥åœ¨ outline_print ä¸­ä½¿ç”¨ to_stringï¼Œ å…¶ä¼šä¸ºä»»ä½•å®ç° Display çš„ç±»å‹è‡ªåŠ¨å®ç°ã€‚å¦‚æœä¸åœ¨ trait ååå¢åŠ  : Display å¹¶å°è¯•åœ¨ outline_print ä¸­ä½¿ç”¨ to_stringï¼Œåˆ™ä¼šå¾—åˆ°ä¸€ä¸ªé”™è¯¯è¯´åœ¨å½“å‰ä½œç”¨åŸŸä¸­æ²¡æœ‰æ‰¾åˆ°ç”¨äº &Self ç±»å‹çš„æ–¹æ³• to_stringã€‚

è®©æˆ‘ä»¬çœ‹çœ‹å¦‚æœå°è¯•åœ¨ä¸€ä¸ªæ²¡æœ‰å®ç° Display çš„ç±»å‹ä¸Šå®ç° OutlinePrint ä¼šå‘ç”Ÿä»€ä¹ˆï¼Œæ¯”å¦‚ Point ç»“æ„ä½“ï¼š

```rust

#![allow(unused_variables)]
fn main() {
trait OutlinePrint {}
struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
}
```

```rust

#![allow(unused_variables)]
fn main() {
struct Point {
    x: i32,
    y: i32,
}

use std::fmt;

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
}
```

##### newtype æ¨¡å¼ç”¨ä»¥åœ¨å¤–éƒ¨ç±»å‹ä¸Šå®ç°å¤–éƒ¨ trait

æåˆ°äº†å­¤å„¿è§„åˆ™ï¼ˆorphan ruleï¼‰ï¼Œå®ƒè¯´æ˜åªè¦ trait æˆ–ç±»å‹å¯¹äºå½“å‰ crate æ˜¯æœ¬åœ°çš„è¯å°±å¯ä»¥åœ¨æ­¤ç±»å‹ä¸Šå®ç°è¯¥ traitã€‚ä¸€ä¸ªç»•å¼€è¿™ä¸ªé™åˆ¶çš„æ–¹æ³•æ˜¯ä½¿ç”¨ newtype æ¨¡å¼ï¼ˆnewtype patternï¼‰ï¼Œå®ƒæ¶‰åŠåˆ°åœ¨ä¸€ä¸ªå…ƒç»„ç»“æ„ä½“ï¼ˆç¬¬äº”ç«  â€œç”¨æ²¡æœ‰å‘½åå­—æ®µçš„å…ƒç»„ç»“æ„ä½“æ¥åˆ›å»ºä¸åŒçš„ç±»å‹â€ éƒ¨åˆ†ä»‹ç»äº†å…ƒç»„ç»“æ„ä½“ï¼‰ä¸­åˆ›å»ºä¸€ä¸ªæ–°ç±»å‹ã€‚è¿™ä¸ªå…ƒç»„ç»“æ„ä½“å¸¦æœ‰ä¸€ä¸ªå­—æ®µä½œä¸ºå¸Œæœ›å®ç° trait çš„ç±»å‹çš„ç®€å•å°è£…ã€‚æ¥ç€è¿™ä¸ªå°è£…ç±»å‹å¯¹äº crate æ˜¯æœ¬åœ°çš„ï¼Œè¿™æ ·å°±å¯ä»¥åœ¨è¿™ä¸ªå°è£…ä¸Šå®ç° traitã€‚Newtype æ˜¯ä¸€ä¸ªæºè‡ªï¼ˆU.C.0079ï¼Œé€ƒï¼‰Haskell ç¼–ç¨‹è¯­è¨€çš„æ¦‚å¿µã€‚ä½¿ç”¨è¿™ä¸ªæ¨¡å¼æ²¡æœ‰è¿è¡Œæ—¶æ€§èƒ½æƒ©ç½šï¼Œè¿™ä¸ªå°è£…ç±»å‹åœ¨ç¼–è¯‘æ—¶å°±è¢«çœç•¥äº†ã€‚

```rust
use std::fmt;

struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {}", w);
}

```

Display çš„å®ç°ä½¿ç”¨ self.0 æ¥è®¿é—®å…¶å†…éƒ¨çš„ `Vec<T>`ï¼Œå› ä¸º Wrapper æ˜¯å…ƒç»„ç»“æ„ä½“è€Œ `Vec<T>` æ˜¯ç»“æ„ä½“æ€»ä½äºç´¢å¼• 0 çš„é¡¹ã€‚æ¥ç€å°±å¯ä»¥ä½¿ç”¨ Wrapper ä¸­ Display çš„åŠŸèƒ½äº†ã€‚

æ­¤æ–¹æ³•çš„ç¼ºç‚¹æ˜¯ï¼Œå› ä¸º Wrapper æ˜¯ä¸€ä¸ªæ–°ç±»å‹ï¼Œå®ƒæ²¡æœ‰å®šä¹‰äºå…¶å€¼ä¹‹ä¸Šçš„æ–¹æ³•ï¼›å¿…é¡»ç›´æ¥åœ¨ Wrapper ä¸Šå®ç° `Vec<T>` çš„æ‰€æœ‰æ–¹æ³•ï¼Œè¿™æ ·å°±å¯ä»¥ä»£ç†åˆ°self.0 ä¸Š â€”â€” è¿™å°±å…è®¸æˆ‘ä»¬å®Œå…¨åƒ `Vec<T>` é‚£æ ·å¯¹å¾… Wrapperã€‚å¦‚æœå¸Œæœ›æ–°ç±»å‹æ‹¥æœ‰å…¶å†…éƒ¨ç±»å‹çš„æ¯ä¸€ä¸ªæ–¹æ³•ï¼Œä¸ºå°è£…ç±»å‹å®ç° Deref traitï¼ˆç¬¬åäº”ç«  â€œé€šè¿‡ Deref trait å°†æ™ºèƒ½æŒ‡é’ˆå½“ä½œå¸¸è§„å¼•ç”¨å¤„ç†â€ éƒ¨åˆ†è®¨è®ºè¿‡ï¼‰å¹¶è¿”å›å…¶å†…éƒ¨ç±»å‹æ˜¯ä¸€ç§è§£å†³æ–¹æ¡ˆã€‚å¦‚æœä¸å¸Œæœ›å°è£…ç±»å‹æ‹¥æœ‰æ‰€æœ‰å†…éƒ¨ç±»å‹çš„æ–¹æ³• â€”â€” æ¯”å¦‚ä¸ºäº†é™åˆ¶å°è£…ç±»å‹çš„è¡Œä¸º â€”â€” åˆ™å¿…é¡»åªè‡ªè¡Œå®ç°æ‰€éœ€çš„æ–¹æ³•ã€‚

#### é«˜çº§ç±»å‹
